// Code generated by ent, DO NOT EDIT.

package ent

import (
	"affluo/ent/banner"
	"affluo/ent/bannercreative"
	"affluo/ent/bannerstats"
	"affluo/ent/campaign"
	"affluo/ent/campaignlink"
	"affluo/ent/lead"
	"affluo/ent/payout"
	"affluo/ent/post"
	"affluo/ent/predicate"
	"affluo/ent/referral"
	"affluo/ent/schema"
	"affluo/ent/track"
	"affluo/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBanner         = "Banner"
	TypeBannerCreative = "BannerCreative"
	TypeBannerStats    = "BannerStats"
	TypeCampaign       = "Campaign"
	TypeCampaignLink   = "CampaignLink"
	TypeLead           = "Lead"
	TypePayout         = "Payout"
	TypePost           = "Post"
	TypeReferral       = "Referral"
	TypeTest           = "Test"
	TypeTrack          = "Track"
	TypeUser           = "User"
)

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	description             *string
	_type                   *banner.Type
	click_url               *string
	size                    *string
	status                  *banner.Status
	allowed_countries       *[]string
	appendallowed_countries []string
	weight                  *int
	addweight               *int
	smart_weight            *float64
	addsmart_weight         *float64
	last_impression         *time.Time
	start_date              *time.Time
	end_date                *time.Time
	allowed_devices         *[]string
	appendallowed_devices   []string
	allowed_browsers        *[]string
	appendallowed_browsers  []string
	allowed_os              *[]string
	appendallowed_os        []string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	campaigns               map[int64]struct{}
	removedcampaigns        map[int64]struct{}
	clearedcampaigns        bool
	creatives               map[int64]struct{}
	removedcreatives        map[int64]struct{}
	clearedcreatives        bool
	stats                   map[int64]struct{}
	removedstats            map[int64]struct{}
	clearedstats            bool
	leads                   map[int64]struct{}
	removedleads            map[int64]struct{}
	clearedleads            bool
	done                    bool
	oldValue                func(context.Context) (*Banner, error)
	predicates              []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id int64) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Banner entities.
func (m *BannerMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Banner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BannerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BannerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BannerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BannerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[banner.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BannerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[banner.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BannerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, banner.FieldDescription)
}

// SetType sets the "type" field.
func (m *BannerMutation) SetType(b banner.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BannerMutation) GetType() (r banner.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldType(ctx context.Context) (v banner.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BannerMutation) ResetType() {
	m._type = nil
}

// SetClickURL sets the "click_url" field.
func (m *BannerMutation) SetClickURL(s string) {
	m.click_url = &s
}

// ClickURL returns the value of the "click_url" field in the mutation.
func (m *BannerMutation) ClickURL() (r string, exists bool) {
	v := m.click_url
	if v == nil {
		return
	}
	return *v, true
}

// OldClickURL returns the old "click_url" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldClickURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickURL: %w", err)
	}
	return oldValue.ClickURL, nil
}

// ClearClickURL clears the value of the "click_url" field.
func (m *BannerMutation) ClearClickURL() {
	m.click_url = nil
	m.clearedFields[banner.FieldClickURL] = struct{}{}
}

// ClickURLCleared returns if the "click_url" field was cleared in this mutation.
func (m *BannerMutation) ClickURLCleared() bool {
	_, ok := m.clearedFields[banner.FieldClickURL]
	return ok
}

// ResetClickURL resets all changes to the "click_url" field.
func (m *BannerMutation) ResetClickURL() {
	m.click_url = nil
	delete(m.clearedFields, banner.FieldClickURL)
}

// SetSize sets the "size" field.
func (m *BannerMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *BannerMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *BannerMutation) ResetSize() {
	m.size = nil
}

// SetStatus sets the "status" field.
func (m *BannerMutation) SetStatus(b banner.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BannerMutation) Status() (r banner.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldStatus(ctx context.Context) (v banner.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BannerMutation) ResetStatus() {
	m.status = nil
}

// SetAllowedCountries sets the "allowed_countries" field.
func (m *BannerMutation) SetAllowedCountries(s []string) {
	m.allowed_countries = &s
	m.appendallowed_countries = nil
}

// AllowedCountries returns the value of the "allowed_countries" field in the mutation.
func (m *BannerMutation) AllowedCountries() (r []string, exists bool) {
	v := m.allowed_countries
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedCountries returns the old "allowed_countries" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedCountries(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedCountries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedCountries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedCountries: %w", err)
	}
	return oldValue.AllowedCountries, nil
}

// AppendAllowedCountries adds s to the "allowed_countries" field.
func (m *BannerMutation) AppendAllowedCountries(s []string) {
	m.appendallowed_countries = append(m.appendallowed_countries, s...)
}

// AppendedAllowedCountries returns the list of values that were appended to the "allowed_countries" field in this mutation.
func (m *BannerMutation) AppendedAllowedCountries() ([]string, bool) {
	if len(m.appendallowed_countries) == 0 {
		return nil, false
	}
	return m.appendallowed_countries, true
}

// ClearAllowedCountries clears the value of the "allowed_countries" field.
func (m *BannerMutation) ClearAllowedCountries() {
	m.allowed_countries = nil
	m.appendallowed_countries = nil
	m.clearedFields[banner.FieldAllowedCountries] = struct{}{}
}

// AllowedCountriesCleared returns if the "allowed_countries" field was cleared in this mutation.
func (m *BannerMutation) AllowedCountriesCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedCountries]
	return ok
}

// ResetAllowedCountries resets all changes to the "allowed_countries" field.
func (m *BannerMutation) ResetAllowedCountries() {
	m.allowed_countries = nil
	m.appendallowed_countries = nil
	delete(m.clearedFields, banner.FieldAllowedCountries)
}

// SetWeight sets the "weight" field.
func (m *BannerMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *BannerMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *BannerMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *BannerMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *BannerMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetSmartWeight sets the "smart_weight" field.
func (m *BannerMutation) SetSmartWeight(f float64) {
	m.smart_weight = &f
	m.addsmart_weight = nil
}

// SmartWeight returns the value of the "smart_weight" field in the mutation.
func (m *BannerMutation) SmartWeight() (r float64, exists bool) {
	v := m.smart_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldSmartWeight returns the old "smart_weight" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldSmartWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSmartWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSmartWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmartWeight: %w", err)
	}
	return oldValue.SmartWeight, nil
}

// AddSmartWeight adds f to the "smart_weight" field.
func (m *BannerMutation) AddSmartWeight(f float64) {
	if m.addsmart_weight != nil {
		*m.addsmart_weight += f
	} else {
		m.addsmart_weight = &f
	}
}

// AddedSmartWeight returns the value that was added to the "smart_weight" field in this mutation.
func (m *BannerMutation) AddedSmartWeight() (r float64, exists bool) {
	v := m.addsmart_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearSmartWeight clears the value of the "smart_weight" field.
func (m *BannerMutation) ClearSmartWeight() {
	m.smart_weight = nil
	m.addsmart_weight = nil
	m.clearedFields[banner.FieldSmartWeight] = struct{}{}
}

// SmartWeightCleared returns if the "smart_weight" field was cleared in this mutation.
func (m *BannerMutation) SmartWeightCleared() bool {
	_, ok := m.clearedFields[banner.FieldSmartWeight]
	return ok
}

// ResetSmartWeight resets all changes to the "smart_weight" field.
func (m *BannerMutation) ResetSmartWeight() {
	m.smart_weight = nil
	m.addsmart_weight = nil
	delete(m.clearedFields, banner.FieldSmartWeight)
}

// SetLastImpression sets the "last_impression" field.
func (m *BannerMutation) SetLastImpression(t time.Time) {
	m.last_impression = &t
}

// LastImpression returns the value of the "last_impression" field in the mutation.
func (m *BannerMutation) LastImpression() (r time.Time, exists bool) {
	v := m.last_impression
	if v == nil {
		return
	}
	return *v, true
}

// OldLastImpression returns the old "last_impression" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldLastImpression(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastImpression is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastImpression requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastImpression: %w", err)
	}
	return oldValue.LastImpression, nil
}

// ClearLastImpression clears the value of the "last_impression" field.
func (m *BannerMutation) ClearLastImpression() {
	m.last_impression = nil
	m.clearedFields[banner.FieldLastImpression] = struct{}{}
}

// LastImpressionCleared returns if the "last_impression" field was cleared in this mutation.
func (m *BannerMutation) LastImpressionCleared() bool {
	_, ok := m.clearedFields[banner.FieldLastImpression]
	return ok
}

// ResetLastImpression resets all changes to the "last_impression" field.
func (m *BannerMutation) ResetLastImpression() {
	m.last_impression = nil
	delete(m.clearedFields, banner.FieldLastImpression)
}

// SetStartDate sets the "start_date" field.
func (m *BannerMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *BannerMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *BannerMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[banner.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *BannerMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[banner.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *BannerMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, banner.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *BannerMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *BannerMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *BannerMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[banner.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *BannerMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[banner.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *BannerMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, banner.FieldEndDate)
}

// SetAllowedDevices sets the "allowed_devices" field.
func (m *BannerMutation) SetAllowedDevices(s []string) {
	m.allowed_devices = &s
	m.appendallowed_devices = nil
}

// AllowedDevices returns the value of the "allowed_devices" field in the mutation.
func (m *BannerMutation) AllowedDevices() (r []string, exists bool) {
	v := m.allowed_devices
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedDevices returns the old "allowed_devices" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedDevices(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedDevices is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedDevices requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedDevices: %w", err)
	}
	return oldValue.AllowedDevices, nil
}

// AppendAllowedDevices adds s to the "allowed_devices" field.
func (m *BannerMutation) AppendAllowedDevices(s []string) {
	m.appendallowed_devices = append(m.appendallowed_devices, s...)
}

// AppendedAllowedDevices returns the list of values that were appended to the "allowed_devices" field in this mutation.
func (m *BannerMutation) AppendedAllowedDevices() ([]string, bool) {
	if len(m.appendallowed_devices) == 0 {
		return nil, false
	}
	return m.appendallowed_devices, true
}

// ClearAllowedDevices clears the value of the "allowed_devices" field.
func (m *BannerMutation) ClearAllowedDevices() {
	m.allowed_devices = nil
	m.appendallowed_devices = nil
	m.clearedFields[banner.FieldAllowedDevices] = struct{}{}
}

// AllowedDevicesCleared returns if the "allowed_devices" field was cleared in this mutation.
func (m *BannerMutation) AllowedDevicesCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedDevices]
	return ok
}

// ResetAllowedDevices resets all changes to the "allowed_devices" field.
func (m *BannerMutation) ResetAllowedDevices() {
	m.allowed_devices = nil
	m.appendallowed_devices = nil
	delete(m.clearedFields, banner.FieldAllowedDevices)
}

// SetAllowedBrowsers sets the "allowed_browsers" field.
func (m *BannerMutation) SetAllowedBrowsers(s []string) {
	m.allowed_browsers = &s
	m.appendallowed_browsers = nil
}

// AllowedBrowsers returns the value of the "allowed_browsers" field in the mutation.
func (m *BannerMutation) AllowedBrowsers() (r []string, exists bool) {
	v := m.allowed_browsers
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedBrowsers returns the old "allowed_browsers" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedBrowsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedBrowsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedBrowsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedBrowsers: %w", err)
	}
	return oldValue.AllowedBrowsers, nil
}

// AppendAllowedBrowsers adds s to the "allowed_browsers" field.
func (m *BannerMutation) AppendAllowedBrowsers(s []string) {
	m.appendallowed_browsers = append(m.appendallowed_browsers, s...)
}

// AppendedAllowedBrowsers returns the list of values that were appended to the "allowed_browsers" field in this mutation.
func (m *BannerMutation) AppendedAllowedBrowsers() ([]string, bool) {
	if len(m.appendallowed_browsers) == 0 {
		return nil, false
	}
	return m.appendallowed_browsers, true
}

// ClearAllowedBrowsers clears the value of the "allowed_browsers" field.
func (m *BannerMutation) ClearAllowedBrowsers() {
	m.allowed_browsers = nil
	m.appendallowed_browsers = nil
	m.clearedFields[banner.FieldAllowedBrowsers] = struct{}{}
}

// AllowedBrowsersCleared returns if the "allowed_browsers" field was cleared in this mutation.
func (m *BannerMutation) AllowedBrowsersCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedBrowsers]
	return ok
}

// ResetAllowedBrowsers resets all changes to the "allowed_browsers" field.
func (m *BannerMutation) ResetAllowedBrowsers() {
	m.allowed_browsers = nil
	m.appendallowed_browsers = nil
	delete(m.clearedFields, banner.FieldAllowedBrowsers)
}

// SetAllowedOs sets the "allowed_os" field.
func (m *BannerMutation) SetAllowedOs(s []string) {
	m.allowed_os = &s
	m.appendallowed_os = nil
}

// AllowedOs returns the value of the "allowed_os" field in the mutation.
func (m *BannerMutation) AllowedOs() (r []string, exists bool) {
	v := m.allowed_os
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedOs returns the old "allowed_os" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedOs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedOs: %w", err)
	}
	return oldValue.AllowedOs, nil
}

// AppendAllowedOs adds s to the "allowed_os" field.
func (m *BannerMutation) AppendAllowedOs(s []string) {
	m.appendallowed_os = append(m.appendallowed_os, s...)
}

// AppendedAllowedOs returns the list of values that were appended to the "allowed_os" field in this mutation.
func (m *BannerMutation) AppendedAllowedOs() ([]string, bool) {
	if len(m.appendallowed_os) == 0 {
		return nil, false
	}
	return m.appendallowed_os, true
}

// ClearAllowedOs clears the value of the "allowed_os" field.
func (m *BannerMutation) ClearAllowedOs() {
	m.allowed_os = nil
	m.appendallowed_os = nil
	m.clearedFields[banner.FieldAllowedOs] = struct{}{}
}

// AllowedOsCleared returns if the "allowed_os" field was cleared in this mutation.
func (m *BannerMutation) AllowedOsCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedOs]
	return ok
}

// ResetAllowedOs resets all changes to the "allowed_os" field.
func (m *BannerMutation) ResetAllowedOs() {
	m.allowed_os = nil
	m.appendallowed_os = nil
	delete(m.clearedFields, banner.FieldAllowedOs)
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCampaignIDs adds the "campaigns" edge to the Campaign entity by ids.
func (m *BannerMutation) AddCampaignIDs(ids ...int64) {
	if m.campaigns == nil {
		m.campaigns = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaigns[ids[i]] = struct{}{}
	}
}

// ClearCampaigns clears the "campaigns" edge to the Campaign entity.
func (m *BannerMutation) ClearCampaigns() {
	m.clearedcampaigns = true
}

// CampaignsCleared reports if the "campaigns" edge to the Campaign entity was cleared.
func (m *BannerMutation) CampaignsCleared() bool {
	return m.clearedcampaigns
}

// RemoveCampaignIDs removes the "campaigns" edge to the Campaign entity by IDs.
func (m *BannerMutation) RemoveCampaignIDs(ids ...int64) {
	if m.removedcampaigns == nil {
		m.removedcampaigns = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaigns, ids[i])
		m.removedcampaigns[ids[i]] = struct{}{}
	}
}

// RemovedCampaigns returns the removed IDs of the "campaigns" edge to the Campaign entity.
func (m *BannerMutation) RemovedCampaignsIDs() (ids []int64) {
	for id := range m.removedcampaigns {
		ids = append(ids, id)
	}
	return
}

// CampaignsIDs returns the "campaigns" edge IDs in the mutation.
func (m *BannerMutation) CampaignsIDs() (ids []int64) {
	for id := range m.campaigns {
		ids = append(ids, id)
	}
	return
}

// ResetCampaigns resets all changes to the "campaigns" edge.
func (m *BannerMutation) ResetCampaigns() {
	m.campaigns = nil
	m.clearedcampaigns = false
	m.removedcampaigns = nil
}

// AddCreativeIDs adds the "creatives" edge to the BannerCreative entity by ids.
func (m *BannerMutation) AddCreativeIDs(ids ...int64) {
	if m.creatives == nil {
		m.creatives = make(map[int64]struct{})
	}
	for i := range ids {
		m.creatives[ids[i]] = struct{}{}
	}
}

// ClearCreatives clears the "creatives" edge to the BannerCreative entity.
func (m *BannerMutation) ClearCreatives() {
	m.clearedcreatives = true
}

// CreativesCleared reports if the "creatives" edge to the BannerCreative entity was cleared.
func (m *BannerMutation) CreativesCleared() bool {
	return m.clearedcreatives
}

// RemoveCreativeIDs removes the "creatives" edge to the BannerCreative entity by IDs.
func (m *BannerMutation) RemoveCreativeIDs(ids ...int64) {
	if m.removedcreatives == nil {
		m.removedcreatives = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.creatives, ids[i])
		m.removedcreatives[ids[i]] = struct{}{}
	}
}

// RemovedCreatives returns the removed IDs of the "creatives" edge to the BannerCreative entity.
func (m *BannerMutation) RemovedCreativesIDs() (ids []int64) {
	for id := range m.removedcreatives {
		ids = append(ids, id)
	}
	return
}

// CreativesIDs returns the "creatives" edge IDs in the mutation.
func (m *BannerMutation) CreativesIDs() (ids []int64) {
	for id := range m.creatives {
		ids = append(ids, id)
	}
	return
}

// ResetCreatives resets all changes to the "creatives" edge.
func (m *BannerMutation) ResetCreatives() {
	m.creatives = nil
	m.clearedcreatives = false
	m.removedcreatives = nil
}

// AddStatIDs adds the "stats" edge to the BannerStats entity by ids.
func (m *BannerMutation) AddStatIDs(ids ...int64) {
	if m.stats == nil {
		m.stats = make(map[int64]struct{})
	}
	for i := range ids {
		m.stats[ids[i]] = struct{}{}
	}
}

// ClearStats clears the "stats" edge to the BannerStats entity.
func (m *BannerMutation) ClearStats() {
	m.clearedstats = true
}

// StatsCleared reports if the "stats" edge to the BannerStats entity was cleared.
func (m *BannerMutation) StatsCleared() bool {
	return m.clearedstats
}

// RemoveStatIDs removes the "stats" edge to the BannerStats entity by IDs.
func (m *BannerMutation) RemoveStatIDs(ids ...int64) {
	if m.removedstats == nil {
		m.removedstats = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.stats, ids[i])
		m.removedstats[ids[i]] = struct{}{}
	}
}

// RemovedStats returns the removed IDs of the "stats" edge to the BannerStats entity.
func (m *BannerMutation) RemovedStatsIDs() (ids []int64) {
	for id := range m.removedstats {
		ids = append(ids, id)
	}
	return
}

// StatsIDs returns the "stats" edge IDs in the mutation.
func (m *BannerMutation) StatsIDs() (ids []int64) {
	for id := range m.stats {
		ids = append(ids, id)
	}
	return
}

// ResetStats resets all changes to the "stats" edge.
func (m *BannerMutation) ResetStats() {
	m.stats = nil
	m.clearedstats = false
	m.removedstats = nil
}

// AddLeadIDs adds the "leads" edge to the Lead entity by ids.
func (m *BannerMutation) AddLeadIDs(ids ...int64) {
	if m.leads == nil {
		m.leads = make(map[int64]struct{})
	}
	for i := range ids {
		m.leads[ids[i]] = struct{}{}
	}
}

// ClearLeads clears the "leads" edge to the Lead entity.
func (m *BannerMutation) ClearLeads() {
	m.clearedleads = true
}

// LeadsCleared reports if the "leads" edge to the Lead entity was cleared.
func (m *BannerMutation) LeadsCleared() bool {
	return m.clearedleads
}

// RemoveLeadIDs removes the "leads" edge to the Lead entity by IDs.
func (m *BannerMutation) RemoveLeadIDs(ids ...int64) {
	if m.removedleads == nil {
		m.removedleads = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.leads, ids[i])
		m.removedleads[ids[i]] = struct{}{}
	}
}

// RemovedLeads returns the removed IDs of the "leads" edge to the Lead entity.
func (m *BannerMutation) RemovedLeadsIDs() (ids []int64) {
	for id := range m.removedleads {
		ids = append(ids, id)
	}
	return
}

// LeadsIDs returns the "leads" edge IDs in the mutation.
func (m *BannerMutation) LeadsIDs() (ids []int64) {
	for id := range m.leads {
		ids = append(ids, id)
	}
	return
}

// ResetLeads resets all changes to the "leads" edge.
func (m *BannerMutation) ResetLeads() {
	m.leads = nil
	m.clearedleads = false
	m.removedleads = nil
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Banner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, banner.FieldName)
	}
	if m.description != nil {
		fields = append(fields, banner.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, banner.FieldType)
	}
	if m.click_url != nil {
		fields = append(fields, banner.FieldClickURL)
	}
	if m.size != nil {
		fields = append(fields, banner.FieldSize)
	}
	if m.status != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.allowed_countries != nil {
		fields = append(fields, banner.FieldAllowedCountries)
	}
	if m.weight != nil {
		fields = append(fields, banner.FieldWeight)
	}
	if m.smart_weight != nil {
		fields = append(fields, banner.FieldSmartWeight)
	}
	if m.last_impression != nil {
		fields = append(fields, banner.FieldLastImpression)
	}
	if m.start_date != nil {
		fields = append(fields, banner.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, banner.FieldEndDate)
	}
	if m.allowed_devices != nil {
		fields = append(fields, banner.FieldAllowedDevices)
	}
	if m.allowed_browsers != nil {
		fields = append(fields, banner.FieldAllowedBrowsers)
	}
	if m.allowed_os != nil {
		fields = append(fields, banner.FieldAllowedOs)
	}
	if m.created_at != nil {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldName:
		return m.Name()
	case banner.FieldDescription:
		return m.Description()
	case banner.FieldType:
		return m.GetType()
	case banner.FieldClickURL:
		return m.ClickURL()
	case banner.FieldSize:
		return m.Size()
	case banner.FieldStatus:
		return m.Status()
	case banner.FieldAllowedCountries:
		return m.AllowedCountries()
	case banner.FieldWeight:
		return m.Weight()
	case banner.FieldSmartWeight:
		return m.SmartWeight()
	case banner.FieldLastImpression:
		return m.LastImpression()
	case banner.FieldStartDate:
		return m.StartDate()
	case banner.FieldEndDate:
		return m.EndDate()
	case banner.FieldAllowedDevices:
		return m.AllowedDevices()
	case banner.FieldAllowedBrowsers:
		return m.AllowedBrowsers()
	case banner.FieldAllowedOs:
		return m.AllowedOs()
	case banner.FieldCreatedAt:
		return m.CreatedAt()
	case banner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldName:
		return m.OldName(ctx)
	case banner.FieldDescription:
		return m.OldDescription(ctx)
	case banner.FieldType:
		return m.OldType(ctx)
	case banner.FieldClickURL:
		return m.OldClickURL(ctx)
	case banner.FieldSize:
		return m.OldSize(ctx)
	case banner.FieldStatus:
		return m.OldStatus(ctx)
	case banner.FieldAllowedCountries:
		return m.OldAllowedCountries(ctx)
	case banner.FieldWeight:
		return m.OldWeight(ctx)
	case banner.FieldSmartWeight:
		return m.OldSmartWeight(ctx)
	case banner.FieldLastImpression:
		return m.OldLastImpression(ctx)
	case banner.FieldStartDate:
		return m.OldStartDate(ctx)
	case banner.FieldEndDate:
		return m.OldEndDate(ctx)
	case banner.FieldAllowedDevices:
		return m.OldAllowedDevices(ctx)
	case banner.FieldAllowedBrowsers:
		return m.OldAllowedBrowsers(ctx)
	case banner.FieldAllowedOs:
		return m.OldAllowedOs(ctx)
	case banner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case banner.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case banner.FieldType:
		v, ok := value.(banner.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case banner.FieldClickURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickURL(v)
		return nil
	case banner.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case banner.FieldStatus:
		v, ok := value.(banner.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case banner.FieldAllowedCountries:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedCountries(v)
		return nil
	case banner.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case banner.FieldSmartWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmartWeight(v)
		return nil
	case banner.FieldLastImpression:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastImpression(v)
		return nil
	case banner.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case banner.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case banner.FieldAllowedDevices:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedDevices(v)
		return nil
	case banner.FieldAllowedBrowsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedBrowsers(v)
		return nil
	case banner.FieldAllowedOs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedOs(v)
		return nil
	case banner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, banner.FieldWeight)
	}
	if m.addsmart_weight != nil {
		fields = append(fields, banner.FieldSmartWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldWeight:
		return m.AddedWeight()
	case banner.FieldSmartWeight:
		return m.AddedSmartWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banner.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case banner.FieldSmartWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSmartWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banner.FieldDescription) {
		fields = append(fields, banner.FieldDescription)
	}
	if m.FieldCleared(banner.FieldClickURL) {
		fields = append(fields, banner.FieldClickURL)
	}
	if m.FieldCleared(banner.FieldAllowedCountries) {
		fields = append(fields, banner.FieldAllowedCountries)
	}
	if m.FieldCleared(banner.FieldSmartWeight) {
		fields = append(fields, banner.FieldSmartWeight)
	}
	if m.FieldCleared(banner.FieldLastImpression) {
		fields = append(fields, banner.FieldLastImpression)
	}
	if m.FieldCleared(banner.FieldStartDate) {
		fields = append(fields, banner.FieldStartDate)
	}
	if m.FieldCleared(banner.FieldEndDate) {
		fields = append(fields, banner.FieldEndDate)
	}
	if m.FieldCleared(banner.FieldAllowedDevices) {
		fields = append(fields, banner.FieldAllowedDevices)
	}
	if m.FieldCleared(banner.FieldAllowedBrowsers) {
		fields = append(fields, banner.FieldAllowedBrowsers)
	}
	if m.FieldCleared(banner.FieldAllowedOs) {
		fields = append(fields, banner.FieldAllowedOs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	switch name {
	case banner.FieldDescription:
		m.ClearDescription()
		return nil
	case banner.FieldClickURL:
		m.ClearClickURL()
		return nil
	case banner.FieldAllowedCountries:
		m.ClearAllowedCountries()
		return nil
	case banner.FieldSmartWeight:
		m.ClearSmartWeight()
		return nil
	case banner.FieldLastImpression:
		m.ClearLastImpression()
		return nil
	case banner.FieldStartDate:
		m.ClearStartDate()
		return nil
	case banner.FieldEndDate:
		m.ClearEndDate()
		return nil
	case banner.FieldAllowedDevices:
		m.ClearAllowedDevices()
		return nil
	case banner.FieldAllowedBrowsers:
		m.ClearAllowedBrowsers()
		return nil
	case banner.FieldAllowedOs:
		m.ClearAllowedOs()
		return nil
	}
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldName:
		m.ResetName()
		return nil
	case banner.FieldDescription:
		m.ResetDescription()
		return nil
	case banner.FieldType:
		m.ResetType()
		return nil
	case banner.FieldClickURL:
		m.ResetClickURL()
		return nil
	case banner.FieldSize:
		m.ResetSize()
		return nil
	case banner.FieldStatus:
		m.ResetStatus()
		return nil
	case banner.FieldAllowedCountries:
		m.ResetAllowedCountries()
		return nil
	case banner.FieldWeight:
		m.ResetWeight()
		return nil
	case banner.FieldSmartWeight:
		m.ResetSmartWeight()
		return nil
	case banner.FieldLastImpression:
		m.ResetLastImpression()
		return nil
	case banner.FieldStartDate:
		m.ResetStartDate()
		return nil
	case banner.FieldEndDate:
		m.ResetEndDate()
		return nil
	case banner.FieldAllowedDevices:
		m.ResetAllowedDevices()
		return nil
	case banner.FieldAllowedBrowsers:
		m.ResetAllowedBrowsers()
		return nil
	case banner.FieldAllowedOs:
		m.ResetAllowedOs()
		return nil
	case banner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.campaigns != nil {
		edges = append(edges, banner.EdgeCampaigns)
	}
	if m.creatives != nil {
		edges = append(edges, banner.EdgeCreatives)
	}
	if m.stats != nil {
		edges = append(edges, banner.EdgeStats)
	}
	if m.leads != nil {
		edges = append(edges, banner.EdgeLeads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.campaigns))
		for id := range m.campaigns {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeCreatives:
		ids := make([]ent.Value, 0, len(m.creatives))
		for id := range m.creatives {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeStats:
		ids := make([]ent.Value, 0, len(m.stats))
		for id := range m.stats {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeLeads:
		ids := make([]ent.Value, 0, len(m.leads))
		for id := range m.leads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcampaigns != nil {
		edges = append(edges, banner.EdgeCampaigns)
	}
	if m.removedcreatives != nil {
		edges = append(edges, banner.EdgeCreatives)
	}
	if m.removedstats != nil {
		edges = append(edges, banner.EdgeStats)
	}
	if m.removedleads != nil {
		edges = append(edges, banner.EdgeLeads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.removedcampaigns))
		for id := range m.removedcampaigns {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeCreatives:
		ids := make([]ent.Value, 0, len(m.removedcreatives))
		for id := range m.removedcreatives {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeStats:
		ids := make([]ent.Value, 0, len(m.removedstats))
		for id := range m.removedstats {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeLeads:
		ids := make([]ent.Value, 0, len(m.removedleads))
		for id := range m.removedleads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcampaigns {
		edges = append(edges, banner.EdgeCampaigns)
	}
	if m.clearedcreatives {
		edges = append(edges, banner.EdgeCreatives)
	}
	if m.clearedstats {
		edges = append(edges, banner.EdgeStats)
	}
	if m.clearedleads {
		edges = append(edges, banner.EdgeLeads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	switch name {
	case banner.EdgeCampaigns:
		return m.clearedcampaigns
	case banner.EdgeCreatives:
		return m.clearedcreatives
	case banner.EdgeStats:
		return m.clearedstats
	case banner.EdgeLeads:
		return m.clearedleads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	switch name {
	case banner.EdgeCampaigns:
		m.ResetCampaigns()
		return nil
	case banner.EdgeCreatives:
		m.ResetCreatives()
		return nil
	case banner.EdgeStats:
		m.ResetStats()
		return nil
	case banner.EdgeLeads:
		m.ResetLeads()
		return nil
	}
	return fmt.Errorf("unknown Banner edge %s", name)
}

// BannerCreativeMutation represents an operation that mutates the BannerCreative nodes in the graph.
type BannerCreativeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	image_url     *string
	size          *string
	enabled       *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	banner        *int64
	clearedbanner bool
	done          bool
	oldValue      func(context.Context) (*BannerCreative, error)
	predicates    []predicate.BannerCreative
}

var _ ent.Mutation = (*BannerCreativeMutation)(nil)

// bannercreativeOption allows management of the mutation configuration using functional options.
type bannercreativeOption func(*BannerCreativeMutation)

// newBannerCreativeMutation creates new mutation for the BannerCreative entity.
func newBannerCreativeMutation(c config, op Op, opts ...bannercreativeOption) *BannerCreativeMutation {
	m := &BannerCreativeMutation{
		config:        c,
		op:            op,
		typ:           TypeBannerCreative,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerCreativeID sets the ID field of the mutation.
func withBannerCreativeID(id int64) bannercreativeOption {
	return func(m *BannerCreativeMutation) {
		var (
			err   error
			once  sync.Once
			value *BannerCreative
		)
		m.oldValue = func(ctx context.Context) (*BannerCreative, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BannerCreative.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBannerCreative sets the old BannerCreative of the mutation.
func withBannerCreative(node *BannerCreative) bannercreativeOption {
	return func(m *BannerCreativeMutation) {
		m.oldValue = func(context.Context) (*BannerCreative, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerCreativeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerCreativeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BannerCreative entities.
func (m *BannerCreativeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerCreativeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerCreativeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BannerCreative.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BannerCreativeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerCreativeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *BannerCreativeMutation) ClearName() {
	m.name = nil
	m.clearedFields[bannercreative.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *BannerCreativeMutation) NameCleared() bool {
	_, ok := m.clearedFields[bannercreative.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *BannerCreativeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, bannercreative.FieldName)
}

// SetImageURL sets the "image_url" field.
func (m *BannerCreativeMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *BannerCreativeMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *BannerCreativeMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[bannercreative.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *BannerCreativeMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[bannercreative.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *BannerCreativeMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, bannercreative.FieldImageURL)
}

// SetSize sets the "size" field.
func (m *BannerCreativeMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *BannerCreativeMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ClearSize clears the value of the "size" field.
func (m *BannerCreativeMutation) ClearSize() {
	m.size = nil
	m.clearedFields[bannercreative.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *BannerCreativeMutation) SizeCleared() bool {
	_, ok := m.clearedFields[bannercreative.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *BannerCreativeMutation) ResetSize() {
	m.size = nil
	delete(m.clearedFields, bannercreative.FieldSize)
}

// SetEnabled sets the "enabled" field.
func (m *BannerCreativeMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *BannerCreativeMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *BannerCreativeMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerCreativeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerCreativeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerCreativeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerCreativeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerCreativeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerCreativeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBannerID sets the "banner" edge to the Banner entity by id.
func (m *BannerCreativeMutation) SetBannerID(id int64) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *BannerCreativeMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *BannerCreativeMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *BannerCreativeMutation) BannerID() (id int64, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *BannerCreativeMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *BannerCreativeMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the BannerCreativeMutation builder.
func (m *BannerCreativeMutation) Where(ps ...predicate.BannerCreative) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerCreativeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerCreativeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BannerCreative, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerCreativeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerCreativeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BannerCreative).
func (m *BannerCreativeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerCreativeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, bannercreative.FieldName)
	}
	if m.image_url != nil {
		fields = append(fields, bannercreative.FieldImageURL)
	}
	if m.size != nil {
		fields = append(fields, bannercreative.FieldSize)
	}
	if m.enabled != nil {
		fields = append(fields, bannercreative.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, bannercreative.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bannercreative.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerCreativeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bannercreative.FieldName:
		return m.Name()
	case bannercreative.FieldImageURL:
		return m.ImageURL()
	case bannercreative.FieldSize:
		return m.Size()
	case bannercreative.FieldEnabled:
		return m.Enabled()
	case bannercreative.FieldCreatedAt:
		return m.CreatedAt()
	case bannercreative.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerCreativeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bannercreative.FieldName:
		return m.OldName(ctx)
	case bannercreative.FieldImageURL:
		return m.OldImageURL(ctx)
	case bannercreative.FieldSize:
		return m.OldSize(ctx)
	case bannercreative.FieldEnabled:
		return m.OldEnabled(ctx)
	case bannercreative.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bannercreative.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BannerCreative field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerCreativeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bannercreative.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bannercreative.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case bannercreative.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case bannercreative.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case bannercreative.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bannercreative.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BannerCreative field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerCreativeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerCreativeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerCreativeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BannerCreative numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerCreativeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bannercreative.FieldName) {
		fields = append(fields, bannercreative.FieldName)
	}
	if m.FieldCleared(bannercreative.FieldImageURL) {
		fields = append(fields, bannercreative.FieldImageURL)
	}
	if m.FieldCleared(bannercreative.FieldSize) {
		fields = append(fields, bannercreative.FieldSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerCreativeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerCreativeMutation) ClearField(name string) error {
	switch name {
	case bannercreative.FieldName:
		m.ClearName()
		return nil
	case bannercreative.FieldImageURL:
		m.ClearImageURL()
		return nil
	case bannercreative.FieldSize:
		m.ClearSize()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerCreativeMutation) ResetField(name string) error {
	switch name {
	case bannercreative.FieldName:
		m.ResetName()
		return nil
	case bannercreative.FieldImageURL:
		m.ResetImageURL()
		return nil
	case bannercreative.FieldSize:
		m.ResetSize()
		return nil
	case bannercreative.FieldEnabled:
		m.ResetEnabled()
		return nil
	case bannercreative.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bannercreative.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerCreativeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner != nil {
		edges = append(edges, bannercreative.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerCreativeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bannercreative.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerCreativeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerCreativeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerCreativeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner {
		edges = append(edges, bannercreative.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerCreativeMutation) EdgeCleared(name string) bool {
	switch name {
	case bannercreative.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerCreativeMutation) ClearEdge(name string) error {
	switch name {
	case bannercreative.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerCreativeMutation) ResetEdge(name string) error {
	switch name {
	case bannercreative.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative edge %s", name)
}

// BannerStatsMutation represents an operation that mutates the BannerStats nodes in the graph.
type BannerStatsMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	date               *time.Time
	impressions        *int64
	addimpressions     *int64
	clicks             *int64
	addclicks          *int64
	leads              *int64
	addleads           *int64
	ctr                *float64
	addctr             *float64
	conversion_rate    *float64
	addconversion_rate *float64
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	banner             *int64
	clearedbanner      bool
	done               bool
	oldValue           func(context.Context) (*BannerStats, error)
	predicates         []predicate.BannerStats
}

var _ ent.Mutation = (*BannerStatsMutation)(nil)

// bannerstatsOption allows management of the mutation configuration using functional options.
type bannerstatsOption func(*BannerStatsMutation)

// newBannerStatsMutation creates new mutation for the BannerStats entity.
func newBannerStatsMutation(c config, op Op, opts ...bannerstatsOption) *BannerStatsMutation {
	m := &BannerStatsMutation{
		config:        c,
		op:            op,
		typ:           TypeBannerStats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerStatsID sets the ID field of the mutation.
func withBannerStatsID(id int64) bannerstatsOption {
	return func(m *BannerStatsMutation) {
		var (
			err   error
			once  sync.Once
			value *BannerStats
		)
		m.oldValue = func(ctx context.Context) (*BannerStats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BannerStats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBannerStats sets the old BannerStats of the mutation.
func withBannerStats(node *BannerStats) bannerstatsOption {
	return func(m *BannerStatsMutation) {
		m.oldValue = func(context.Context) (*BannerStats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerStatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerStatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BannerStats entities.
func (m *BannerStatsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerStatsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerStatsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BannerStats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *BannerStatsMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *BannerStatsMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *BannerStatsMutation) ResetDate() {
	m.date = nil
}

// SetImpressions sets the "impressions" field.
func (m *BannerStatsMutation) SetImpressions(i int64) {
	m.impressions = &i
	m.addimpressions = nil
}

// Impressions returns the value of the "impressions" field in the mutation.
func (m *BannerStatsMutation) Impressions() (r int64, exists bool) {
	v := m.impressions
	if v == nil {
		return
	}
	return *v, true
}

// OldImpressions returns the old "impressions" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldImpressions(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpressions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpressions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpressions: %w", err)
	}
	return oldValue.Impressions, nil
}

// AddImpressions adds i to the "impressions" field.
func (m *BannerStatsMutation) AddImpressions(i int64) {
	if m.addimpressions != nil {
		*m.addimpressions += i
	} else {
		m.addimpressions = &i
	}
}

// AddedImpressions returns the value that was added to the "impressions" field in this mutation.
func (m *BannerStatsMutation) AddedImpressions() (r int64, exists bool) {
	v := m.addimpressions
	if v == nil {
		return
	}
	return *v, true
}

// ResetImpressions resets all changes to the "impressions" field.
func (m *BannerStatsMutation) ResetImpressions() {
	m.impressions = nil
	m.addimpressions = nil
}

// SetClicks sets the "clicks" field.
func (m *BannerStatsMutation) SetClicks(i int64) {
	m.clicks = &i
	m.addclicks = nil
}

// Clicks returns the value of the "clicks" field in the mutation.
func (m *BannerStatsMutation) Clicks() (r int64, exists bool) {
	v := m.clicks
	if v == nil {
		return
	}
	return *v, true
}

// OldClicks returns the old "clicks" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldClicks(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClicks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClicks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClicks: %w", err)
	}
	return oldValue.Clicks, nil
}

// AddClicks adds i to the "clicks" field.
func (m *BannerStatsMutation) AddClicks(i int64) {
	if m.addclicks != nil {
		*m.addclicks += i
	} else {
		m.addclicks = &i
	}
}

// AddedClicks returns the value that was added to the "clicks" field in this mutation.
func (m *BannerStatsMutation) AddedClicks() (r int64, exists bool) {
	v := m.addclicks
	if v == nil {
		return
	}
	return *v, true
}

// ResetClicks resets all changes to the "clicks" field.
func (m *BannerStatsMutation) ResetClicks() {
	m.clicks = nil
	m.addclicks = nil
}

// SetLeads sets the "leads" field.
func (m *BannerStatsMutation) SetLeads(i int64) {
	m.leads = &i
	m.addleads = nil
}

// Leads returns the value of the "leads" field in the mutation.
func (m *BannerStatsMutation) Leads() (r int64, exists bool) {
	v := m.leads
	if v == nil {
		return
	}
	return *v, true
}

// OldLeads returns the old "leads" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldLeads(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeads: %w", err)
	}
	return oldValue.Leads, nil
}

// AddLeads adds i to the "leads" field.
func (m *BannerStatsMutation) AddLeads(i int64) {
	if m.addleads != nil {
		*m.addleads += i
	} else {
		m.addleads = &i
	}
}

// AddedLeads returns the value that was added to the "leads" field in this mutation.
func (m *BannerStatsMutation) AddedLeads() (r int64, exists bool) {
	v := m.addleads
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeads resets all changes to the "leads" field.
func (m *BannerStatsMutation) ResetLeads() {
	m.leads = nil
	m.addleads = nil
}

// SetCtr sets the "ctr" field.
func (m *BannerStatsMutation) SetCtr(f float64) {
	m.ctr = &f
	m.addctr = nil
}

// Ctr returns the value of the "ctr" field in the mutation.
func (m *BannerStatsMutation) Ctr() (r float64, exists bool) {
	v := m.ctr
	if v == nil {
		return
	}
	return *v, true
}

// OldCtr returns the old "ctr" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldCtr(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtr: %w", err)
	}
	return oldValue.Ctr, nil
}

// AddCtr adds f to the "ctr" field.
func (m *BannerStatsMutation) AddCtr(f float64) {
	if m.addctr != nil {
		*m.addctr += f
	} else {
		m.addctr = &f
	}
}

// AddedCtr returns the value that was added to the "ctr" field in this mutation.
func (m *BannerStatsMutation) AddedCtr() (r float64, exists bool) {
	v := m.addctr
	if v == nil {
		return
	}
	return *v, true
}

// ClearCtr clears the value of the "ctr" field.
func (m *BannerStatsMutation) ClearCtr() {
	m.ctr = nil
	m.addctr = nil
	m.clearedFields[bannerstats.FieldCtr] = struct{}{}
}

// CtrCleared returns if the "ctr" field was cleared in this mutation.
func (m *BannerStatsMutation) CtrCleared() bool {
	_, ok := m.clearedFields[bannerstats.FieldCtr]
	return ok
}

// ResetCtr resets all changes to the "ctr" field.
func (m *BannerStatsMutation) ResetCtr() {
	m.ctr = nil
	m.addctr = nil
	delete(m.clearedFields, bannerstats.FieldCtr)
}

// SetConversionRate sets the "conversion_rate" field.
func (m *BannerStatsMutation) SetConversionRate(f float64) {
	m.conversion_rate = &f
	m.addconversion_rate = nil
}

// ConversionRate returns the value of the "conversion_rate" field in the mutation.
func (m *BannerStatsMutation) ConversionRate() (r float64, exists bool) {
	v := m.conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldConversionRate returns the old "conversion_rate" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldConversionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversionRate: %w", err)
	}
	return oldValue.ConversionRate, nil
}

// AddConversionRate adds f to the "conversion_rate" field.
func (m *BannerStatsMutation) AddConversionRate(f float64) {
	if m.addconversion_rate != nil {
		*m.addconversion_rate += f
	} else {
		m.addconversion_rate = &f
	}
}

// AddedConversionRate returns the value that was added to the "conversion_rate" field in this mutation.
func (m *BannerStatsMutation) AddedConversionRate() (r float64, exists bool) {
	v := m.addconversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearConversionRate clears the value of the "conversion_rate" field.
func (m *BannerStatsMutation) ClearConversionRate() {
	m.conversion_rate = nil
	m.addconversion_rate = nil
	m.clearedFields[bannerstats.FieldConversionRate] = struct{}{}
}

// ConversionRateCleared returns if the "conversion_rate" field was cleared in this mutation.
func (m *BannerStatsMutation) ConversionRateCleared() bool {
	_, ok := m.clearedFields[bannerstats.FieldConversionRate]
	return ok
}

// ResetConversionRate resets all changes to the "conversion_rate" field.
func (m *BannerStatsMutation) ResetConversionRate() {
	m.conversion_rate = nil
	m.addconversion_rate = nil
	delete(m.clearedFields, bannerstats.FieldConversionRate)
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerStatsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerStatsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerStatsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerStatsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerStatsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerStatsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBannerID sets the "banner" edge to the Banner entity by id.
func (m *BannerStatsMutation) SetBannerID(id int64) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *BannerStatsMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *BannerStatsMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *BannerStatsMutation) BannerID() (id int64, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *BannerStatsMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *BannerStatsMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the BannerStatsMutation builder.
func (m *BannerStatsMutation) Where(ps ...predicate.BannerStats) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerStatsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerStatsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BannerStats, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerStatsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerStatsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BannerStats).
func (m *BannerStatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerStatsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.date != nil {
		fields = append(fields, bannerstats.FieldDate)
	}
	if m.impressions != nil {
		fields = append(fields, bannerstats.FieldImpressions)
	}
	if m.clicks != nil {
		fields = append(fields, bannerstats.FieldClicks)
	}
	if m.leads != nil {
		fields = append(fields, bannerstats.FieldLeads)
	}
	if m.ctr != nil {
		fields = append(fields, bannerstats.FieldCtr)
	}
	if m.conversion_rate != nil {
		fields = append(fields, bannerstats.FieldConversionRate)
	}
	if m.created_at != nil {
		fields = append(fields, bannerstats.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bannerstats.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerStatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bannerstats.FieldDate:
		return m.Date()
	case bannerstats.FieldImpressions:
		return m.Impressions()
	case bannerstats.FieldClicks:
		return m.Clicks()
	case bannerstats.FieldLeads:
		return m.Leads()
	case bannerstats.FieldCtr:
		return m.Ctr()
	case bannerstats.FieldConversionRate:
		return m.ConversionRate()
	case bannerstats.FieldCreatedAt:
		return m.CreatedAt()
	case bannerstats.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerStatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bannerstats.FieldDate:
		return m.OldDate(ctx)
	case bannerstats.FieldImpressions:
		return m.OldImpressions(ctx)
	case bannerstats.FieldClicks:
		return m.OldClicks(ctx)
	case bannerstats.FieldLeads:
		return m.OldLeads(ctx)
	case bannerstats.FieldCtr:
		return m.OldCtr(ctx)
	case bannerstats.FieldConversionRate:
		return m.OldConversionRate(ctx)
	case bannerstats.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bannerstats.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BannerStats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerStatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bannerstats.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case bannerstats.FieldImpressions:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpressions(v)
		return nil
	case bannerstats.FieldClicks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClicks(v)
		return nil
	case bannerstats.FieldLeads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeads(v)
		return nil
	case bannerstats.FieldCtr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtr(v)
		return nil
	case bannerstats.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversionRate(v)
		return nil
	case bannerstats.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bannerstats.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BannerStats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerStatsMutation) AddedFields() []string {
	var fields []string
	if m.addimpressions != nil {
		fields = append(fields, bannerstats.FieldImpressions)
	}
	if m.addclicks != nil {
		fields = append(fields, bannerstats.FieldClicks)
	}
	if m.addleads != nil {
		fields = append(fields, bannerstats.FieldLeads)
	}
	if m.addctr != nil {
		fields = append(fields, bannerstats.FieldCtr)
	}
	if m.addconversion_rate != nil {
		fields = append(fields, bannerstats.FieldConversionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerStatsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bannerstats.FieldImpressions:
		return m.AddedImpressions()
	case bannerstats.FieldClicks:
		return m.AddedClicks()
	case bannerstats.FieldLeads:
		return m.AddedLeads()
	case bannerstats.FieldCtr:
		return m.AddedCtr()
	case bannerstats.FieldConversionRate:
		return m.AddedConversionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerStatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bannerstats.FieldImpressions:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImpressions(v)
		return nil
	case bannerstats.FieldClicks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClicks(v)
		return nil
	case bannerstats.FieldLeads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeads(v)
		return nil
	case bannerstats.FieldCtr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCtr(v)
		return nil
	case bannerstats.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown BannerStats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerStatsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bannerstats.FieldCtr) {
		fields = append(fields, bannerstats.FieldCtr)
	}
	if m.FieldCleared(bannerstats.FieldConversionRate) {
		fields = append(fields, bannerstats.FieldConversionRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerStatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerStatsMutation) ClearField(name string) error {
	switch name {
	case bannerstats.FieldCtr:
		m.ClearCtr()
		return nil
	case bannerstats.FieldConversionRate:
		m.ClearConversionRate()
		return nil
	}
	return fmt.Errorf("unknown BannerStats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerStatsMutation) ResetField(name string) error {
	switch name {
	case bannerstats.FieldDate:
		m.ResetDate()
		return nil
	case bannerstats.FieldImpressions:
		m.ResetImpressions()
		return nil
	case bannerstats.FieldClicks:
		m.ResetClicks()
		return nil
	case bannerstats.FieldLeads:
		m.ResetLeads()
		return nil
	case bannerstats.FieldCtr:
		m.ResetCtr()
		return nil
	case bannerstats.FieldConversionRate:
		m.ResetConversionRate()
		return nil
	case bannerstats.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bannerstats.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BannerStats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerStatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner != nil {
		edges = append(edges, bannerstats.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerStatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bannerstats.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerStatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerStatsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerStatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner {
		edges = append(edges, bannerstats.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerStatsMutation) EdgeCleared(name string) bool {
	switch name {
	case bannerstats.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerStatsMutation) ClearEdge(name string) error {
	switch name {
	case bannerstats.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerStats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerStatsMutation) ResetEdge(name string) error {
	switch name {
	case bannerstats.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerStats edge %s", name)
}

// CampaignMutation represents an operation that mutates the Campaign nodes in the graph.
type CampaignMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	description             *string
	unique_code             *string
	_type                   *campaign.Type
	commission_type         *campaign.CommissionType
	base_commission_rate    *float64
	addbase_commission_rate *float64
	commission_tiers        *[]schema.CommissionTier
	appendcommission_tiers  []schema.CommissionTier
	target_geography        *string
	target_demographics     *map[string]interface{}
	start_date              *time.Time
	end_date                *time.Time
	status                  *campaign.Status
	tracking_url            *string
	total_clicks            *int
	addtotal_clicks         *int
	total_conversions       *int
	addtotal_conversions    *int
	total_revenue           *float64
	addtotal_revenue        *float64
	conversion_rate         *float64
	addconversion_rate      *float64
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	owner                   *int64
	clearedowner            bool
	links                   map[int64]struct{}
	removedlinks            map[int64]struct{}
	clearedlinks            bool
	tracks                  map[int64]struct{}
	removedtracks           map[int64]struct{}
	clearedtracks           bool
	referrals               map[int64]struct{}
	removedreferrals        map[int64]struct{}
	clearedreferrals        bool
	banners                 map[int64]struct{}
	removedbanners          map[int64]struct{}
	clearedbanners          bool
	done                    bool
	oldValue                func(context.Context) (*Campaign, error)
	predicates              []predicate.Campaign
}

var _ ent.Mutation = (*CampaignMutation)(nil)

// campaignOption allows management of the mutation configuration using functional options.
type campaignOption func(*CampaignMutation)

// newCampaignMutation creates new mutation for the Campaign entity.
func newCampaignMutation(c config, op Op, opts ...campaignOption) *CampaignMutation {
	m := &CampaignMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignID sets the ID field of the mutation.
func withCampaignID(id int64) campaignOption {
	return func(m *CampaignMutation) {
		var (
			err   error
			once  sync.Once
			value *Campaign
		)
		m.oldValue = func(ctx context.Context) (*Campaign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Campaign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaign sets the old Campaign of the mutation.
func withCampaign(node *Campaign) campaignOption {
	return func(m *CampaignMutation) {
		m.oldValue = func(context.Context) (*Campaign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Campaign entities.
func (m *CampaignMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Campaign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CampaignMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CampaignMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CampaignMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CampaignMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CampaignMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CampaignMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[campaign.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CampaignMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[campaign.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CampaignMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, campaign.FieldDescription)
}

// SetUniqueCode sets the "unique_code" field.
func (m *CampaignMutation) SetUniqueCode(s string) {
	m.unique_code = &s
}

// UniqueCode returns the value of the "unique_code" field in the mutation.
func (m *CampaignMutation) UniqueCode() (r string, exists bool) {
	v := m.unique_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueCode returns the old "unique_code" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUniqueCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueCode: %w", err)
	}
	return oldValue.UniqueCode, nil
}

// ResetUniqueCode resets all changes to the "unique_code" field.
func (m *CampaignMutation) ResetUniqueCode() {
	m.unique_code = nil
}

// SetType sets the "type" field.
func (m *CampaignMutation) SetType(c campaign.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CampaignMutation) GetType() (r campaign.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldType(ctx context.Context) (v campaign.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CampaignMutation) ResetType() {
	m._type = nil
}

// SetCommissionType sets the "commission_type" field.
func (m *CampaignMutation) SetCommissionType(ct campaign.CommissionType) {
	m.commission_type = &ct
}

// CommissionType returns the value of the "commission_type" field in the mutation.
func (m *CampaignMutation) CommissionType() (r campaign.CommissionType, exists bool) {
	v := m.commission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionType returns the old "commission_type" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCommissionType(ctx context.Context) (v campaign.CommissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionType: %w", err)
	}
	return oldValue.CommissionType, nil
}

// ResetCommissionType resets all changes to the "commission_type" field.
func (m *CampaignMutation) ResetCommissionType() {
	m.commission_type = nil
}

// SetBaseCommissionRate sets the "base_commission_rate" field.
func (m *CampaignMutation) SetBaseCommissionRate(f float64) {
	m.base_commission_rate = &f
	m.addbase_commission_rate = nil
}

// BaseCommissionRate returns the value of the "base_commission_rate" field in the mutation.
func (m *CampaignMutation) BaseCommissionRate() (r float64, exists bool) {
	v := m.base_commission_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCommissionRate returns the old "base_commission_rate" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldBaseCommissionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCommissionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCommissionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCommissionRate: %w", err)
	}
	return oldValue.BaseCommissionRate, nil
}

// AddBaseCommissionRate adds f to the "base_commission_rate" field.
func (m *CampaignMutation) AddBaseCommissionRate(f float64) {
	if m.addbase_commission_rate != nil {
		*m.addbase_commission_rate += f
	} else {
		m.addbase_commission_rate = &f
	}
}

// AddedBaseCommissionRate returns the value that was added to the "base_commission_rate" field in this mutation.
func (m *CampaignMutation) AddedBaseCommissionRate() (r float64, exists bool) {
	v := m.addbase_commission_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseCommissionRate resets all changes to the "base_commission_rate" field.
func (m *CampaignMutation) ResetBaseCommissionRate() {
	m.base_commission_rate = nil
	m.addbase_commission_rate = nil
}

// SetCommissionTiers sets the "commission_tiers" field.
func (m *CampaignMutation) SetCommissionTiers(st []schema.CommissionTier) {
	m.commission_tiers = &st
	m.appendcommission_tiers = nil
}

// CommissionTiers returns the value of the "commission_tiers" field in the mutation.
func (m *CampaignMutation) CommissionTiers() (r []schema.CommissionTier, exists bool) {
	v := m.commission_tiers
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionTiers returns the old "commission_tiers" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCommissionTiers(ctx context.Context) (v []schema.CommissionTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionTiers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionTiers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionTiers: %w", err)
	}
	return oldValue.CommissionTiers, nil
}

// AppendCommissionTiers adds st to the "commission_tiers" field.
func (m *CampaignMutation) AppendCommissionTiers(st []schema.CommissionTier) {
	m.appendcommission_tiers = append(m.appendcommission_tiers, st...)
}

// AppendedCommissionTiers returns the list of values that were appended to the "commission_tiers" field in this mutation.
func (m *CampaignMutation) AppendedCommissionTiers() ([]schema.CommissionTier, bool) {
	if len(m.appendcommission_tiers) == 0 {
		return nil, false
	}
	return m.appendcommission_tiers, true
}

// ClearCommissionTiers clears the value of the "commission_tiers" field.
func (m *CampaignMutation) ClearCommissionTiers() {
	m.commission_tiers = nil
	m.appendcommission_tiers = nil
	m.clearedFields[campaign.FieldCommissionTiers] = struct{}{}
}

// CommissionTiersCleared returns if the "commission_tiers" field was cleared in this mutation.
func (m *CampaignMutation) CommissionTiersCleared() bool {
	_, ok := m.clearedFields[campaign.FieldCommissionTiers]
	return ok
}

// ResetCommissionTiers resets all changes to the "commission_tiers" field.
func (m *CampaignMutation) ResetCommissionTiers() {
	m.commission_tiers = nil
	m.appendcommission_tiers = nil
	delete(m.clearedFields, campaign.FieldCommissionTiers)
}

// SetTargetGeography sets the "target_geography" field.
func (m *CampaignMutation) SetTargetGeography(s string) {
	m.target_geography = &s
}

// TargetGeography returns the value of the "target_geography" field in the mutation.
func (m *CampaignMutation) TargetGeography() (r string, exists bool) {
	v := m.target_geography
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetGeography returns the old "target_geography" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTargetGeography(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetGeography is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetGeography requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetGeography: %w", err)
	}
	return oldValue.TargetGeography, nil
}

// ClearTargetGeography clears the value of the "target_geography" field.
func (m *CampaignMutation) ClearTargetGeography() {
	m.target_geography = nil
	m.clearedFields[campaign.FieldTargetGeography] = struct{}{}
}

// TargetGeographyCleared returns if the "target_geography" field was cleared in this mutation.
func (m *CampaignMutation) TargetGeographyCleared() bool {
	_, ok := m.clearedFields[campaign.FieldTargetGeography]
	return ok
}

// ResetTargetGeography resets all changes to the "target_geography" field.
func (m *CampaignMutation) ResetTargetGeography() {
	m.target_geography = nil
	delete(m.clearedFields, campaign.FieldTargetGeography)
}

// SetTargetDemographics sets the "target_demographics" field.
func (m *CampaignMutation) SetTargetDemographics(value map[string]interface{}) {
	m.target_demographics = &value
}

// TargetDemographics returns the value of the "target_demographics" field in the mutation.
func (m *CampaignMutation) TargetDemographics() (r map[string]interface{}, exists bool) {
	v := m.target_demographics
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDemographics returns the old "target_demographics" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTargetDemographics(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDemographics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDemographics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDemographics: %w", err)
	}
	return oldValue.TargetDemographics, nil
}

// ClearTargetDemographics clears the value of the "target_demographics" field.
func (m *CampaignMutation) ClearTargetDemographics() {
	m.target_demographics = nil
	m.clearedFields[campaign.FieldTargetDemographics] = struct{}{}
}

// TargetDemographicsCleared returns if the "target_demographics" field was cleared in this mutation.
func (m *CampaignMutation) TargetDemographicsCleared() bool {
	_, ok := m.clearedFields[campaign.FieldTargetDemographics]
	return ok
}

// ResetTargetDemographics resets all changes to the "target_demographics" field.
func (m *CampaignMutation) ResetTargetDemographics() {
	m.target_demographics = nil
	delete(m.clearedFields, campaign.FieldTargetDemographics)
}

// SetStartDate sets the "start_date" field.
func (m *CampaignMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *CampaignMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *CampaignMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *CampaignMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *CampaignMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *CampaignMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[campaign.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *CampaignMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[campaign.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *CampaignMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, campaign.FieldEndDate)
}

// SetStatus sets the "status" field.
func (m *CampaignMutation) SetStatus(c campaign.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CampaignMutation) Status() (r campaign.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStatus(ctx context.Context) (v campaign.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CampaignMutation) ResetStatus() {
	m.status = nil
}

// SetTrackingURL sets the "tracking_url" field.
func (m *CampaignMutation) SetTrackingURL(s string) {
	m.tracking_url = &s
}

// TrackingURL returns the value of the "tracking_url" field in the mutation.
func (m *CampaignMutation) TrackingURL() (r string, exists bool) {
	v := m.tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingURL returns the old "tracking_url" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingURL: %w", err)
	}
	return oldValue.TrackingURL, nil
}

// ClearTrackingURL clears the value of the "tracking_url" field.
func (m *CampaignMutation) ClearTrackingURL() {
	m.tracking_url = nil
	m.clearedFields[campaign.FieldTrackingURL] = struct{}{}
}

// TrackingURLCleared returns if the "tracking_url" field was cleared in this mutation.
func (m *CampaignMutation) TrackingURLCleared() bool {
	_, ok := m.clearedFields[campaign.FieldTrackingURL]
	return ok
}

// ResetTrackingURL resets all changes to the "tracking_url" field.
func (m *CampaignMutation) ResetTrackingURL() {
	m.tracking_url = nil
	delete(m.clearedFields, campaign.FieldTrackingURL)
}

// SetTotalClicks sets the "total_clicks" field.
func (m *CampaignMutation) SetTotalClicks(i int) {
	m.total_clicks = &i
	m.addtotal_clicks = nil
}

// TotalClicks returns the value of the "total_clicks" field in the mutation.
func (m *CampaignMutation) TotalClicks() (r int, exists bool) {
	v := m.total_clicks
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalClicks returns the old "total_clicks" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTotalClicks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalClicks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalClicks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalClicks: %w", err)
	}
	return oldValue.TotalClicks, nil
}

// AddTotalClicks adds i to the "total_clicks" field.
func (m *CampaignMutation) AddTotalClicks(i int) {
	if m.addtotal_clicks != nil {
		*m.addtotal_clicks += i
	} else {
		m.addtotal_clicks = &i
	}
}

// AddedTotalClicks returns the value that was added to the "total_clicks" field in this mutation.
func (m *CampaignMutation) AddedTotalClicks() (r int, exists bool) {
	v := m.addtotal_clicks
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalClicks resets all changes to the "total_clicks" field.
func (m *CampaignMutation) ResetTotalClicks() {
	m.total_clicks = nil
	m.addtotal_clicks = nil
}

// SetTotalConversions sets the "total_conversions" field.
func (m *CampaignMutation) SetTotalConversions(i int) {
	m.total_conversions = &i
	m.addtotal_conversions = nil
}

// TotalConversions returns the value of the "total_conversions" field in the mutation.
func (m *CampaignMutation) TotalConversions() (r int, exists bool) {
	v := m.total_conversions
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalConversions returns the old "total_conversions" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTotalConversions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalConversions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalConversions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalConversions: %w", err)
	}
	return oldValue.TotalConversions, nil
}

// AddTotalConversions adds i to the "total_conversions" field.
func (m *CampaignMutation) AddTotalConversions(i int) {
	if m.addtotal_conversions != nil {
		*m.addtotal_conversions += i
	} else {
		m.addtotal_conversions = &i
	}
}

// AddedTotalConversions returns the value that was added to the "total_conversions" field in this mutation.
func (m *CampaignMutation) AddedTotalConversions() (r int, exists bool) {
	v := m.addtotal_conversions
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalConversions resets all changes to the "total_conversions" field.
func (m *CampaignMutation) ResetTotalConversions() {
	m.total_conversions = nil
	m.addtotal_conversions = nil
}

// SetTotalRevenue sets the "total_revenue" field.
func (m *CampaignMutation) SetTotalRevenue(f float64) {
	m.total_revenue = &f
	m.addtotal_revenue = nil
}

// TotalRevenue returns the value of the "total_revenue" field in the mutation.
func (m *CampaignMutation) TotalRevenue() (r float64, exists bool) {
	v := m.total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRevenue returns the old "total_revenue" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTotalRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRevenue: %w", err)
	}
	return oldValue.TotalRevenue, nil
}

// AddTotalRevenue adds f to the "total_revenue" field.
func (m *CampaignMutation) AddTotalRevenue(f float64) {
	if m.addtotal_revenue != nil {
		*m.addtotal_revenue += f
	} else {
		m.addtotal_revenue = &f
	}
}

// AddedTotalRevenue returns the value that was added to the "total_revenue" field in this mutation.
func (m *CampaignMutation) AddedTotalRevenue() (r float64, exists bool) {
	v := m.addtotal_revenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRevenue resets all changes to the "total_revenue" field.
func (m *CampaignMutation) ResetTotalRevenue() {
	m.total_revenue = nil
	m.addtotal_revenue = nil
}

// SetConversionRate sets the "conversion_rate" field.
func (m *CampaignMutation) SetConversionRate(f float64) {
	m.conversion_rate = &f
	m.addconversion_rate = nil
}

// ConversionRate returns the value of the "conversion_rate" field in the mutation.
func (m *CampaignMutation) ConversionRate() (r float64, exists bool) {
	v := m.conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldConversionRate returns the old "conversion_rate" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldConversionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversionRate: %w", err)
	}
	return oldValue.ConversionRate, nil
}

// AddConversionRate adds f to the "conversion_rate" field.
func (m *CampaignMutation) AddConversionRate(f float64) {
	if m.addconversion_rate != nil {
		*m.addconversion_rate += f
	} else {
		m.addconversion_rate = &f
	}
}

// AddedConversionRate returns the value that was added to the "conversion_rate" field in this mutation.
func (m *CampaignMutation) AddedConversionRate() (r float64, exists bool) {
	v := m.addconversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetConversionRate resets all changes to the "conversion_rate" field.
func (m *CampaignMutation) ResetConversionRate() {
	m.conversion_rate = nil
	m.addconversion_rate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CampaignMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CampaignMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CampaignMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CampaignMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CampaignMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CampaignMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CampaignMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CampaignMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CampaignMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddLinkIDs adds the "links" edge to the CampaignLink entity by ids.
func (m *CampaignMutation) AddLinkIDs(ids ...int64) {
	if m.links == nil {
		m.links = make(map[int64]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the CampaignLink entity.
func (m *CampaignMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the CampaignLink entity was cleared.
func (m *CampaignMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the CampaignLink entity by IDs.
func (m *CampaignMutation) RemoveLinkIDs(ids ...int64) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the CampaignLink entity.
func (m *CampaignMutation) RemovedLinksIDs() (ids []int64) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *CampaignMutation) LinksIDs() (ids []int64) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *CampaignMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// AddTrackIDs adds the "tracks" edge to the Track entity by ids.
func (m *CampaignMutation) AddTrackIDs(ids ...int64) {
	if m.tracks == nil {
		m.tracks = make(map[int64]struct{})
	}
	for i := range ids {
		m.tracks[ids[i]] = struct{}{}
	}
}

// ClearTracks clears the "tracks" edge to the Track entity.
func (m *CampaignMutation) ClearTracks() {
	m.clearedtracks = true
}

// TracksCleared reports if the "tracks" edge to the Track entity was cleared.
func (m *CampaignMutation) TracksCleared() bool {
	return m.clearedtracks
}

// RemoveTrackIDs removes the "tracks" edge to the Track entity by IDs.
func (m *CampaignMutation) RemoveTrackIDs(ids ...int64) {
	if m.removedtracks == nil {
		m.removedtracks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tracks, ids[i])
		m.removedtracks[ids[i]] = struct{}{}
	}
}

// RemovedTracks returns the removed IDs of the "tracks" edge to the Track entity.
func (m *CampaignMutation) RemovedTracksIDs() (ids []int64) {
	for id := range m.removedtracks {
		ids = append(ids, id)
	}
	return
}

// TracksIDs returns the "tracks" edge IDs in the mutation.
func (m *CampaignMutation) TracksIDs() (ids []int64) {
	for id := range m.tracks {
		ids = append(ids, id)
	}
	return
}

// ResetTracks resets all changes to the "tracks" edge.
func (m *CampaignMutation) ResetTracks() {
	m.tracks = nil
	m.clearedtracks = false
	m.removedtracks = nil
}

// AddReferralIDs adds the "referrals" edge to the Referral entity by ids.
func (m *CampaignMutation) AddReferralIDs(ids ...int64) {
	if m.referrals == nil {
		m.referrals = make(map[int64]struct{})
	}
	for i := range ids {
		m.referrals[ids[i]] = struct{}{}
	}
}

// ClearReferrals clears the "referrals" edge to the Referral entity.
func (m *CampaignMutation) ClearReferrals() {
	m.clearedreferrals = true
}

// ReferralsCleared reports if the "referrals" edge to the Referral entity was cleared.
func (m *CampaignMutation) ReferralsCleared() bool {
	return m.clearedreferrals
}

// RemoveReferralIDs removes the "referrals" edge to the Referral entity by IDs.
func (m *CampaignMutation) RemoveReferralIDs(ids ...int64) {
	if m.removedreferrals == nil {
		m.removedreferrals = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.referrals, ids[i])
		m.removedreferrals[ids[i]] = struct{}{}
	}
}

// RemovedReferrals returns the removed IDs of the "referrals" edge to the Referral entity.
func (m *CampaignMutation) RemovedReferralsIDs() (ids []int64) {
	for id := range m.removedreferrals {
		ids = append(ids, id)
	}
	return
}

// ReferralsIDs returns the "referrals" edge IDs in the mutation.
func (m *CampaignMutation) ReferralsIDs() (ids []int64) {
	for id := range m.referrals {
		ids = append(ids, id)
	}
	return
}

// ResetReferrals resets all changes to the "referrals" edge.
func (m *CampaignMutation) ResetReferrals() {
	m.referrals = nil
	m.clearedreferrals = false
	m.removedreferrals = nil
}

// AddBannerIDs adds the "banners" edge to the Banner entity by ids.
func (m *CampaignMutation) AddBannerIDs(ids ...int64) {
	if m.banners == nil {
		m.banners = make(map[int64]struct{})
	}
	for i := range ids {
		m.banners[ids[i]] = struct{}{}
	}
}

// ClearBanners clears the "banners" edge to the Banner entity.
func (m *CampaignMutation) ClearBanners() {
	m.clearedbanners = true
}

// BannersCleared reports if the "banners" edge to the Banner entity was cleared.
func (m *CampaignMutation) BannersCleared() bool {
	return m.clearedbanners
}

// RemoveBannerIDs removes the "banners" edge to the Banner entity by IDs.
func (m *CampaignMutation) RemoveBannerIDs(ids ...int64) {
	if m.removedbanners == nil {
		m.removedbanners = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.banners, ids[i])
		m.removedbanners[ids[i]] = struct{}{}
	}
}

// RemovedBanners returns the removed IDs of the "banners" edge to the Banner entity.
func (m *CampaignMutation) RemovedBannersIDs() (ids []int64) {
	for id := range m.removedbanners {
		ids = append(ids, id)
	}
	return
}

// BannersIDs returns the "banners" edge IDs in the mutation.
func (m *CampaignMutation) BannersIDs() (ids []int64) {
	for id := range m.banners {
		ids = append(ids, id)
	}
	return
}

// ResetBanners resets all changes to the "banners" edge.
func (m *CampaignMutation) ResetBanners() {
	m.banners = nil
	m.clearedbanners = false
	m.removedbanners = nil
}

// Where appends a list predicates to the CampaignMutation builder.
func (m *CampaignMutation) Where(ps ...predicate.Campaign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Campaign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Campaign).
func (m *CampaignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.name != nil {
		fields = append(fields, campaign.FieldName)
	}
	if m.description != nil {
		fields = append(fields, campaign.FieldDescription)
	}
	if m.unique_code != nil {
		fields = append(fields, campaign.FieldUniqueCode)
	}
	if m._type != nil {
		fields = append(fields, campaign.FieldType)
	}
	if m.commission_type != nil {
		fields = append(fields, campaign.FieldCommissionType)
	}
	if m.base_commission_rate != nil {
		fields = append(fields, campaign.FieldBaseCommissionRate)
	}
	if m.commission_tiers != nil {
		fields = append(fields, campaign.FieldCommissionTiers)
	}
	if m.target_geography != nil {
		fields = append(fields, campaign.FieldTargetGeography)
	}
	if m.target_demographics != nil {
		fields = append(fields, campaign.FieldTargetDemographics)
	}
	if m.start_date != nil {
		fields = append(fields, campaign.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, campaign.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, campaign.FieldStatus)
	}
	if m.tracking_url != nil {
		fields = append(fields, campaign.FieldTrackingURL)
	}
	if m.total_clicks != nil {
		fields = append(fields, campaign.FieldTotalClicks)
	}
	if m.total_conversions != nil {
		fields = append(fields, campaign.FieldTotalConversions)
	}
	if m.total_revenue != nil {
		fields = append(fields, campaign.FieldTotalRevenue)
	}
	if m.conversion_rate != nil {
		fields = append(fields, campaign.FieldConversionRate)
	}
	if m.created_at != nil {
		fields = append(fields, campaign.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, campaign.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldName:
		return m.Name()
	case campaign.FieldDescription:
		return m.Description()
	case campaign.FieldUniqueCode:
		return m.UniqueCode()
	case campaign.FieldType:
		return m.GetType()
	case campaign.FieldCommissionType:
		return m.CommissionType()
	case campaign.FieldBaseCommissionRate:
		return m.BaseCommissionRate()
	case campaign.FieldCommissionTiers:
		return m.CommissionTiers()
	case campaign.FieldTargetGeography:
		return m.TargetGeography()
	case campaign.FieldTargetDemographics:
		return m.TargetDemographics()
	case campaign.FieldStartDate:
		return m.StartDate()
	case campaign.FieldEndDate:
		return m.EndDate()
	case campaign.FieldStatus:
		return m.Status()
	case campaign.FieldTrackingURL:
		return m.TrackingURL()
	case campaign.FieldTotalClicks:
		return m.TotalClicks()
	case campaign.FieldTotalConversions:
		return m.TotalConversions()
	case campaign.FieldTotalRevenue:
		return m.TotalRevenue()
	case campaign.FieldConversionRate:
		return m.ConversionRate()
	case campaign.FieldCreatedAt:
		return m.CreatedAt()
	case campaign.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaign.FieldName:
		return m.OldName(ctx)
	case campaign.FieldDescription:
		return m.OldDescription(ctx)
	case campaign.FieldUniqueCode:
		return m.OldUniqueCode(ctx)
	case campaign.FieldType:
		return m.OldType(ctx)
	case campaign.FieldCommissionType:
		return m.OldCommissionType(ctx)
	case campaign.FieldBaseCommissionRate:
		return m.OldBaseCommissionRate(ctx)
	case campaign.FieldCommissionTiers:
		return m.OldCommissionTiers(ctx)
	case campaign.FieldTargetGeography:
		return m.OldTargetGeography(ctx)
	case campaign.FieldTargetDemographics:
		return m.OldTargetDemographics(ctx)
	case campaign.FieldStartDate:
		return m.OldStartDate(ctx)
	case campaign.FieldEndDate:
		return m.OldEndDate(ctx)
	case campaign.FieldStatus:
		return m.OldStatus(ctx)
	case campaign.FieldTrackingURL:
		return m.OldTrackingURL(ctx)
	case campaign.FieldTotalClicks:
		return m.OldTotalClicks(ctx)
	case campaign.FieldTotalConversions:
		return m.OldTotalConversions(ctx)
	case campaign.FieldTotalRevenue:
		return m.OldTotalRevenue(ctx)
	case campaign.FieldConversionRate:
		return m.OldConversionRate(ctx)
	case campaign.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaign.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Campaign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case campaign.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case campaign.FieldUniqueCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueCode(v)
		return nil
	case campaign.FieldType:
		v, ok := value.(campaign.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case campaign.FieldCommissionType:
		v, ok := value.(campaign.CommissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionType(v)
		return nil
	case campaign.FieldBaseCommissionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCommissionRate(v)
		return nil
	case campaign.FieldCommissionTiers:
		v, ok := value.([]schema.CommissionTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionTiers(v)
		return nil
	case campaign.FieldTargetGeography:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetGeography(v)
		return nil
	case campaign.FieldTargetDemographics:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDemographics(v)
		return nil
	case campaign.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case campaign.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case campaign.FieldStatus:
		v, ok := value.(campaign.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case campaign.FieldTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingURL(v)
		return nil
	case campaign.FieldTotalClicks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalClicks(v)
		return nil
	case campaign.FieldTotalConversions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalConversions(v)
		return nil
	case campaign.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRevenue(v)
		return nil
	case campaign.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversionRate(v)
		return nil
	case campaign.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaign.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignMutation) AddedFields() []string {
	var fields []string
	if m.addbase_commission_rate != nil {
		fields = append(fields, campaign.FieldBaseCommissionRate)
	}
	if m.addtotal_clicks != nil {
		fields = append(fields, campaign.FieldTotalClicks)
	}
	if m.addtotal_conversions != nil {
		fields = append(fields, campaign.FieldTotalConversions)
	}
	if m.addtotal_revenue != nil {
		fields = append(fields, campaign.FieldTotalRevenue)
	}
	if m.addconversion_rate != nil {
		fields = append(fields, campaign.FieldConversionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldBaseCommissionRate:
		return m.AddedBaseCommissionRate()
	case campaign.FieldTotalClicks:
		return m.AddedTotalClicks()
	case campaign.FieldTotalConversions:
		return m.AddedTotalConversions()
	case campaign.FieldTotalRevenue:
		return m.AddedTotalRevenue()
	case campaign.FieldConversionRate:
		return m.AddedConversionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldBaseCommissionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseCommissionRate(v)
		return nil
	case campaign.FieldTotalClicks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalClicks(v)
		return nil
	case campaign.FieldTotalConversions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalConversions(v)
		return nil
	case campaign.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRevenue(v)
		return nil
	case campaign.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(campaign.FieldDescription) {
		fields = append(fields, campaign.FieldDescription)
	}
	if m.FieldCleared(campaign.FieldCommissionTiers) {
		fields = append(fields, campaign.FieldCommissionTiers)
	}
	if m.FieldCleared(campaign.FieldTargetGeography) {
		fields = append(fields, campaign.FieldTargetGeography)
	}
	if m.FieldCleared(campaign.FieldTargetDemographics) {
		fields = append(fields, campaign.FieldTargetDemographics)
	}
	if m.FieldCleared(campaign.FieldEndDate) {
		fields = append(fields, campaign.FieldEndDate)
	}
	if m.FieldCleared(campaign.FieldTrackingURL) {
		fields = append(fields, campaign.FieldTrackingURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignMutation) ClearField(name string) error {
	switch name {
	case campaign.FieldDescription:
		m.ClearDescription()
		return nil
	case campaign.FieldCommissionTiers:
		m.ClearCommissionTiers()
		return nil
	case campaign.FieldTargetGeography:
		m.ClearTargetGeography()
		return nil
	case campaign.FieldTargetDemographics:
		m.ClearTargetDemographics()
		return nil
	case campaign.FieldEndDate:
		m.ClearEndDate()
		return nil
	case campaign.FieldTrackingURL:
		m.ClearTrackingURL()
		return nil
	}
	return fmt.Errorf("unknown Campaign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignMutation) ResetField(name string) error {
	switch name {
	case campaign.FieldName:
		m.ResetName()
		return nil
	case campaign.FieldDescription:
		m.ResetDescription()
		return nil
	case campaign.FieldUniqueCode:
		m.ResetUniqueCode()
		return nil
	case campaign.FieldType:
		m.ResetType()
		return nil
	case campaign.FieldCommissionType:
		m.ResetCommissionType()
		return nil
	case campaign.FieldBaseCommissionRate:
		m.ResetBaseCommissionRate()
		return nil
	case campaign.FieldCommissionTiers:
		m.ResetCommissionTiers()
		return nil
	case campaign.FieldTargetGeography:
		m.ResetTargetGeography()
		return nil
	case campaign.FieldTargetDemographics:
		m.ResetTargetDemographics()
		return nil
	case campaign.FieldStartDate:
		m.ResetStartDate()
		return nil
	case campaign.FieldEndDate:
		m.ResetEndDate()
		return nil
	case campaign.FieldStatus:
		m.ResetStatus()
		return nil
	case campaign.FieldTrackingURL:
		m.ResetTrackingURL()
		return nil
	case campaign.FieldTotalClicks:
		m.ResetTotalClicks()
		return nil
	case campaign.FieldTotalConversions:
		m.ResetTotalConversions()
		return nil
	case campaign.FieldTotalRevenue:
		m.ResetTotalRevenue()
		return nil
	case campaign.FieldConversionRate:
		m.ResetConversionRate()
		return nil
	case campaign.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaign.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, campaign.EdgeOwner)
	}
	if m.links != nil {
		edges = append(edges, campaign.EdgeLinks)
	}
	if m.tracks != nil {
		edges = append(edges, campaign.EdgeTracks)
	}
	if m.referrals != nil {
		edges = append(edges, campaign.EdgeReferrals)
	}
	if m.banners != nil {
		edges = append(edges, campaign.EdgeBanners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case campaign.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeTracks:
		ids := make([]ent.Value, 0, len(m.tracks))
		for id := range m.tracks {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeReferrals:
		ids := make([]ent.Value, 0, len(m.referrals))
		for id := range m.referrals {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.banners))
		for id := range m.banners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedlinks != nil {
		edges = append(edges, campaign.EdgeLinks)
	}
	if m.removedtracks != nil {
		edges = append(edges, campaign.EdgeTracks)
	}
	if m.removedreferrals != nil {
		edges = append(edges, campaign.EdgeReferrals)
	}
	if m.removedbanners != nil {
		edges = append(edges, campaign.EdgeBanners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeTracks:
		ids := make([]ent.Value, 0, len(m.removedtracks))
		for id := range m.removedtracks {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeReferrals:
		ids := make([]ent.Value, 0, len(m.removedreferrals))
		for id := range m.removedreferrals {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.removedbanners))
		for id := range m.removedbanners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, campaign.EdgeOwner)
	}
	if m.clearedlinks {
		edges = append(edges, campaign.EdgeLinks)
	}
	if m.clearedtracks {
		edges = append(edges, campaign.EdgeTracks)
	}
	if m.clearedreferrals {
		edges = append(edges, campaign.EdgeReferrals)
	}
	if m.clearedbanners {
		edges = append(edges, campaign.EdgeBanners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignMutation) EdgeCleared(name string) bool {
	switch name {
	case campaign.EdgeOwner:
		return m.clearedowner
	case campaign.EdgeLinks:
		return m.clearedlinks
	case campaign.EdgeTracks:
		return m.clearedtracks
	case campaign.EdgeReferrals:
		return m.clearedreferrals
	case campaign.EdgeBanners:
		return m.clearedbanners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignMutation) ClearEdge(name string) error {
	switch name {
	case campaign.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Campaign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignMutation) ResetEdge(name string) error {
	switch name {
	case campaign.EdgeOwner:
		m.ResetOwner()
		return nil
	case campaign.EdgeLinks:
		m.ResetLinks()
		return nil
	case campaign.EdgeTracks:
		m.ResetTracks()
		return nil
	case campaign.EdgeReferrals:
		m.ResetReferrals()
		return nil
	case campaign.EdgeBanners:
		m.ResetBanners()
		return nil
	}
	return fmt.Errorf("unknown Campaign edge %s", name)
}

// CampaignLinkMutation represents an operation that mutates the CampaignLink nodes in the graph.
type CampaignLinkMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	unique_code     *string
	original_url    *string
	tracking_url    *string
	created_at      *time.Time
	is_active       *bool
	clearedFields   map[string]struct{}
	campaign        *int64
	clearedcampaign bool
	tracks          map[int64]struct{}
	removedtracks   map[int64]struct{}
	clearedtracks   bool
	done            bool
	oldValue        func(context.Context) (*CampaignLink, error)
	predicates      []predicate.CampaignLink
}

var _ ent.Mutation = (*CampaignLinkMutation)(nil)

// campaignlinkOption allows management of the mutation configuration using functional options.
type campaignlinkOption func(*CampaignLinkMutation)

// newCampaignLinkMutation creates new mutation for the CampaignLink entity.
func newCampaignLinkMutation(c config, op Op, opts ...campaignlinkOption) *CampaignLinkMutation {
	m := &CampaignLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaignLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignLinkID sets the ID field of the mutation.
func withCampaignLinkID(id int64) campaignlinkOption {
	return func(m *CampaignLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *CampaignLink
		)
		m.oldValue = func(ctx context.Context) (*CampaignLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CampaignLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaignLink sets the old CampaignLink of the mutation.
func withCampaignLink(node *CampaignLink) campaignlinkOption {
	return func(m *CampaignLinkMutation) {
		m.oldValue = func(context.Context) (*CampaignLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CampaignLink entities.
func (m *CampaignLinkMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignLinkMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignLinkMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CampaignLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUniqueCode sets the "unique_code" field.
func (m *CampaignLinkMutation) SetUniqueCode(s string) {
	m.unique_code = &s
}

// UniqueCode returns the value of the "unique_code" field in the mutation.
func (m *CampaignLinkMutation) UniqueCode() (r string, exists bool) {
	v := m.unique_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueCode returns the old "unique_code" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldUniqueCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueCode: %w", err)
	}
	return oldValue.UniqueCode, nil
}

// ResetUniqueCode resets all changes to the "unique_code" field.
func (m *CampaignLinkMutation) ResetUniqueCode() {
	m.unique_code = nil
}

// SetOriginalURL sets the "original_url" field.
func (m *CampaignLinkMutation) SetOriginalURL(s string) {
	m.original_url = &s
}

// OriginalURL returns the value of the "original_url" field in the mutation.
func (m *CampaignLinkMutation) OriginalURL() (r string, exists bool) {
	v := m.original_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalURL returns the old "original_url" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldOriginalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalURL: %w", err)
	}
	return oldValue.OriginalURL, nil
}

// ResetOriginalURL resets all changes to the "original_url" field.
func (m *CampaignLinkMutation) ResetOriginalURL() {
	m.original_url = nil
}

// SetTrackingURL sets the "tracking_url" field.
func (m *CampaignLinkMutation) SetTrackingURL(s string) {
	m.tracking_url = &s
}

// TrackingURL returns the value of the "tracking_url" field in the mutation.
func (m *CampaignLinkMutation) TrackingURL() (r string, exists bool) {
	v := m.tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingURL returns the old "tracking_url" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingURL: %w", err)
	}
	return oldValue.TrackingURL, nil
}

// ResetTrackingURL resets all changes to the "tracking_url" field.
func (m *CampaignLinkMutation) ResetTrackingURL() {
	m.tracking_url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIsActive sets the "is_active" field.
func (m *CampaignLinkMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CampaignLinkMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CampaignLinkMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCampaignID sets the "campaign" edge to the Campaign entity by id.
func (m *CampaignLinkMutation) SetCampaignID(id int64) {
	m.campaign = &id
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *CampaignLinkMutation) ClearCampaign() {
	m.clearedcampaign = true
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *CampaignLinkMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignID returns the "campaign" edge ID in the mutation.
func (m *CampaignLinkMutation) CampaignID() (id int64, exists bool) {
	if m.campaign != nil {
		return *m.campaign, true
	}
	return
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *CampaignLinkMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *CampaignLinkMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// AddTrackIDs adds the "tracks" edge to the Track entity by ids.
func (m *CampaignLinkMutation) AddTrackIDs(ids ...int64) {
	if m.tracks == nil {
		m.tracks = make(map[int64]struct{})
	}
	for i := range ids {
		m.tracks[ids[i]] = struct{}{}
	}
}

// ClearTracks clears the "tracks" edge to the Track entity.
func (m *CampaignLinkMutation) ClearTracks() {
	m.clearedtracks = true
}

// TracksCleared reports if the "tracks" edge to the Track entity was cleared.
func (m *CampaignLinkMutation) TracksCleared() bool {
	return m.clearedtracks
}

// RemoveTrackIDs removes the "tracks" edge to the Track entity by IDs.
func (m *CampaignLinkMutation) RemoveTrackIDs(ids ...int64) {
	if m.removedtracks == nil {
		m.removedtracks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tracks, ids[i])
		m.removedtracks[ids[i]] = struct{}{}
	}
}

// RemovedTracks returns the removed IDs of the "tracks" edge to the Track entity.
func (m *CampaignLinkMutation) RemovedTracksIDs() (ids []int64) {
	for id := range m.removedtracks {
		ids = append(ids, id)
	}
	return
}

// TracksIDs returns the "tracks" edge IDs in the mutation.
func (m *CampaignLinkMutation) TracksIDs() (ids []int64) {
	for id := range m.tracks {
		ids = append(ids, id)
	}
	return
}

// ResetTracks resets all changes to the "tracks" edge.
func (m *CampaignLinkMutation) ResetTracks() {
	m.tracks = nil
	m.clearedtracks = false
	m.removedtracks = nil
}

// Where appends a list predicates to the CampaignLinkMutation builder.
func (m *CampaignLinkMutation) Where(ps ...predicate.CampaignLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CampaignLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CampaignLink).
func (m *CampaignLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignLinkMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.unique_code != nil {
		fields = append(fields, campaignlink.FieldUniqueCode)
	}
	if m.original_url != nil {
		fields = append(fields, campaignlink.FieldOriginalURL)
	}
	if m.tracking_url != nil {
		fields = append(fields, campaignlink.FieldTrackingURL)
	}
	if m.created_at != nil {
		fields = append(fields, campaignlink.FieldCreatedAt)
	}
	if m.is_active != nil {
		fields = append(fields, campaignlink.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaignlink.FieldUniqueCode:
		return m.UniqueCode()
	case campaignlink.FieldOriginalURL:
		return m.OriginalURL()
	case campaignlink.FieldTrackingURL:
		return m.TrackingURL()
	case campaignlink.FieldCreatedAt:
		return m.CreatedAt()
	case campaignlink.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaignlink.FieldUniqueCode:
		return m.OldUniqueCode(ctx)
	case campaignlink.FieldOriginalURL:
		return m.OldOriginalURL(ctx)
	case campaignlink.FieldTrackingURL:
		return m.OldTrackingURL(ctx)
	case campaignlink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaignlink.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown CampaignLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaignlink.FieldUniqueCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueCode(v)
		return nil
	case campaignlink.FieldOriginalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalURL(v)
		return nil
	case campaignlink.FieldTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingURL(v)
		return nil
	case campaignlink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaignlink.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown CampaignLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CampaignLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignLinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignLinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CampaignLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignLinkMutation) ResetField(name string) error {
	switch name {
	case campaignlink.FieldUniqueCode:
		m.ResetUniqueCode()
		return nil
	case campaignlink.FieldOriginalURL:
		m.ResetOriginalURL()
		return nil
	case campaignlink.FieldTrackingURL:
		m.ResetTrackingURL()
		return nil
	case campaignlink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaignlink.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown CampaignLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.campaign != nil {
		edges = append(edges, campaignlink.EdgeCampaign)
	}
	if m.tracks != nil {
		edges = append(edges, campaignlink.EdgeTracks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaignlink.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	case campaignlink.EdgeTracks:
		ids := make([]ent.Value, 0, len(m.tracks))
		for id := range m.tracks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtracks != nil {
		edges = append(edges, campaignlink.EdgeTracks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignLinkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case campaignlink.EdgeTracks:
		ids := make([]ent.Value, 0, len(m.removedtracks))
		for id := range m.removedtracks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcampaign {
		edges = append(edges, campaignlink.EdgeCampaign)
	}
	if m.clearedtracks {
		edges = append(edges, campaignlink.EdgeTracks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case campaignlink.EdgeCampaign:
		return m.clearedcampaign
	case campaignlink.EdgeTracks:
		return m.clearedtracks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignLinkMutation) ClearEdge(name string) error {
	switch name {
	case campaignlink.EdgeCampaign:
		m.ClearCampaign()
		return nil
	}
	return fmt.Errorf("unknown CampaignLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignLinkMutation) ResetEdge(name string) error {
	switch name {
	case campaignlink.EdgeCampaign:
		m.ResetCampaign()
		return nil
	case campaignlink.EdgeTracks:
		m.ResetTracks()
		return nil
	}
	return fmt.Errorf("unknown CampaignLink edge %s", name)
}

// LeadMutation represents an operation that mutates the Lead nodes in the graph.
type LeadMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	reference_id  *string
	_type         *lead.Type
	amount        *float64
	addamount     *float64
	currency      *string
	ip_address    *string
	user_agent    *string
	metadata      *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	banner        *int64
	clearedbanner bool
	done          bool
	oldValue      func(context.Context) (*Lead, error)
	predicates    []predicate.Lead
}

var _ ent.Mutation = (*LeadMutation)(nil)

// leadOption allows management of the mutation configuration using functional options.
type leadOption func(*LeadMutation)

// newLeadMutation creates new mutation for the Lead entity.
func newLeadMutation(c config, op Op, opts ...leadOption) *LeadMutation {
	m := &LeadMutation{
		config:        c,
		op:            op,
		typ:           TypeLead,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadID sets the ID field of the mutation.
func withLeadID(id int64) leadOption {
	return func(m *LeadMutation) {
		var (
			err   error
			once  sync.Once
			value *Lead
		)
		m.oldValue = func(ctx context.Context) (*Lead, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lead.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLead sets the old Lead of the mutation.
func withLead(node *Lead) leadOption {
	return func(m *LeadMutation) {
		m.oldValue = func(context.Context) (*Lead, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Lead entities.
func (m *LeadMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lead.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReferenceID sets the "reference_id" field.
func (m *LeadMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *LeadMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *LeadMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[lead.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *LeadMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[lead.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *LeadMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, lead.FieldReferenceID)
}

// SetType sets the "type" field.
func (m *LeadMutation) SetType(l lead.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LeadMutation) GetType() (r lead.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldType(ctx context.Context) (v lead.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LeadMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *LeadMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LeadMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *LeadMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *LeadMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *LeadMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[lead.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *LeadMutation) AmountCleared() bool {
	_, ok := m.clearedFields[lead.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *LeadMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, lead.FieldAmount)
}

// SetCurrency sets the "currency" field.
func (m *LeadMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *LeadMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *LeadMutation) ResetCurrency() {
	m.currency = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *LeadMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *LeadMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *LeadMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[lead.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *LeadMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[lead.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *LeadMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, lead.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *LeadMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LeadMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LeadMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[lead.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LeadMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[lead.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LeadMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, lead.FieldUserAgent)
}

// SetMetadata sets the "metadata" field.
func (m *LeadMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LeadMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LeadMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[lead.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LeadMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[lead.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LeadMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, lead.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetBannerID sets the "banner" edge to the Banner entity by id.
func (m *LeadMutation) SetBannerID(id int64) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *LeadMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *LeadMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *LeadMutation) BannerID() (id int64, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *LeadMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *LeadMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the LeadMutation builder.
func (m *LeadMutation) Where(ps ...predicate.Lead) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lead, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lead).
func (m *LeadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.reference_id != nil {
		fields = append(fields, lead.FieldReferenceID)
	}
	if m._type != nil {
		fields = append(fields, lead.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, lead.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, lead.FieldCurrency)
	}
	if m.ip_address != nil {
		fields = append(fields, lead.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, lead.FieldUserAgent)
	}
	if m.metadata != nil {
		fields = append(fields, lead.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, lead.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldReferenceID:
		return m.ReferenceID()
	case lead.FieldType:
		return m.GetType()
	case lead.FieldAmount:
		return m.Amount()
	case lead.FieldCurrency:
		return m.Currency()
	case lead.FieldIPAddress:
		return m.IPAddress()
	case lead.FieldUserAgent:
		return m.UserAgent()
	case lead.FieldMetadata:
		return m.Metadata()
	case lead.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lead.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case lead.FieldType:
		return m.OldType(ctx)
	case lead.FieldAmount:
		return m.OldAmount(ctx)
	case lead.FieldCurrency:
		return m.OldCurrency(ctx)
	case lead.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case lead.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case lead.FieldMetadata:
		return m.OldMetadata(ctx)
	case lead.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Lead field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lead.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case lead.FieldType:
		v, ok := value.(lead.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case lead.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case lead.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case lead.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case lead.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case lead.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case lead.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, lead.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lead.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Lead numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lead.FieldReferenceID) {
		fields = append(fields, lead.FieldReferenceID)
	}
	if m.FieldCleared(lead.FieldAmount) {
		fields = append(fields, lead.FieldAmount)
	}
	if m.FieldCleared(lead.FieldIPAddress) {
		fields = append(fields, lead.FieldIPAddress)
	}
	if m.FieldCleared(lead.FieldUserAgent) {
		fields = append(fields, lead.FieldUserAgent)
	}
	if m.FieldCleared(lead.FieldMetadata) {
		fields = append(fields, lead.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadMutation) ClearField(name string) error {
	switch name {
	case lead.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case lead.FieldAmount:
		m.ClearAmount()
		return nil
	case lead.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case lead.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case lead.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Lead nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadMutation) ResetField(name string) error {
	switch name {
	case lead.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case lead.FieldType:
		m.ResetType()
		return nil
	case lead.FieldAmount:
		m.ResetAmount()
		return nil
	case lead.FieldCurrency:
		m.ResetCurrency()
		return nil
	case lead.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case lead.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case lead.FieldMetadata:
		m.ResetMetadata()
		return nil
	case lead.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner != nil {
		edges = append(edges, lead.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lead.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner {
		edges = append(edges, lead.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadMutation) EdgeCleared(name string) bool {
	switch name {
	case lead.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadMutation) ClearEdge(name string) error {
	switch name {
	case lead.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown Lead unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadMutation) ResetEdge(name string) error {
	switch name {
	case lead.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown Lead edge %s", name)
}

// PayoutMutation represents an operation that mutates the Payout nodes in the graph.
type PayoutMutation struct {
	config
	op             Op
	typ            string
	id             *string
	amount         *float64
	addamount      *float64
	paid_at        *time.Time
	status         *payout.Status
	transaction_id *string
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Payout, error)
	predicates     []predicate.Payout
}

var _ ent.Mutation = (*PayoutMutation)(nil)

// payoutOption allows management of the mutation configuration using functional options.
type payoutOption func(*PayoutMutation)

// newPayoutMutation creates new mutation for the Payout entity.
func newPayoutMutation(c config, op Op, opts ...payoutOption) *PayoutMutation {
	m := &PayoutMutation{
		config:        c,
		op:            op,
		typ:           TypePayout,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayoutID sets the ID field of the mutation.
func withPayoutID(id string) payoutOption {
	return func(m *PayoutMutation) {
		var (
			err   error
			once  sync.Once
			value *Payout
		)
		m.oldValue = func(ctx context.Context) (*Payout, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payout.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayout sets the old Payout of the mutation.
func withPayout(node *Payout) payoutOption {
	return func(m *PayoutMutation) {
		m.oldValue = func(context.Context) (*Payout, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayoutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayoutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payout entities.
func (m *PayoutMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayoutMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayoutMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payout.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *PayoutMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PayoutMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PayoutMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PayoutMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PayoutMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *PayoutMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PayoutMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldPaidAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PayoutMutation) ResetPaidAt() {
	m.paid_at = nil
}

// SetStatus sets the "status" field.
func (m *PayoutMutation) SetStatus(pa payout.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PayoutMutation) Status() (r payout.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldStatus(ctx context.Context) (v payout.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PayoutMutation) ResetStatus() {
	m.status = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *PayoutMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *PayoutMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ClearTransactionID clears the value of the "transaction_id" field.
func (m *PayoutMutation) ClearTransactionID() {
	m.transaction_id = nil
	m.clearedFields[payout.FieldTransactionID] = struct{}{}
}

// TransactionIDCleared returns if the "transaction_id" field was cleared in this mutation.
func (m *PayoutMutation) TransactionIDCleared() bool {
	_, ok := m.clearedFields[payout.FieldTransactionID]
	return ok
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *PayoutMutation) ResetTransactionID() {
	m.transaction_id = nil
	delete(m.clearedFields, payout.FieldTransactionID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PayoutMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PayoutMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PayoutMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PayoutMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PayoutMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PayoutMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PayoutMutation builder.
func (m *PayoutMutation) Where(ps ...predicate.Payout) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PayoutMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PayoutMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payout, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PayoutMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PayoutMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payout).
func (m *PayoutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayoutMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.amount != nil {
		fields = append(fields, payout.FieldAmount)
	}
	if m.paid_at != nil {
		fields = append(fields, payout.FieldPaidAt)
	}
	if m.status != nil {
		fields = append(fields, payout.FieldStatus)
	}
	if m.transaction_id != nil {
		fields = append(fields, payout.FieldTransactionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayoutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payout.FieldAmount:
		return m.Amount()
	case payout.FieldPaidAt:
		return m.PaidAt()
	case payout.FieldStatus:
		return m.Status()
	case payout.FieldTransactionID:
		return m.TransactionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayoutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payout.FieldAmount:
		return m.OldAmount(ctx)
	case payout.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case payout.FieldStatus:
		return m.OldStatus(ctx)
	case payout.FieldTransactionID:
		return m.OldTransactionID(ctx)
	}
	return nil, fmt.Errorf("unknown Payout field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayoutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payout.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payout.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case payout.FieldStatus:
		v, ok := value.(payout.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case payout.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	}
	return fmt.Errorf("unknown Payout field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayoutMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payout.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayoutMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payout.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayoutMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payout.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payout numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayoutMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payout.FieldTransactionID) {
		fields = append(fields, payout.FieldTransactionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayoutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayoutMutation) ClearField(name string) error {
	switch name {
	case payout.FieldTransactionID:
		m.ClearTransactionID()
		return nil
	}
	return fmt.Errorf("unknown Payout nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayoutMutation) ResetField(name string) error {
	switch name {
	case payout.FieldAmount:
		m.ResetAmount()
		return nil
	case payout.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case payout.FieldStatus:
		m.ResetStatus()
		return nil
	case payout.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	}
	return fmt.Errorf("unknown Payout field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayoutMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, payout.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayoutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payout.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayoutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayoutMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayoutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, payout.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayoutMutation) EdgeCleared(name string) bool {
	switch name {
	case payout.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayoutMutation) ClearEdge(name string) error {
	switch name {
	case payout.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Payout unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayoutMutation) ResetEdge(name string) error {
	switch name {
	case payout.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Payout edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op            Op
	typ           string
	id            *string
	title         *string
	content       *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	author        *int64
	clearedauthor bool
	done          bool
	oldValue      func(context.Context) (*Post, error)
	predicates    []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id string) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *PostMutation) SetAuthorID(id int64) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *PostMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *PostMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *PostMutation) AuthorID() (id int64, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *PostMutation) AuthorIDs() (ids []int64) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldTitle:
		return m.Title()
	case post.FieldContent:
		return m.Content()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.author != nil {
		edges = append(edges, post.EdgeAuthor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthor {
		edges = append(edges, post.EdgeAuthor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeAuthor:
		return m.clearedauthor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// ReferralMutation represents an operation that mutates the Referral nodes in the graph.
type ReferralMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	status               *referral.Status
	commission_amount    *float64
	addcommission_amount *float64
	created_at           *time.Time
	processed_at         *time.Time
	clearedFields        map[string]struct{}
	referrer             *int64
	clearedreferrer      bool
	campaign             *int64
	clearedcampaign      bool
	done                 bool
	oldValue             func(context.Context) (*Referral, error)
	predicates           []predicate.Referral
}

var _ ent.Mutation = (*ReferralMutation)(nil)

// referralOption allows management of the mutation configuration using functional options.
type referralOption func(*ReferralMutation)

// newReferralMutation creates new mutation for the Referral entity.
func newReferralMutation(c config, op Op, opts ...referralOption) *ReferralMutation {
	m := &ReferralMutation{
		config:        c,
		op:            op,
		typ:           TypeReferral,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReferralID sets the ID field of the mutation.
func withReferralID(id int64) referralOption {
	return func(m *ReferralMutation) {
		var (
			err   error
			once  sync.Once
			value *Referral
		)
		m.oldValue = func(ctx context.Context) (*Referral, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Referral.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReferral sets the old Referral of the mutation.
func withReferral(node *Referral) referralOption {
	return func(m *ReferralMutation) {
		m.oldValue = func(context.Context) (*Referral, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReferralMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReferralMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Referral entities.
func (m *ReferralMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReferralMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReferralMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Referral.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ReferralMutation) SetStatus(r referral.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReferralMutation) Status() (r referral.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Referral entity.
// If the Referral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralMutation) OldStatus(ctx context.Context) (v referral.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReferralMutation) ResetStatus() {
	m.status = nil
}

// SetCommissionAmount sets the "commission_amount" field.
func (m *ReferralMutation) SetCommissionAmount(f float64) {
	m.commission_amount = &f
	m.addcommission_amount = nil
}

// CommissionAmount returns the value of the "commission_amount" field in the mutation.
func (m *ReferralMutation) CommissionAmount() (r float64, exists bool) {
	v := m.commission_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionAmount returns the old "commission_amount" field's value of the Referral entity.
// If the Referral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralMutation) OldCommissionAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionAmount: %w", err)
	}
	return oldValue.CommissionAmount, nil
}

// AddCommissionAmount adds f to the "commission_amount" field.
func (m *ReferralMutation) AddCommissionAmount(f float64) {
	if m.addcommission_amount != nil {
		*m.addcommission_amount += f
	} else {
		m.addcommission_amount = &f
	}
}

// AddedCommissionAmount returns the value that was added to the "commission_amount" field in this mutation.
func (m *ReferralMutation) AddedCommissionAmount() (r float64, exists bool) {
	v := m.addcommission_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommissionAmount resets all changes to the "commission_amount" field.
func (m *ReferralMutation) ResetCommissionAmount() {
	m.commission_amount = nil
	m.addcommission_amount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReferralMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReferralMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Referral entity.
// If the Referral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReferralMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetProcessedAt sets the "processed_at" field.
func (m *ReferralMutation) SetProcessedAt(t time.Time) {
	m.processed_at = &t
}

// ProcessedAt returns the value of the "processed_at" field in the mutation.
func (m *ReferralMutation) ProcessedAt() (r time.Time, exists bool) {
	v := m.processed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedAt returns the old "processed_at" field's value of the Referral entity.
// If the Referral object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralMutation) OldProcessedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedAt: %w", err)
	}
	return oldValue.ProcessedAt, nil
}

// ClearProcessedAt clears the value of the "processed_at" field.
func (m *ReferralMutation) ClearProcessedAt() {
	m.processed_at = nil
	m.clearedFields[referral.FieldProcessedAt] = struct{}{}
}

// ProcessedAtCleared returns if the "processed_at" field was cleared in this mutation.
func (m *ReferralMutation) ProcessedAtCleared() bool {
	_, ok := m.clearedFields[referral.FieldProcessedAt]
	return ok
}

// ResetProcessedAt resets all changes to the "processed_at" field.
func (m *ReferralMutation) ResetProcessedAt() {
	m.processed_at = nil
	delete(m.clearedFields, referral.FieldProcessedAt)
}

// SetReferrerID sets the "referrer" edge to the User entity by id.
func (m *ReferralMutation) SetReferrerID(id int64) {
	m.referrer = &id
}

// ClearReferrer clears the "referrer" edge to the User entity.
func (m *ReferralMutation) ClearReferrer() {
	m.clearedreferrer = true
}

// ReferrerCleared reports if the "referrer" edge to the User entity was cleared.
func (m *ReferralMutation) ReferrerCleared() bool {
	return m.clearedreferrer
}

// ReferrerID returns the "referrer" edge ID in the mutation.
func (m *ReferralMutation) ReferrerID() (id int64, exists bool) {
	if m.referrer != nil {
		return *m.referrer, true
	}
	return
}

// ReferrerIDs returns the "referrer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferrerID instead. It exists only for internal usage by the builders.
func (m *ReferralMutation) ReferrerIDs() (ids []int64) {
	if id := m.referrer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferrer resets all changes to the "referrer" edge.
func (m *ReferralMutation) ResetReferrer() {
	m.referrer = nil
	m.clearedreferrer = false
}

// SetCampaignID sets the "campaign" edge to the Campaign entity by id.
func (m *ReferralMutation) SetCampaignID(id int64) {
	m.campaign = &id
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *ReferralMutation) ClearCampaign() {
	m.clearedcampaign = true
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *ReferralMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignID returns the "campaign" edge ID in the mutation.
func (m *ReferralMutation) CampaignID() (id int64, exists bool) {
	if m.campaign != nil {
		return *m.campaign, true
	}
	return
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *ReferralMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *ReferralMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// Where appends a list predicates to the ReferralMutation builder.
func (m *ReferralMutation) Where(ps ...predicate.Referral) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReferralMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReferralMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Referral, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReferralMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReferralMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Referral).
func (m *ReferralMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReferralMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.status != nil {
		fields = append(fields, referral.FieldStatus)
	}
	if m.commission_amount != nil {
		fields = append(fields, referral.FieldCommissionAmount)
	}
	if m.created_at != nil {
		fields = append(fields, referral.FieldCreatedAt)
	}
	if m.processed_at != nil {
		fields = append(fields, referral.FieldProcessedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReferralMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case referral.FieldStatus:
		return m.Status()
	case referral.FieldCommissionAmount:
		return m.CommissionAmount()
	case referral.FieldCreatedAt:
		return m.CreatedAt()
	case referral.FieldProcessedAt:
		return m.ProcessedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReferralMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case referral.FieldStatus:
		return m.OldStatus(ctx)
	case referral.FieldCommissionAmount:
		return m.OldCommissionAmount(ctx)
	case referral.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case referral.FieldProcessedAt:
		return m.OldProcessedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Referral field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferralMutation) SetField(name string, value ent.Value) error {
	switch name {
	case referral.FieldStatus:
		v, ok := value.(referral.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case referral.FieldCommissionAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionAmount(v)
		return nil
	case referral.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case referral.FieldProcessedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Referral field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReferralMutation) AddedFields() []string {
	var fields []string
	if m.addcommission_amount != nil {
		fields = append(fields, referral.FieldCommissionAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReferralMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case referral.FieldCommissionAmount:
		return m.AddedCommissionAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferralMutation) AddField(name string, value ent.Value) error {
	switch name {
	case referral.FieldCommissionAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommissionAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Referral numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReferralMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(referral.FieldProcessedAt) {
		fields = append(fields, referral.FieldProcessedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReferralMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReferralMutation) ClearField(name string) error {
	switch name {
	case referral.FieldProcessedAt:
		m.ClearProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown Referral nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReferralMutation) ResetField(name string) error {
	switch name {
	case referral.FieldStatus:
		m.ResetStatus()
		return nil
	case referral.FieldCommissionAmount:
		m.ResetCommissionAmount()
		return nil
	case referral.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case referral.FieldProcessedAt:
		m.ResetProcessedAt()
		return nil
	}
	return fmt.Errorf("unknown Referral field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReferralMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.referrer != nil {
		edges = append(edges, referral.EdgeReferrer)
	}
	if m.campaign != nil {
		edges = append(edges, referral.EdgeCampaign)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReferralMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case referral.EdgeReferrer:
		if id := m.referrer; id != nil {
			return []ent.Value{*id}
		}
	case referral.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReferralMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReferralMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReferralMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreferrer {
		edges = append(edges, referral.EdgeReferrer)
	}
	if m.clearedcampaign {
		edges = append(edges, referral.EdgeCampaign)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReferralMutation) EdgeCleared(name string) bool {
	switch name {
	case referral.EdgeReferrer:
		return m.clearedreferrer
	case referral.EdgeCampaign:
		return m.clearedcampaign
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReferralMutation) ClearEdge(name string) error {
	switch name {
	case referral.EdgeReferrer:
		m.ClearReferrer()
		return nil
	case referral.EdgeCampaign:
		m.ClearCampaign()
		return nil
	}
	return fmt.Errorf("unknown Referral unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReferralMutation) ResetEdge(name string) error {
	switch name {
	case referral.EdgeReferrer:
		m.ResetReferrer()
		return nil
	case referral.EdgeCampaign:
		m.ResetCampaign()
		return nil
	}
	return fmt.Errorf("unknown Referral edge %s", name)
}

// TestMutation represents an operation that mutates the Test nodes in the graph.
type TestMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Test, error)
	predicates    []predicate.Test
}

var _ ent.Mutation = (*TestMutation)(nil)

// testOption allows management of the mutation configuration using functional options.
type testOption func(*TestMutation)

// newTestMutation creates new mutation for the Test entity.
func newTestMutation(c config, op Op, opts ...testOption) *TestMutation {
	m := &TestMutation{
		config:        c,
		op:            op,
		typ:           TypeTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestID sets the ID field of the mutation.
func withTestID(id int) testOption {
	return func(m *TestMutation) {
		var (
			err   error
			once  sync.Once
			value *Test
		)
		m.oldValue = func(ctx context.Context) (*Test, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest sets the old Test of the mutation.
func withTest(node *Test) testOption {
	return func(m *TestMutation) {
		m.oldValue = func(context.Context) (*Test, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the TestMutation builder.
func (m *TestMutation) Where(ps ...predicate.Test) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test).
func (m *TestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Test field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Test numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Test nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Test unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Test edge %s", name)
}

// TrackMutation represents an operation that mutates the Track nodes in the graph.
type TrackMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	ip_address          *string
	user_agent          *string
	device_fingerprint  *string
	referrer            *string
	_type               *track.Type
	status              *track.Status
	created_at          *time.Time
	is_unique_click     *bool
	additional_metadata *map[string]interface{}
	clearedFields       map[string]struct{}
	user                *int64
	cleareduser         bool
	campaign            *int64
	clearedcampaign     bool
	link                *int64
	clearedlink         bool
	done                bool
	oldValue            func(context.Context) (*Track, error)
	predicates          []predicate.Track
}

var _ ent.Mutation = (*TrackMutation)(nil)

// trackOption allows management of the mutation configuration using functional options.
type trackOption func(*TrackMutation)

// newTrackMutation creates new mutation for the Track entity.
func newTrackMutation(c config, op Op, opts ...trackOption) *TrackMutation {
	m := &TrackMutation{
		config:        c,
		op:            op,
		typ:           TypeTrack,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrackID sets the ID field of the mutation.
func withTrackID(id int64) trackOption {
	return func(m *TrackMutation) {
		var (
			err   error
			once  sync.Once
			value *Track
		)
		m.oldValue = func(ctx context.Context) (*Track, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Track.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrack sets the old Track of the mutation.
func withTrack(node *Track) trackOption {
	return func(m *TrackMutation) {
		m.oldValue = func(context.Context) (*Track, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Track entities.
func (m *TrackMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrackMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrackMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Track.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIPAddress sets the "ip_address" field.
func (m *TrackMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *TrackMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *TrackMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *TrackMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *TrackMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *TrackMutation) ResetUserAgent() {
	m.user_agent = nil
}

// SetDeviceFingerprint sets the "device_fingerprint" field.
func (m *TrackMutation) SetDeviceFingerprint(s string) {
	m.device_fingerprint = &s
}

// DeviceFingerprint returns the value of the "device_fingerprint" field in the mutation.
func (m *TrackMutation) DeviceFingerprint() (r string, exists bool) {
	v := m.device_fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceFingerprint returns the old "device_fingerprint" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldDeviceFingerprint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceFingerprint: %w", err)
	}
	return oldValue.DeviceFingerprint, nil
}

// ResetDeviceFingerprint resets all changes to the "device_fingerprint" field.
func (m *TrackMutation) ResetDeviceFingerprint() {
	m.device_fingerprint = nil
}

// SetReferrer sets the "referrer" field.
func (m *TrackMutation) SetReferrer(s string) {
	m.referrer = &s
}

// Referrer returns the value of the "referrer" field in the mutation.
func (m *TrackMutation) Referrer() (r string, exists bool) {
	v := m.referrer
	if v == nil {
		return
	}
	return *v, true
}

// OldReferrer returns the old "referrer" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldReferrer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferrer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferrer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferrer: %w", err)
	}
	return oldValue.Referrer, nil
}

// ClearReferrer clears the value of the "referrer" field.
func (m *TrackMutation) ClearReferrer() {
	m.referrer = nil
	m.clearedFields[track.FieldReferrer] = struct{}{}
}

// ReferrerCleared returns if the "referrer" field was cleared in this mutation.
func (m *TrackMutation) ReferrerCleared() bool {
	_, ok := m.clearedFields[track.FieldReferrer]
	return ok
}

// ResetReferrer resets all changes to the "referrer" field.
func (m *TrackMutation) ResetReferrer() {
	m.referrer = nil
	delete(m.clearedFields, track.FieldReferrer)
}

// SetType sets the "type" field.
func (m *TrackMutation) SetType(t track.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TrackMutation) GetType() (r track.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldType(ctx context.Context) (v track.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TrackMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *TrackMutation) SetStatus(t track.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TrackMutation) Status() (r track.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldStatus(ctx context.Context) (v track.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TrackMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIsUniqueClick sets the "is_unique_click" field.
func (m *TrackMutation) SetIsUniqueClick(b bool) {
	m.is_unique_click = &b
}

// IsUniqueClick returns the value of the "is_unique_click" field in the mutation.
func (m *TrackMutation) IsUniqueClick() (r bool, exists bool) {
	v := m.is_unique_click
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUniqueClick returns the old "is_unique_click" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldIsUniqueClick(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUniqueClick is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUniqueClick requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUniqueClick: %w", err)
	}
	return oldValue.IsUniqueClick, nil
}

// ResetIsUniqueClick resets all changes to the "is_unique_click" field.
func (m *TrackMutation) ResetIsUniqueClick() {
	m.is_unique_click = nil
}

// SetAdditionalMetadata sets the "additional_metadata" field.
func (m *TrackMutation) SetAdditionalMetadata(value map[string]interface{}) {
	m.additional_metadata = &value
}

// AdditionalMetadata returns the value of the "additional_metadata" field in the mutation.
func (m *TrackMutation) AdditionalMetadata() (r map[string]interface{}, exists bool) {
	v := m.additional_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalMetadata returns the old "additional_metadata" field's value of the Track entity.
// If the Track object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrackMutation) OldAdditionalMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalMetadata: %w", err)
	}
	return oldValue.AdditionalMetadata, nil
}

// ClearAdditionalMetadata clears the value of the "additional_metadata" field.
func (m *TrackMutation) ClearAdditionalMetadata() {
	m.additional_metadata = nil
	m.clearedFields[track.FieldAdditionalMetadata] = struct{}{}
}

// AdditionalMetadataCleared returns if the "additional_metadata" field was cleared in this mutation.
func (m *TrackMutation) AdditionalMetadataCleared() bool {
	_, ok := m.clearedFields[track.FieldAdditionalMetadata]
	return ok
}

// ResetAdditionalMetadata resets all changes to the "additional_metadata" field.
func (m *TrackMutation) ResetAdditionalMetadata() {
	m.additional_metadata = nil
	delete(m.clearedFields, track.FieldAdditionalMetadata)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *TrackMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *TrackMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TrackMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *TrackMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TrackMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TrackMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCampaignID sets the "campaign" edge to the Campaign entity by id.
func (m *TrackMutation) SetCampaignID(id int64) {
	m.campaign = &id
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *TrackMutation) ClearCampaign() {
	m.clearedcampaign = true
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *TrackMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignID returns the "campaign" edge ID in the mutation.
func (m *TrackMutation) CampaignID() (id int64, exists bool) {
	if m.campaign != nil {
		return *m.campaign, true
	}
	return
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *TrackMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *TrackMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// SetLinkID sets the "link" edge to the CampaignLink entity by id.
func (m *TrackMutation) SetLinkID(id int64) {
	m.link = &id
}

// ClearLink clears the "link" edge to the CampaignLink entity.
func (m *TrackMutation) ClearLink() {
	m.clearedlink = true
}

// LinkCleared reports if the "link" edge to the CampaignLink entity was cleared.
func (m *TrackMutation) LinkCleared() bool {
	return m.clearedlink
}

// LinkID returns the "link" edge ID in the mutation.
func (m *TrackMutation) LinkID() (id int64, exists bool) {
	if m.link != nil {
		return *m.link, true
	}
	return
}

// LinkIDs returns the "link" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkID instead. It exists only for internal usage by the builders.
func (m *TrackMutation) LinkIDs() (ids []int64) {
	if id := m.link; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLink resets all changes to the "link" edge.
func (m *TrackMutation) ResetLink() {
	m.link = nil
	m.clearedlink = false
}

// Where appends a list predicates to the TrackMutation builder.
func (m *TrackMutation) Where(ps ...predicate.Track) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Track, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Track).
func (m *TrackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrackMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.ip_address != nil {
		fields = append(fields, track.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, track.FieldUserAgent)
	}
	if m.device_fingerprint != nil {
		fields = append(fields, track.FieldDeviceFingerprint)
	}
	if m.referrer != nil {
		fields = append(fields, track.FieldReferrer)
	}
	if m._type != nil {
		fields = append(fields, track.FieldType)
	}
	if m.status != nil {
		fields = append(fields, track.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, track.FieldCreatedAt)
	}
	if m.is_unique_click != nil {
		fields = append(fields, track.FieldIsUniqueClick)
	}
	if m.additional_metadata != nil {
		fields = append(fields, track.FieldAdditionalMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case track.FieldIPAddress:
		return m.IPAddress()
	case track.FieldUserAgent:
		return m.UserAgent()
	case track.FieldDeviceFingerprint:
		return m.DeviceFingerprint()
	case track.FieldReferrer:
		return m.Referrer()
	case track.FieldType:
		return m.GetType()
	case track.FieldStatus:
		return m.Status()
	case track.FieldCreatedAt:
		return m.CreatedAt()
	case track.FieldIsUniqueClick:
		return m.IsUniqueClick()
	case track.FieldAdditionalMetadata:
		return m.AdditionalMetadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case track.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case track.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case track.FieldDeviceFingerprint:
		return m.OldDeviceFingerprint(ctx)
	case track.FieldReferrer:
		return m.OldReferrer(ctx)
	case track.FieldType:
		return m.OldType(ctx)
	case track.FieldStatus:
		return m.OldStatus(ctx)
	case track.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case track.FieldIsUniqueClick:
		return m.OldIsUniqueClick(ctx)
	case track.FieldAdditionalMetadata:
		return m.OldAdditionalMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Track field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case track.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case track.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case track.FieldDeviceFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceFingerprint(v)
		return nil
	case track.FieldReferrer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferrer(v)
		return nil
	case track.FieldType:
		v, ok := value.(track.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case track.FieldStatus:
		v, ok := value.(track.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case track.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case track.FieldIsUniqueClick:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUniqueClick(v)
		return nil
	case track.FieldAdditionalMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Track field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Track numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(track.FieldReferrer) {
		fields = append(fields, track.FieldReferrer)
	}
	if m.FieldCleared(track.FieldAdditionalMetadata) {
		fields = append(fields, track.FieldAdditionalMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrackMutation) ClearField(name string) error {
	switch name {
	case track.FieldReferrer:
		m.ClearReferrer()
		return nil
	case track.FieldAdditionalMetadata:
		m.ClearAdditionalMetadata()
		return nil
	}
	return fmt.Errorf("unknown Track nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrackMutation) ResetField(name string) error {
	switch name {
	case track.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case track.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case track.FieldDeviceFingerprint:
		m.ResetDeviceFingerprint()
		return nil
	case track.FieldReferrer:
		m.ResetReferrer()
		return nil
	case track.FieldType:
		m.ResetType()
		return nil
	case track.FieldStatus:
		m.ResetStatus()
		return nil
	case track.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case track.FieldIsUniqueClick:
		m.ResetIsUniqueClick()
		return nil
	case track.FieldAdditionalMetadata:
		m.ResetAdditionalMetadata()
		return nil
	}
	return fmt.Errorf("unknown Track field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrackMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, track.EdgeUser)
	}
	if m.campaign != nil {
		edges = append(edges, track.EdgeCampaign)
	}
	if m.link != nil {
		edges = append(edges, track.EdgeLink)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case track.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case track.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	case track.EdgeLink:
		if id := m.link; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, track.EdgeUser)
	}
	if m.clearedcampaign {
		edges = append(edges, track.EdgeCampaign)
	}
	if m.clearedlink {
		edges = append(edges, track.EdgeLink)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrackMutation) EdgeCleared(name string) bool {
	switch name {
	case track.EdgeUser:
		return m.cleareduser
	case track.EdgeCampaign:
		return m.clearedcampaign
	case track.EdgeLink:
		return m.clearedlink
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrackMutation) ClearEdge(name string) error {
	switch name {
	case track.EdgeUser:
		m.ClearUser()
		return nil
	case track.EdgeCampaign:
		m.ClearCampaign()
		return nil
	case track.EdgeLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Track unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrackMutation) ResetEdge(name string) error {
	switch name {
	case track.EdgeUser:
		m.ResetUser()
		return nil
	case track.EdgeCampaign:
		m.ResetCampaign()
		return nil
	case track.EdgeLink:
		m.ResetLink()
		return nil
	}
	return fmt.Errorf("unknown Track edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	username               *string
	email                  *string
	password_hash          *string
	first_name             *string
	last_name              *string
	role                   *user.Role
	created_at             *time.Time
	updated_at             *time.Time
	is_active              *bool
	last_login             *time.Time
	reset_token            *string
	reset_token_expires_at *time.Time
	clearedFields          map[string]struct{}
	campaigns              map[int64]struct{}
	removedcampaigns       map[int64]struct{}
	clearedcampaigns       bool
	referrals              map[int64]struct{}
	removedreferrals       map[int64]struct{}
	clearedreferrals       bool
	tracks                 map[int64]struct{}
	removedtracks          map[int64]struct{}
	clearedtracks          bool
	payouts                map[string]struct{}
	removedpayouts         map[string]struct{}
	clearedpayouts         bool
	posts                  map[string]struct{}
	removedposts           map[string]struct{}
	clearedposts           bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetResetToken sets the "reset_token" field.
func (m *UserMutation) SetResetToken(s string) {
	m.reset_token = &s
}

// ResetToken returns the value of the "reset_token" field in the mutation.
func (m *UserMutation) ResetToken() (r string, exists bool) {
	v := m.reset_token
	if v == nil {
		return
	}
	return *v, true
}

// OldResetToken returns the old "reset_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldResetToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetToken: %w", err)
	}
	return oldValue.ResetToken, nil
}

// ClearResetToken clears the value of the "reset_token" field.
func (m *UserMutation) ClearResetToken() {
	m.reset_token = nil
	m.clearedFields[user.FieldResetToken] = struct{}{}
}

// ResetTokenCleared returns if the "reset_token" field was cleared in this mutation.
func (m *UserMutation) ResetTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldResetToken]
	return ok
}

// ResetResetToken resets all changes to the "reset_token" field.
func (m *UserMutation) ResetResetToken() {
	m.reset_token = nil
	delete(m.clearedFields, user.FieldResetToken)
}

// SetResetTokenExpiresAt sets the "reset_token_expires_at" field.
func (m *UserMutation) SetResetTokenExpiresAt(t time.Time) {
	m.reset_token_expires_at = &t
}

// ResetTokenExpiresAt returns the value of the "reset_token_expires_at" field in the mutation.
func (m *UserMutation) ResetTokenExpiresAt() (r time.Time, exists bool) {
	v := m.reset_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTokenExpiresAt returns the old "reset_token_expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldResetTokenExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTokenExpiresAt: %w", err)
	}
	return oldValue.ResetTokenExpiresAt, nil
}

// ClearResetTokenExpiresAt clears the value of the "reset_token_expires_at" field.
func (m *UserMutation) ClearResetTokenExpiresAt() {
	m.reset_token_expires_at = nil
	m.clearedFields[user.FieldResetTokenExpiresAt] = struct{}{}
}

// ResetTokenExpiresAtCleared returns if the "reset_token_expires_at" field was cleared in this mutation.
func (m *UserMutation) ResetTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldResetTokenExpiresAt]
	return ok
}

// ResetResetTokenExpiresAt resets all changes to the "reset_token_expires_at" field.
func (m *UserMutation) ResetResetTokenExpiresAt() {
	m.reset_token_expires_at = nil
	delete(m.clearedFields, user.FieldResetTokenExpiresAt)
}

// AddCampaignIDs adds the "campaigns" edge to the Campaign entity by ids.
func (m *UserMutation) AddCampaignIDs(ids ...int64) {
	if m.campaigns == nil {
		m.campaigns = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaigns[ids[i]] = struct{}{}
	}
}

// ClearCampaigns clears the "campaigns" edge to the Campaign entity.
func (m *UserMutation) ClearCampaigns() {
	m.clearedcampaigns = true
}

// CampaignsCleared reports if the "campaigns" edge to the Campaign entity was cleared.
func (m *UserMutation) CampaignsCleared() bool {
	return m.clearedcampaigns
}

// RemoveCampaignIDs removes the "campaigns" edge to the Campaign entity by IDs.
func (m *UserMutation) RemoveCampaignIDs(ids ...int64) {
	if m.removedcampaigns == nil {
		m.removedcampaigns = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaigns, ids[i])
		m.removedcampaigns[ids[i]] = struct{}{}
	}
}

// RemovedCampaigns returns the removed IDs of the "campaigns" edge to the Campaign entity.
func (m *UserMutation) RemovedCampaignsIDs() (ids []int64) {
	for id := range m.removedcampaigns {
		ids = append(ids, id)
	}
	return
}

// CampaignsIDs returns the "campaigns" edge IDs in the mutation.
func (m *UserMutation) CampaignsIDs() (ids []int64) {
	for id := range m.campaigns {
		ids = append(ids, id)
	}
	return
}

// ResetCampaigns resets all changes to the "campaigns" edge.
func (m *UserMutation) ResetCampaigns() {
	m.campaigns = nil
	m.clearedcampaigns = false
	m.removedcampaigns = nil
}

// AddReferralIDs adds the "referrals" edge to the Referral entity by ids.
func (m *UserMutation) AddReferralIDs(ids ...int64) {
	if m.referrals == nil {
		m.referrals = make(map[int64]struct{})
	}
	for i := range ids {
		m.referrals[ids[i]] = struct{}{}
	}
}

// ClearReferrals clears the "referrals" edge to the Referral entity.
func (m *UserMutation) ClearReferrals() {
	m.clearedreferrals = true
}

// ReferralsCleared reports if the "referrals" edge to the Referral entity was cleared.
func (m *UserMutation) ReferralsCleared() bool {
	return m.clearedreferrals
}

// RemoveReferralIDs removes the "referrals" edge to the Referral entity by IDs.
func (m *UserMutation) RemoveReferralIDs(ids ...int64) {
	if m.removedreferrals == nil {
		m.removedreferrals = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.referrals, ids[i])
		m.removedreferrals[ids[i]] = struct{}{}
	}
}

// RemovedReferrals returns the removed IDs of the "referrals" edge to the Referral entity.
func (m *UserMutation) RemovedReferralsIDs() (ids []int64) {
	for id := range m.removedreferrals {
		ids = append(ids, id)
	}
	return
}

// ReferralsIDs returns the "referrals" edge IDs in the mutation.
func (m *UserMutation) ReferralsIDs() (ids []int64) {
	for id := range m.referrals {
		ids = append(ids, id)
	}
	return
}

// ResetReferrals resets all changes to the "referrals" edge.
func (m *UserMutation) ResetReferrals() {
	m.referrals = nil
	m.clearedreferrals = false
	m.removedreferrals = nil
}

// AddTrackIDs adds the "tracks" edge to the Track entity by ids.
func (m *UserMutation) AddTrackIDs(ids ...int64) {
	if m.tracks == nil {
		m.tracks = make(map[int64]struct{})
	}
	for i := range ids {
		m.tracks[ids[i]] = struct{}{}
	}
}

// ClearTracks clears the "tracks" edge to the Track entity.
func (m *UserMutation) ClearTracks() {
	m.clearedtracks = true
}

// TracksCleared reports if the "tracks" edge to the Track entity was cleared.
func (m *UserMutation) TracksCleared() bool {
	return m.clearedtracks
}

// RemoveTrackIDs removes the "tracks" edge to the Track entity by IDs.
func (m *UserMutation) RemoveTrackIDs(ids ...int64) {
	if m.removedtracks == nil {
		m.removedtracks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tracks, ids[i])
		m.removedtracks[ids[i]] = struct{}{}
	}
}

// RemovedTracks returns the removed IDs of the "tracks" edge to the Track entity.
func (m *UserMutation) RemovedTracksIDs() (ids []int64) {
	for id := range m.removedtracks {
		ids = append(ids, id)
	}
	return
}

// TracksIDs returns the "tracks" edge IDs in the mutation.
func (m *UserMutation) TracksIDs() (ids []int64) {
	for id := range m.tracks {
		ids = append(ids, id)
	}
	return
}

// ResetTracks resets all changes to the "tracks" edge.
func (m *UserMutation) ResetTracks() {
	m.tracks = nil
	m.clearedtracks = false
	m.removedtracks = nil
}

// AddPayoutIDs adds the "payouts" edge to the Payout entity by ids.
func (m *UserMutation) AddPayoutIDs(ids ...string) {
	if m.payouts == nil {
		m.payouts = make(map[string]struct{})
	}
	for i := range ids {
		m.payouts[ids[i]] = struct{}{}
	}
}

// ClearPayouts clears the "payouts" edge to the Payout entity.
func (m *UserMutation) ClearPayouts() {
	m.clearedpayouts = true
}

// PayoutsCleared reports if the "payouts" edge to the Payout entity was cleared.
func (m *UserMutation) PayoutsCleared() bool {
	return m.clearedpayouts
}

// RemovePayoutIDs removes the "payouts" edge to the Payout entity by IDs.
func (m *UserMutation) RemovePayoutIDs(ids ...string) {
	if m.removedpayouts == nil {
		m.removedpayouts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.payouts, ids[i])
		m.removedpayouts[ids[i]] = struct{}{}
	}
}

// RemovedPayouts returns the removed IDs of the "payouts" edge to the Payout entity.
func (m *UserMutation) RemovedPayoutsIDs() (ids []string) {
	for id := range m.removedpayouts {
		ids = append(ids, id)
	}
	return
}

// PayoutsIDs returns the "payouts" edge IDs in the mutation.
func (m *UserMutation) PayoutsIDs() (ids []string) {
	for id := range m.payouts {
		ids = append(ids, id)
	}
	return
}

// ResetPayouts resets all changes to the "payouts" edge.
func (m *UserMutation) ResetPayouts() {
	m.payouts = nil
	m.clearedpayouts = false
	m.removedpayouts = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.reset_token != nil {
		fields = append(fields, user.FieldResetToken)
	}
	if m.reset_token_expires_at != nil {
		fields = append(fields, user.FieldResetTokenExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldResetToken:
		return m.ResetToken()
	case user.FieldResetTokenExpiresAt:
		return m.ResetTokenExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldResetToken:
		return m.OldResetToken(ctx)
	case user.FieldResetTokenExpiresAt:
		return m.OldResetTokenExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldResetToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetToken(v)
		return nil
	case user.FieldResetTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTokenExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.FieldCleared(user.FieldResetToken) {
		fields = append(fields, user.FieldResetToken)
	}
	if m.FieldCleared(user.FieldResetTokenExpiresAt) {
		fields = append(fields, user.FieldResetTokenExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	case user.FieldResetToken:
		m.ClearResetToken()
		return nil
	case user.FieldResetTokenExpiresAt:
		m.ClearResetTokenExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldResetToken:
		m.ResetResetToken()
		return nil
	case user.FieldResetTokenExpiresAt:
		m.ResetResetTokenExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.campaigns != nil {
		edges = append(edges, user.EdgeCampaigns)
	}
	if m.referrals != nil {
		edges = append(edges, user.EdgeReferrals)
	}
	if m.tracks != nil {
		edges = append(edges, user.EdgeTracks)
	}
	if m.payouts != nil {
		edges = append(edges, user.EdgePayouts)
	}
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.campaigns))
		for id := range m.campaigns {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReferrals:
		ids := make([]ent.Value, 0, len(m.referrals))
		for id := range m.referrals {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTracks:
		ids := make([]ent.Value, 0, len(m.tracks))
		for id := range m.tracks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayouts:
		ids := make([]ent.Value, 0, len(m.payouts))
		for id := range m.payouts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcampaigns != nil {
		edges = append(edges, user.EdgeCampaigns)
	}
	if m.removedreferrals != nil {
		edges = append(edges, user.EdgeReferrals)
	}
	if m.removedtracks != nil {
		edges = append(edges, user.EdgeTracks)
	}
	if m.removedpayouts != nil {
		edges = append(edges, user.EdgePayouts)
	}
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.removedcampaigns))
		for id := range m.removedcampaigns {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReferrals:
		ids := make([]ent.Value, 0, len(m.removedreferrals))
		for id := range m.removedreferrals {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTracks:
		ids := make([]ent.Value, 0, len(m.removedtracks))
		for id := range m.removedtracks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayouts:
		ids := make([]ent.Value, 0, len(m.removedpayouts))
		for id := range m.removedpayouts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcampaigns {
		edges = append(edges, user.EdgeCampaigns)
	}
	if m.clearedreferrals {
		edges = append(edges, user.EdgeReferrals)
	}
	if m.clearedtracks {
		edges = append(edges, user.EdgeTracks)
	}
	if m.clearedpayouts {
		edges = append(edges, user.EdgePayouts)
	}
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCampaigns:
		return m.clearedcampaigns
	case user.EdgeReferrals:
		return m.clearedreferrals
	case user.EdgeTracks:
		return m.clearedtracks
	case user.EdgePayouts:
		return m.clearedpayouts
	case user.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCampaigns:
		m.ResetCampaigns()
		return nil
	case user.EdgeReferrals:
		m.ResetReferrals()
		return nil
	case user.EdgeTracks:
		m.ResetTracks()
		return nil
	case user.EdgePayouts:
		m.ResetPayouts()
		return nil
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
