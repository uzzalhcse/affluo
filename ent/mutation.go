// Code generated by ent, DO NOT EDIT.

package ent

import (
	"affluo/ent/affiliate"
	"affluo/ent/banner"
	"affluo/ent/bannercreative"
	"affluo/ent/bannerstats"
	"affluo/ent/campaign"
	"affluo/ent/campaignlink"
	"affluo/ent/commissionplan"
	"affluo/ent/creative"
	"affluo/ent/gigtracking"
	"affluo/ent/lead"
	"affluo/ent/payout"
	"affluo/ent/predicate"
	"affluo/ent/schema"
	"affluo/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAffiliate      = "Affiliate"
	TypeBanner         = "Banner"
	TypeBannerCreative = "BannerCreative"
	TypeBannerStats    = "BannerStats"
	TypeCampaign       = "Campaign"
	TypeCampaignLink   = "CampaignLink"
	TypeCommissionPlan = "CommissionPlan"
	TypeCreative       = "Creative"
	TypeGigTracking    = "GigTracking"
	TypeLead           = "Lead"
	TypePayout         = "Payout"
	TypeTest           = "Test"
	TypeUser           = "User"
)

// AffiliateMutation represents an operation that mutates the Affiliate nodes in the graph.
type AffiliateMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	tracking_code          *string
	affiliate_user_id      *string
	source                 *affiliate.Source
	registration_date      *time.Time
	first_transaction_date *time.Time
	commission             *float64
	addcommission          *float64
	date                   *time.Time
	clearedFields          map[string]struct{}
	user                   *int64
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*Affiliate, error)
	predicates             []predicate.Affiliate
}

var _ ent.Mutation = (*AffiliateMutation)(nil)

// affiliateOption allows management of the mutation configuration using functional options.
type affiliateOption func(*AffiliateMutation)

// newAffiliateMutation creates new mutation for the Affiliate entity.
func newAffiliateMutation(c config, op Op, opts ...affiliateOption) *AffiliateMutation {
	m := &AffiliateMutation{
		config:        c,
		op:            op,
		typ:           TypeAffiliate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAffiliateID sets the ID field of the mutation.
func withAffiliateID(id int64) affiliateOption {
	return func(m *AffiliateMutation) {
		var (
			err   error
			once  sync.Once
			value *Affiliate
		)
		m.oldValue = func(ctx context.Context) (*Affiliate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Affiliate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAffiliate sets the old Affiliate of the mutation.
func withAffiliate(node *Affiliate) affiliateOption {
	return func(m *AffiliateMutation) {
		m.oldValue = func(context.Context) (*Affiliate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AffiliateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AffiliateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Affiliate entities.
func (m *AffiliateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AffiliateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AffiliateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Affiliate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTrackingCode sets the "tracking_code" field.
func (m *AffiliateMutation) SetTrackingCode(s string) {
	m.tracking_code = &s
}

// TrackingCode returns the value of the "tracking_code" field in the mutation.
func (m *AffiliateMutation) TrackingCode() (r string, exists bool) {
	v := m.tracking_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingCode returns the old "tracking_code" field's value of the Affiliate entity.
// If the Affiliate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AffiliateMutation) OldTrackingCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingCode: %w", err)
	}
	return oldValue.TrackingCode, nil
}

// ClearTrackingCode clears the value of the "tracking_code" field.
func (m *AffiliateMutation) ClearTrackingCode() {
	m.tracking_code = nil
	m.clearedFields[affiliate.FieldTrackingCode] = struct{}{}
}

// TrackingCodeCleared returns if the "tracking_code" field was cleared in this mutation.
func (m *AffiliateMutation) TrackingCodeCleared() bool {
	_, ok := m.clearedFields[affiliate.FieldTrackingCode]
	return ok
}

// ResetTrackingCode resets all changes to the "tracking_code" field.
func (m *AffiliateMutation) ResetTrackingCode() {
	m.tracking_code = nil
	delete(m.clearedFields, affiliate.FieldTrackingCode)
}

// SetAffiliateUserID sets the "affiliate_user_id" field.
func (m *AffiliateMutation) SetAffiliateUserID(s string) {
	m.affiliate_user_id = &s
}

// AffiliateUserID returns the value of the "affiliate_user_id" field in the mutation.
func (m *AffiliateMutation) AffiliateUserID() (r string, exists bool) {
	v := m.affiliate_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliateUserID returns the old "affiliate_user_id" field's value of the Affiliate entity.
// If the Affiliate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AffiliateMutation) OldAffiliateUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliateUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliateUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliateUserID: %w", err)
	}
	return oldValue.AffiliateUserID, nil
}

// ResetAffiliateUserID resets all changes to the "affiliate_user_id" field.
func (m *AffiliateMutation) ResetAffiliateUserID() {
	m.affiliate_user_id = nil
}

// SetSource sets the "source" field.
func (m *AffiliateMutation) SetSource(a affiliate.Source) {
	m.source = &a
}

// Source returns the value of the "source" field in the mutation.
func (m *AffiliateMutation) Source() (r affiliate.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Affiliate entity.
// If the Affiliate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AffiliateMutation) OldSource(ctx context.Context) (v affiliate.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AffiliateMutation) ResetSource() {
	m.source = nil
}

// SetRegistrationDate sets the "registration_date" field.
func (m *AffiliateMutation) SetRegistrationDate(t time.Time) {
	m.registration_date = &t
}

// RegistrationDate returns the value of the "registration_date" field in the mutation.
func (m *AffiliateMutation) RegistrationDate() (r time.Time, exists bool) {
	v := m.registration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationDate returns the old "registration_date" field's value of the Affiliate entity.
// If the Affiliate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AffiliateMutation) OldRegistrationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationDate: %w", err)
	}
	return oldValue.RegistrationDate, nil
}

// ResetRegistrationDate resets all changes to the "registration_date" field.
func (m *AffiliateMutation) ResetRegistrationDate() {
	m.registration_date = nil
}

// SetFirstTransactionDate sets the "first_transaction_date" field.
func (m *AffiliateMutation) SetFirstTransactionDate(t time.Time) {
	m.first_transaction_date = &t
}

// FirstTransactionDate returns the value of the "first_transaction_date" field in the mutation.
func (m *AffiliateMutation) FirstTransactionDate() (r time.Time, exists bool) {
	v := m.first_transaction_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstTransactionDate returns the old "first_transaction_date" field's value of the Affiliate entity.
// If the Affiliate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AffiliateMutation) OldFirstTransactionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstTransactionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstTransactionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstTransactionDate: %w", err)
	}
	return oldValue.FirstTransactionDate, nil
}

// ClearFirstTransactionDate clears the value of the "first_transaction_date" field.
func (m *AffiliateMutation) ClearFirstTransactionDate() {
	m.first_transaction_date = nil
	m.clearedFields[affiliate.FieldFirstTransactionDate] = struct{}{}
}

// FirstTransactionDateCleared returns if the "first_transaction_date" field was cleared in this mutation.
func (m *AffiliateMutation) FirstTransactionDateCleared() bool {
	_, ok := m.clearedFields[affiliate.FieldFirstTransactionDate]
	return ok
}

// ResetFirstTransactionDate resets all changes to the "first_transaction_date" field.
func (m *AffiliateMutation) ResetFirstTransactionDate() {
	m.first_transaction_date = nil
	delete(m.clearedFields, affiliate.FieldFirstTransactionDate)
}

// SetCommission sets the "commission" field.
func (m *AffiliateMutation) SetCommission(f float64) {
	m.commission = &f
	m.addcommission = nil
}

// Commission returns the value of the "commission" field in the mutation.
func (m *AffiliateMutation) Commission() (r float64, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the Affiliate entity.
// If the Affiliate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AffiliateMutation) OldCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// AddCommission adds f to the "commission" field.
func (m *AffiliateMutation) AddCommission(f float64) {
	if m.addcommission != nil {
		*m.addcommission += f
	} else {
		m.addcommission = &f
	}
}

// AddedCommission returns the value that was added to the "commission" field in this mutation.
func (m *AffiliateMutation) AddedCommission() (r float64, exists bool) {
	v := m.addcommission
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommission resets all changes to the "commission" field.
func (m *AffiliateMutation) ResetCommission() {
	m.commission = nil
	m.addcommission = nil
}

// SetDate sets the "date" field.
func (m *AffiliateMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AffiliateMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Affiliate entity.
// If the Affiliate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AffiliateMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AffiliateMutation) ResetDate() {
	m.date = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AffiliateMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AffiliateMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AffiliateMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AffiliateMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AffiliateMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AffiliateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AffiliateMutation builder.
func (m *AffiliateMutation) Where(ps ...predicate.Affiliate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AffiliateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AffiliateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Affiliate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AffiliateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AffiliateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Affiliate).
func (m *AffiliateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AffiliateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tracking_code != nil {
		fields = append(fields, affiliate.FieldTrackingCode)
	}
	if m.affiliate_user_id != nil {
		fields = append(fields, affiliate.FieldAffiliateUserID)
	}
	if m.source != nil {
		fields = append(fields, affiliate.FieldSource)
	}
	if m.registration_date != nil {
		fields = append(fields, affiliate.FieldRegistrationDate)
	}
	if m.first_transaction_date != nil {
		fields = append(fields, affiliate.FieldFirstTransactionDate)
	}
	if m.commission != nil {
		fields = append(fields, affiliate.FieldCommission)
	}
	if m.date != nil {
		fields = append(fields, affiliate.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AffiliateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case affiliate.FieldTrackingCode:
		return m.TrackingCode()
	case affiliate.FieldAffiliateUserID:
		return m.AffiliateUserID()
	case affiliate.FieldSource:
		return m.Source()
	case affiliate.FieldRegistrationDate:
		return m.RegistrationDate()
	case affiliate.FieldFirstTransactionDate:
		return m.FirstTransactionDate()
	case affiliate.FieldCommission:
		return m.Commission()
	case affiliate.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AffiliateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case affiliate.FieldTrackingCode:
		return m.OldTrackingCode(ctx)
	case affiliate.FieldAffiliateUserID:
		return m.OldAffiliateUserID(ctx)
	case affiliate.FieldSource:
		return m.OldSource(ctx)
	case affiliate.FieldRegistrationDate:
		return m.OldRegistrationDate(ctx)
	case affiliate.FieldFirstTransactionDate:
		return m.OldFirstTransactionDate(ctx)
	case affiliate.FieldCommission:
		return m.OldCommission(ctx)
	case affiliate.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown Affiliate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AffiliateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case affiliate.FieldTrackingCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingCode(v)
		return nil
	case affiliate.FieldAffiliateUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliateUserID(v)
		return nil
	case affiliate.FieldSource:
		v, ok := value.(affiliate.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case affiliate.FieldRegistrationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationDate(v)
		return nil
	case affiliate.FieldFirstTransactionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstTransactionDate(v)
		return nil
	case affiliate.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	case affiliate.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown Affiliate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AffiliateMutation) AddedFields() []string {
	var fields []string
	if m.addcommission != nil {
		fields = append(fields, affiliate.FieldCommission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AffiliateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case affiliate.FieldCommission:
		return m.AddedCommission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AffiliateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case affiliate.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Affiliate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AffiliateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(affiliate.FieldTrackingCode) {
		fields = append(fields, affiliate.FieldTrackingCode)
	}
	if m.FieldCleared(affiliate.FieldFirstTransactionDate) {
		fields = append(fields, affiliate.FieldFirstTransactionDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AffiliateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AffiliateMutation) ClearField(name string) error {
	switch name {
	case affiliate.FieldTrackingCode:
		m.ClearTrackingCode()
		return nil
	case affiliate.FieldFirstTransactionDate:
		m.ClearFirstTransactionDate()
		return nil
	}
	return fmt.Errorf("unknown Affiliate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AffiliateMutation) ResetField(name string) error {
	switch name {
	case affiliate.FieldTrackingCode:
		m.ResetTrackingCode()
		return nil
	case affiliate.FieldAffiliateUserID:
		m.ResetAffiliateUserID()
		return nil
	case affiliate.FieldSource:
		m.ResetSource()
		return nil
	case affiliate.FieldRegistrationDate:
		m.ResetRegistrationDate()
		return nil
	case affiliate.FieldFirstTransactionDate:
		m.ResetFirstTransactionDate()
		return nil
	case affiliate.FieldCommission:
		m.ResetCommission()
		return nil
	case affiliate.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown Affiliate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AffiliateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, affiliate.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AffiliateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case affiliate.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AffiliateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AffiliateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AffiliateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, affiliate.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AffiliateMutation) EdgeCleared(name string) bool {
	switch name {
	case affiliate.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AffiliateMutation) ClearEdge(name string) error {
	switch name {
	case affiliate.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Affiliate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AffiliateMutation) ResetEdge(name string) error {
	switch name {
	case affiliate.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Affiliate edge %s", name)
}

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	description             *string
	_type                   *banner.Type
	click_url               *string
	size                    *string
	status                  *banner.Status
	allowed_countries       *[]string
	appendallowed_countries []string
	weight                  *int
	addweight               *int
	smart_weight            *float64
	addsmart_weight         *float64
	last_impression         *time.Time
	start_date              *time.Time
	end_date                *time.Time
	allowed_devices         *[]string
	appendallowed_devices   []string
	allowed_browsers        *[]string
	appendallowed_browsers  []string
	allowed_os              *[]string
	appendallowed_os        []string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	campaigns               map[int64]struct{}
	removedcampaigns        map[int64]struct{}
	clearedcampaigns        bool
	creatives               map[int64]struct{}
	removedcreatives        map[int64]struct{}
	clearedcreatives        bool
	stats                   map[int64]struct{}
	removedstats            map[int64]struct{}
	clearedstats            bool
	leads                   map[int64]struct{}
	removedleads            map[int64]struct{}
	clearedleads            bool
	banner_creatives        map[int]struct{}
	removedbanner_creatives map[int]struct{}
	clearedbanner_creatives bool
	done                    bool
	oldValue                func(context.Context) (*Banner, error)
	predicates              []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id int64) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Banner entities.
func (m *BannerMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Banner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BannerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BannerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BannerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BannerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[banner.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BannerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[banner.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BannerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, banner.FieldDescription)
}

// SetType sets the "type" field.
func (m *BannerMutation) SetType(b banner.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BannerMutation) GetType() (r banner.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldType(ctx context.Context) (v banner.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BannerMutation) ResetType() {
	m._type = nil
}

// SetClickURL sets the "click_url" field.
func (m *BannerMutation) SetClickURL(s string) {
	m.click_url = &s
}

// ClickURL returns the value of the "click_url" field in the mutation.
func (m *BannerMutation) ClickURL() (r string, exists bool) {
	v := m.click_url
	if v == nil {
		return
	}
	return *v, true
}

// OldClickURL returns the old "click_url" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldClickURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickURL: %w", err)
	}
	return oldValue.ClickURL, nil
}

// ClearClickURL clears the value of the "click_url" field.
func (m *BannerMutation) ClearClickURL() {
	m.click_url = nil
	m.clearedFields[banner.FieldClickURL] = struct{}{}
}

// ClickURLCleared returns if the "click_url" field was cleared in this mutation.
func (m *BannerMutation) ClickURLCleared() bool {
	_, ok := m.clearedFields[banner.FieldClickURL]
	return ok
}

// ResetClickURL resets all changes to the "click_url" field.
func (m *BannerMutation) ResetClickURL() {
	m.click_url = nil
	delete(m.clearedFields, banner.FieldClickURL)
}

// SetSize sets the "size" field.
func (m *BannerMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *BannerMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *BannerMutation) ResetSize() {
	m.size = nil
}

// SetStatus sets the "status" field.
func (m *BannerMutation) SetStatus(b banner.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BannerMutation) Status() (r banner.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldStatus(ctx context.Context) (v banner.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BannerMutation) ResetStatus() {
	m.status = nil
}

// SetAllowedCountries sets the "allowed_countries" field.
func (m *BannerMutation) SetAllowedCountries(s []string) {
	m.allowed_countries = &s
	m.appendallowed_countries = nil
}

// AllowedCountries returns the value of the "allowed_countries" field in the mutation.
func (m *BannerMutation) AllowedCountries() (r []string, exists bool) {
	v := m.allowed_countries
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedCountries returns the old "allowed_countries" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedCountries(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedCountries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedCountries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedCountries: %w", err)
	}
	return oldValue.AllowedCountries, nil
}

// AppendAllowedCountries adds s to the "allowed_countries" field.
func (m *BannerMutation) AppendAllowedCountries(s []string) {
	m.appendallowed_countries = append(m.appendallowed_countries, s...)
}

// AppendedAllowedCountries returns the list of values that were appended to the "allowed_countries" field in this mutation.
func (m *BannerMutation) AppendedAllowedCountries() ([]string, bool) {
	if len(m.appendallowed_countries) == 0 {
		return nil, false
	}
	return m.appendallowed_countries, true
}

// ClearAllowedCountries clears the value of the "allowed_countries" field.
func (m *BannerMutation) ClearAllowedCountries() {
	m.allowed_countries = nil
	m.appendallowed_countries = nil
	m.clearedFields[banner.FieldAllowedCountries] = struct{}{}
}

// AllowedCountriesCleared returns if the "allowed_countries" field was cleared in this mutation.
func (m *BannerMutation) AllowedCountriesCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedCountries]
	return ok
}

// ResetAllowedCountries resets all changes to the "allowed_countries" field.
func (m *BannerMutation) ResetAllowedCountries() {
	m.allowed_countries = nil
	m.appendallowed_countries = nil
	delete(m.clearedFields, banner.FieldAllowedCountries)
}

// SetWeight sets the "weight" field.
func (m *BannerMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *BannerMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *BannerMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *BannerMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *BannerMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetSmartWeight sets the "smart_weight" field.
func (m *BannerMutation) SetSmartWeight(f float64) {
	m.smart_weight = &f
	m.addsmart_weight = nil
}

// SmartWeight returns the value of the "smart_weight" field in the mutation.
func (m *BannerMutation) SmartWeight() (r float64, exists bool) {
	v := m.smart_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldSmartWeight returns the old "smart_weight" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldSmartWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSmartWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSmartWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmartWeight: %w", err)
	}
	return oldValue.SmartWeight, nil
}

// AddSmartWeight adds f to the "smart_weight" field.
func (m *BannerMutation) AddSmartWeight(f float64) {
	if m.addsmart_weight != nil {
		*m.addsmart_weight += f
	} else {
		m.addsmart_weight = &f
	}
}

// AddedSmartWeight returns the value that was added to the "smart_weight" field in this mutation.
func (m *BannerMutation) AddedSmartWeight() (r float64, exists bool) {
	v := m.addsmart_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearSmartWeight clears the value of the "smart_weight" field.
func (m *BannerMutation) ClearSmartWeight() {
	m.smart_weight = nil
	m.addsmart_weight = nil
	m.clearedFields[banner.FieldSmartWeight] = struct{}{}
}

// SmartWeightCleared returns if the "smart_weight" field was cleared in this mutation.
func (m *BannerMutation) SmartWeightCleared() bool {
	_, ok := m.clearedFields[banner.FieldSmartWeight]
	return ok
}

// ResetSmartWeight resets all changes to the "smart_weight" field.
func (m *BannerMutation) ResetSmartWeight() {
	m.smart_weight = nil
	m.addsmart_weight = nil
	delete(m.clearedFields, banner.FieldSmartWeight)
}

// SetLastImpression sets the "last_impression" field.
func (m *BannerMutation) SetLastImpression(t time.Time) {
	m.last_impression = &t
}

// LastImpression returns the value of the "last_impression" field in the mutation.
func (m *BannerMutation) LastImpression() (r time.Time, exists bool) {
	v := m.last_impression
	if v == nil {
		return
	}
	return *v, true
}

// OldLastImpression returns the old "last_impression" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldLastImpression(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastImpression is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastImpression requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastImpression: %w", err)
	}
	return oldValue.LastImpression, nil
}

// ClearLastImpression clears the value of the "last_impression" field.
func (m *BannerMutation) ClearLastImpression() {
	m.last_impression = nil
	m.clearedFields[banner.FieldLastImpression] = struct{}{}
}

// LastImpressionCleared returns if the "last_impression" field was cleared in this mutation.
func (m *BannerMutation) LastImpressionCleared() bool {
	_, ok := m.clearedFields[banner.FieldLastImpression]
	return ok
}

// ResetLastImpression resets all changes to the "last_impression" field.
func (m *BannerMutation) ResetLastImpression() {
	m.last_impression = nil
	delete(m.clearedFields, banner.FieldLastImpression)
}

// SetStartDate sets the "start_date" field.
func (m *BannerMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *BannerMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *BannerMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[banner.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *BannerMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[banner.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *BannerMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, banner.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *BannerMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *BannerMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *BannerMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[banner.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *BannerMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[banner.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *BannerMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, banner.FieldEndDate)
}

// SetAllowedDevices sets the "allowed_devices" field.
func (m *BannerMutation) SetAllowedDevices(s []string) {
	m.allowed_devices = &s
	m.appendallowed_devices = nil
}

// AllowedDevices returns the value of the "allowed_devices" field in the mutation.
func (m *BannerMutation) AllowedDevices() (r []string, exists bool) {
	v := m.allowed_devices
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedDevices returns the old "allowed_devices" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedDevices(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedDevices is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedDevices requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedDevices: %w", err)
	}
	return oldValue.AllowedDevices, nil
}

// AppendAllowedDevices adds s to the "allowed_devices" field.
func (m *BannerMutation) AppendAllowedDevices(s []string) {
	m.appendallowed_devices = append(m.appendallowed_devices, s...)
}

// AppendedAllowedDevices returns the list of values that were appended to the "allowed_devices" field in this mutation.
func (m *BannerMutation) AppendedAllowedDevices() ([]string, bool) {
	if len(m.appendallowed_devices) == 0 {
		return nil, false
	}
	return m.appendallowed_devices, true
}

// ClearAllowedDevices clears the value of the "allowed_devices" field.
func (m *BannerMutation) ClearAllowedDevices() {
	m.allowed_devices = nil
	m.appendallowed_devices = nil
	m.clearedFields[banner.FieldAllowedDevices] = struct{}{}
}

// AllowedDevicesCleared returns if the "allowed_devices" field was cleared in this mutation.
func (m *BannerMutation) AllowedDevicesCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedDevices]
	return ok
}

// ResetAllowedDevices resets all changes to the "allowed_devices" field.
func (m *BannerMutation) ResetAllowedDevices() {
	m.allowed_devices = nil
	m.appendallowed_devices = nil
	delete(m.clearedFields, banner.FieldAllowedDevices)
}

// SetAllowedBrowsers sets the "allowed_browsers" field.
func (m *BannerMutation) SetAllowedBrowsers(s []string) {
	m.allowed_browsers = &s
	m.appendallowed_browsers = nil
}

// AllowedBrowsers returns the value of the "allowed_browsers" field in the mutation.
func (m *BannerMutation) AllowedBrowsers() (r []string, exists bool) {
	v := m.allowed_browsers
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedBrowsers returns the old "allowed_browsers" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedBrowsers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedBrowsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedBrowsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedBrowsers: %w", err)
	}
	return oldValue.AllowedBrowsers, nil
}

// AppendAllowedBrowsers adds s to the "allowed_browsers" field.
func (m *BannerMutation) AppendAllowedBrowsers(s []string) {
	m.appendallowed_browsers = append(m.appendallowed_browsers, s...)
}

// AppendedAllowedBrowsers returns the list of values that were appended to the "allowed_browsers" field in this mutation.
func (m *BannerMutation) AppendedAllowedBrowsers() ([]string, bool) {
	if len(m.appendallowed_browsers) == 0 {
		return nil, false
	}
	return m.appendallowed_browsers, true
}

// ClearAllowedBrowsers clears the value of the "allowed_browsers" field.
func (m *BannerMutation) ClearAllowedBrowsers() {
	m.allowed_browsers = nil
	m.appendallowed_browsers = nil
	m.clearedFields[banner.FieldAllowedBrowsers] = struct{}{}
}

// AllowedBrowsersCleared returns if the "allowed_browsers" field was cleared in this mutation.
func (m *BannerMutation) AllowedBrowsersCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedBrowsers]
	return ok
}

// ResetAllowedBrowsers resets all changes to the "allowed_browsers" field.
func (m *BannerMutation) ResetAllowedBrowsers() {
	m.allowed_browsers = nil
	m.appendallowed_browsers = nil
	delete(m.clearedFields, banner.FieldAllowedBrowsers)
}

// SetAllowedOs sets the "allowed_os" field.
func (m *BannerMutation) SetAllowedOs(s []string) {
	m.allowed_os = &s
	m.appendallowed_os = nil
}

// AllowedOs returns the value of the "allowed_os" field in the mutation.
func (m *BannerMutation) AllowedOs() (r []string, exists bool) {
	v := m.allowed_os
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowedOs returns the old "allowed_os" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldAllowedOs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowedOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowedOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowedOs: %w", err)
	}
	return oldValue.AllowedOs, nil
}

// AppendAllowedOs adds s to the "allowed_os" field.
func (m *BannerMutation) AppendAllowedOs(s []string) {
	m.appendallowed_os = append(m.appendallowed_os, s...)
}

// AppendedAllowedOs returns the list of values that were appended to the "allowed_os" field in this mutation.
func (m *BannerMutation) AppendedAllowedOs() ([]string, bool) {
	if len(m.appendallowed_os) == 0 {
		return nil, false
	}
	return m.appendallowed_os, true
}

// ClearAllowedOs clears the value of the "allowed_os" field.
func (m *BannerMutation) ClearAllowedOs() {
	m.allowed_os = nil
	m.appendallowed_os = nil
	m.clearedFields[banner.FieldAllowedOs] = struct{}{}
}

// AllowedOsCleared returns if the "allowed_os" field was cleared in this mutation.
func (m *BannerMutation) AllowedOsCleared() bool {
	_, ok := m.clearedFields[banner.FieldAllowedOs]
	return ok
}

// ResetAllowedOs resets all changes to the "allowed_os" field.
func (m *BannerMutation) ResetAllowedOs() {
	m.allowed_os = nil
	m.appendallowed_os = nil
	delete(m.clearedFields, banner.FieldAllowedOs)
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCampaignIDs adds the "campaigns" edge to the Campaign entity by ids.
func (m *BannerMutation) AddCampaignIDs(ids ...int64) {
	if m.campaigns == nil {
		m.campaigns = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaigns[ids[i]] = struct{}{}
	}
}

// ClearCampaigns clears the "campaigns" edge to the Campaign entity.
func (m *BannerMutation) ClearCampaigns() {
	m.clearedcampaigns = true
}

// CampaignsCleared reports if the "campaigns" edge to the Campaign entity was cleared.
func (m *BannerMutation) CampaignsCleared() bool {
	return m.clearedcampaigns
}

// RemoveCampaignIDs removes the "campaigns" edge to the Campaign entity by IDs.
func (m *BannerMutation) RemoveCampaignIDs(ids ...int64) {
	if m.removedcampaigns == nil {
		m.removedcampaigns = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaigns, ids[i])
		m.removedcampaigns[ids[i]] = struct{}{}
	}
}

// RemovedCampaigns returns the removed IDs of the "campaigns" edge to the Campaign entity.
func (m *BannerMutation) RemovedCampaignsIDs() (ids []int64) {
	for id := range m.removedcampaigns {
		ids = append(ids, id)
	}
	return
}

// CampaignsIDs returns the "campaigns" edge IDs in the mutation.
func (m *BannerMutation) CampaignsIDs() (ids []int64) {
	for id := range m.campaigns {
		ids = append(ids, id)
	}
	return
}

// ResetCampaigns resets all changes to the "campaigns" edge.
func (m *BannerMutation) ResetCampaigns() {
	m.campaigns = nil
	m.clearedcampaigns = false
	m.removedcampaigns = nil
}

// AddCreativeIDs adds the "creatives" edge to the Creative entity by ids.
func (m *BannerMutation) AddCreativeIDs(ids ...int64) {
	if m.creatives == nil {
		m.creatives = make(map[int64]struct{})
	}
	for i := range ids {
		m.creatives[ids[i]] = struct{}{}
	}
}

// ClearCreatives clears the "creatives" edge to the Creative entity.
func (m *BannerMutation) ClearCreatives() {
	m.clearedcreatives = true
}

// CreativesCleared reports if the "creatives" edge to the Creative entity was cleared.
func (m *BannerMutation) CreativesCleared() bool {
	return m.clearedcreatives
}

// RemoveCreativeIDs removes the "creatives" edge to the Creative entity by IDs.
func (m *BannerMutation) RemoveCreativeIDs(ids ...int64) {
	if m.removedcreatives == nil {
		m.removedcreatives = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.creatives, ids[i])
		m.removedcreatives[ids[i]] = struct{}{}
	}
}

// RemovedCreatives returns the removed IDs of the "creatives" edge to the Creative entity.
func (m *BannerMutation) RemovedCreativesIDs() (ids []int64) {
	for id := range m.removedcreatives {
		ids = append(ids, id)
	}
	return
}

// CreativesIDs returns the "creatives" edge IDs in the mutation.
func (m *BannerMutation) CreativesIDs() (ids []int64) {
	for id := range m.creatives {
		ids = append(ids, id)
	}
	return
}

// ResetCreatives resets all changes to the "creatives" edge.
func (m *BannerMutation) ResetCreatives() {
	m.creatives = nil
	m.clearedcreatives = false
	m.removedcreatives = nil
}

// AddStatIDs adds the "stats" edge to the BannerStats entity by ids.
func (m *BannerMutation) AddStatIDs(ids ...int64) {
	if m.stats == nil {
		m.stats = make(map[int64]struct{})
	}
	for i := range ids {
		m.stats[ids[i]] = struct{}{}
	}
}

// ClearStats clears the "stats" edge to the BannerStats entity.
func (m *BannerMutation) ClearStats() {
	m.clearedstats = true
}

// StatsCleared reports if the "stats" edge to the BannerStats entity was cleared.
func (m *BannerMutation) StatsCleared() bool {
	return m.clearedstats
}

// RemoveStatIDs removes the "stats" edge to the BannerStats entity by IDs.
func (m *BannerMutation) RemoveStatIDs(ids ...int64) {
	if m.removedstats == nil {
		m.removedstats = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.stats, ids[i])
		m.removedstats[ids[i]] = struct{}{}
	}
}

// RemovedStats returns the removed IDs of the "stats" edge to the BannerStats entity.
func (m *BannerMutation) RemovedStatsIDs() (ids []int64) {
	for id := range m.removedstats {
		ids = append(ids, id)
	}
	return
}

// StatsIDs returns the "stats" edge IDs in the mutation.
func (m *BannerMutation) StatsIDs() (ids []int64) {
	for id := range m.stats {
		ids = append(ids, id)
	}
	return
}

// ResetStats resets all changes to the "stats" edge.
func (m *BannerMutation) ResetStats() {
	m.stats = nil
	m.clearedstats = false
	m.removedstats = nil
}

// AddLeadIDs adds the "leads" edge to the Lead entity by ids.
func (m *BannerMutation) AddLeadIDs(ids ...int64) {
	if m.leads == nil {
		m.leads = make(map[int64]struct{})
	}
	for i := range ids {
		m.leads[ids[i]] = struct{}{}
	}
}

// ClearLeads clears the "leads" edge to the Lead entity.
func (m *BannerMutation) ClearLeads() {
	m.clearedleads = true
}

// LeadsCleared reports if the "leads" edge to the Lead entity was cleared.
func (m *BannerMutation) LeadsCleared() bool {
	return m.clearedleads
}

// RemoveLeadIDs removes the "leads" edge to the Lead entity by IDs.
func (m *BannerMutation) RemoveLeadIDs(ids ...int64) {
	if m.removedleads == nil {
		m.removedleads = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.leads, ids[i])
		m.removedleads[ids[i]] = struct{}{}
	}
}

// RemovedLeads returns the removed IDs of the "leads" edge to the Lead entity.
func (m *BannerMutation) RemovedLeadsIDs() (ids []int64) {
	for id := range m.removedleads {
		ids = append(ids, id)
	}
	return
}

// LeadsIDs returns the "leads" edge IDs in the mutation.
func (m *BannerMutation) LeadsIDs() (ids []int64) {
	for id := range m.leads {
		ids = append(ids, id)
	}
	return
}

// ResetLeads resets all changes to the "leads" edge.
func (m *BannerMutation) ResetLeads() {
	m.leads = nil
	m.clearedleads = false
	m.removedleads = nil
}

// AddBannerCreativeIDs adds the "banner_creatives" edge to the BannerCreative entity by ids.
func (m *BannerMutation) AddBannerCreativeIDs(ids ...int) {
	if m.banner_creatives == nil {
		m.banner_creatives = make(map[int]struct{})
	}
	for i := range ids {
		m.banner_creatives[ids[i]] = struct{}{}
	}
}

// ClearBannerCreatives clears the "banner_creatives" edge to the BannerCreative entity.
func (m *BannerMutation) ClearBannerCreatives() {
	m.clearedbanner_creatives = true
}

// BannerCreativesCleared reports if the "banner_creatives" edge to the BannerCreative entity was cleared.
func (m *BannerMutation) BannerCreativesCleared() bool {
	return m.clearedbanner_creatives
}

// RemoveBannerCreativeIDs removes the "banner_creatives" edge to the BannerCreative entity by IDs.
func (m *BannerMutation) RemoveBannerCreativeIDs(ids ...int) {
	if m.removedbanner_creatives == nil {
		m.removedbanner_creatives = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.banner_creatives, ids[i])
		m.removedbanner_creatives[ids[i]] = struct{}{}
	}
}

// RemovedBannerCreatives returns the removed IDs of the "banner_creatives" edge to the BannerCreative entity.
func (m *BannerMutation) RemovedBannerCreativesIDs() (ids []int) {
	for id := range m.removedbanner_creatives {
		ids = append(ids, id)
	}
	return
}

// BannerCreativesIDs returns the "banner_creatives" edge IDs in the mutation.
func (m *BannerMutation) BannerCreativesIDs() (ids []int) {
	for id := range m.banner_creatives {
		ids = append(ids, id)
	}
	return
}

// ResetBannerCreatives resets all changes to the "banner_creatives" edge.
func (m *BannerMutation) ResetBannerCreatives() {
	m.banner_creatives = nil
	m.clearedbanner_creatives = false
	m.removedbanner_creatives = nil
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Banner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, banner.FieldName)
	}
	if m.description != nil {
		fields = append(fields, banner.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, banner.FieldType)
	}
	if m.click_url != nil {
		fields = append(fields, banner.FieldClickURL)
	}
	if m.size != nil {
		fields = append(fields, banner.FieldSize)
	}
	if m.status != nil {
		fields = append(fields, banner.FieldStatus)
	}
	if m.allowed_countries != nil {
		fields = append(fields, banner.FieldAllowedCountries)
	}
	if m.weight != nil {
		fields = append(fields, banner.FieldWeight)
	}
	if m.smart_weight != nil {
		fields = append(fields, banner.FieldSmartWeight)
	}
	if m.last_impression != nil {
		fields = append(fields, banner.FieldLastImpression)
	}
	if m.start_date != nil {
		fields = append(fields, banner.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, banner.FieldEndDate)
	}
	if m.allowed_devices != nil {
		fields = append(fields, banner.FieldAllowedDevices)
	}
	if m.allowed_browsers != nil {
		fields = append(fields, banner.FieldAllowedBrowsers)
	}
	if m.allowed_os != nil {
		fields = append(fields, banner.FieldAllowedOs)
	}
	if m.created_at != nil {
		fields = append(fields, banner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldName:
		return m.Name()
	case banner.FieldDescription:
		return m.Description()
	case banner.FieldType:
		return m.GetType()
	case banner.FieldClickURL:
		return m.ClickURL()
	case banner.FieldSize:
		return m.Size()
	case banner.FieldStatus:
		return m.Status()
	case banner.FieldAllowedCountries:
		return m.AllowedCountries()
	case banner.FieldWeight:
		return m.Weight()
	case banner.FieldSmartWeight:
		return m.SmartWeight()
	case banner.FieldLastImpression:
		return m.LastImpression()
	case banner.FieldStartDate:
		return m.StartDate()
	case banner.FieldEndDate:
		return m.EndDate()
	case banner.FieldAllowedDevices:
		return m.AllowedDevices()
	case banner.FieldAllowedBrowsers:
		return m.AllowedBrowsers()
	case banner.FieldAllowedOs:
		return m.AllowedOs()
	case banner.FieldCreatedAt:
		return m.CreatedAt()
	case banner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldName:
		return m.OldName(ctx)
	case banner.FieldDescription:
		return m.OldDescription(ctx)
	case banner.FieldType:
		return m.OldType(ctx)
	case banner.FieldClickURL:
		return m.OldClickURL(ctx)
	case banner.FieldSize:
		return m.OldSize(ctx)
	case banner.FieldStatus:
		return m.OldStatus(ctx)
	case banner.FieldAllowedCountries:
		return m.OldAllowedCountries(ctx)
	case banner.FieldWeight:
		return m.OldWeight(ctx)
	case banner.FieldSmartWeight:
		return m.OldSmartWeight(ctx)
	case banner.FieldLastImpression:
		return m.OldLastImpression(ctx)
	case banner.FieldStartDate:
		return m.OldStartDate(ctx)
	case banner.FieldEndDate:
		return m.OldEndDate(ctx)
	case banner.FieldAllowedDevices:
		return m.OldAllowedDevices(ctx)
	case banner.FieldAllowedBrowsers:
		return m.OldAllowedBrowsers(ctx)
	case banner.FieldAllowedOs:
		return m.OldAllowedOs(ctx)
	case banner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case banner.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case banner.FieldType:
		v, ok := value.(banner.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case banner.FieldClickURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickURL(v)
		return nil
	case banner.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case banner.FieldStatus:
		v, ok := value.(banner.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case banner.FieldAllowedCountries:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedCountries(v)
		return nil
	case banner.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case banner.FieldSmartWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmartWeight(v)
		return nil
	case banner.FieldLastImpression:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastImpression(v)
		return nil
	case banner.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case banner.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case banner.FieldAllowedDevices:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedDevices(v)
		return nil
	case banner.FieldAllowedBrowsers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedBrowsers(v)
		return nil
	case banner.FieldAllowedOs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowedOs(v)
		return nil
	case banner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, banner.FieldWeight)
	}
	if m.addsmart_weight != nil {
		fields = append(fields, banner.FieldSmartWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldWeight:
		return m.AddedWeight()
	case banner.FieldSmartWeight:
		return m.AddedSmartWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banner.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case banner.FieldSmartWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSmartWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banner.FieldDescription) {
		fields = append(fields, banner.FieldDescription)
	}
	if m.FieldCleared(banner.FieldClickURL) {
		fields = append(fields, banner.FieldClickURL)
	}
	if m.FieldCleared(banner.FieldAllowedCountries) {
		fields = append(fields, banner.FieldAllowedCountries)
	}
	if m.FieldCleared(banner.FieldSmartWeight) {
		fields = append(fields, banner.FieldSmartWeight)
	}
	if m.FieldCleared(banner.FieldLastImpression) {
		fields = append(fields, banner.FieldLastImpression)
	}
	if m.FieldCleared(banner.FieldStartDate) {
		fields = append(fields, banner.FieldStartDate)
	}
	if m.FieldCleared(banner.FieldEndDate) {
		fields = append(fields, banner.FieldEndDate)
	}
	if m.FieldCleared(banner.FieldAllowedDevices) {
		fields = append(fields, banner.FieldAllowedDevices)
	}
	if m.FieldCleared(banner.FieldAllowedBrowsers) {
		fields = append(fields, banner.FieldAllowedBrowsers)
	}
	if m.FieldCleared(banner.FieldAllowedOs) {
		fields = append(fields, banner.FieldAllowedOs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	switch name {
	case banner.FieldDescription:
		m.ClearDescription()
		return nil
	case banner.FieldClickURL:
		m.ClearClickURL()
		return nil
	case banner.FieldAllowedCountries:
		m.ClearAllowedCountries()
		return nil
	case banner.FieldSmartWeight:
		m.ClearSmartWeight()
		return nil
	case banner.FieldLastImpression:
		m.ClearLastImpression()
		return nil
	case banner.FieldStartDate:
		m.ClearStartDate()
		return nil
	case banner.FieldEndDate:
		m.ClearEndDate()
		return nil
	case banner.FieldAllowedDevices:
		m.ClearAllowedDevices()
		return nil
	case banner.FieldAllowedBrowsers:
		m.ClearAllowedBrowsers()
		return nil
	case banner.FieldAllowedOs:
		m.ClearAllowedOs()
		return nil
	}
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldName:
		m.ResetName()
		return nil
	case banner.FieldDescription:
		m.ResetDescription()
		return nil
	case banner.FieldType:
		m.ResetType()
		return nil
	case banner.FieldClickURL:
		m.ResetClickURL()
		return nil
	case banner.FieldSize:
		m.ResetSize()
		return nil
	case banner.FieldStatus:
		m.ResetStatus()
		return nil
	case banner.FieldAllowedCountries:
		m.ResetAllowedCountries()
		return nil
	case banner.FieldWeight:
		m.ResetWeight()
		return nil
	case banner.FieldSmartWeight:
		m.ResetSmartWeight()
		return nil
	case banner.FieldLastImpression:
		m.ResetLastImpression()
		return nil
	case banner.FieldStartDate:
		m.ResetStartDate()
		return nil
	case banner.FieldEndDate:
		m.ResetEndDate()
		return nil
	case banner.FieldAllowedDevices:
		m.ResetAllowedDevices()
		return nil
	case banner.FieldAllowedBrowsers:
		m.ResetAllowedBrowsers()
		return nil
	case banner.FieldAllowedOs:
		m.ResetAllowedOs()
		return nil
	case banner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.campaigns != nil {
		edges = append(edges, banner.EdgeCampaigns)
	}
	if m.creatives != nil {
		edges = append(edges, banner.EdgeCreatives)
	}
	if m.stats != nil {
		edges = append(edges, banner.EdgeStats)
	}
	if m.leads != nil {
		edges = append(edges, banner.EdgeLeads)
	}
	if m.banner_creatives != nil {
		edges = append(edges, banner.EdgeBannerCreatives)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.campaigns))
		for id := range m.campaigns {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeCreatives:
		ids := make([]ent.Value, 0, len(m.creatives))
		for id := range m.creatives {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeStats:
		ids := make([]ent.Value, 0, len(m.stats))
		for id := range m.stats {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeLeads:
		ids := make([]ent.Value, 0, len(m.leads))
		for id := range m.leads {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeBannerCreatives:
		ids := make([]ent.Value, 0, len(m.banner_creatives))
		for id := range m.banner_creatives {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcampaigns != nil {
		edges = append(edges, banner.EdgeCampaigns)
	}
	if m.removedcreatives != nil {
		edges = append(edges, banner.EdgeCreatives)
	}
	if m.removedstats != nil {
		edges = append(edges, banner.EdgeStats)
	}
	if m.removedleads != nil {
		edges = append(edges, banner.EdgeLeads)
	}
	if m.removedbanner_creatives != nil {
		edges = append(edges, banner.EdgeBannerCreatives)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.removedcampaigns))
		for id := range m.removedcampaigns {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeCreatives:
		ids := make([]ent.Value, 0, len(m.removedcreatives))
		for id := range m.removedcreatives {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeStats:
		ids := make([]ent.Value, 0, len(m.removedstats))
		for id := range m.removedstats {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeLeads:
		ids := make([]ent.Value, 0, len(m.removedleads))
		for id := range m.removedleads {
			ids = append(ids, id)
		}
		return ids
	case banner.EdgeBannerCreatives:
		ids := make([]ent.Value, 0, len(m.removedbanner_creatives))
		for id := range m.removedbanner_creatives {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcampaigns {
		edges = append(edges, banner.EdgeCampaigns)
	}
	if m.clearedcreatives {
		edges = append(edges, banner.EdgeCreatives)
	}
	if m.clearedstats {
		edges = append(edges, banner.EdgeStats)
	}
	if m.clearedleads {
		edges = append(edges, banner.EdgeLeads)
	}
	if m.clearedbanner_creatives {
		edges = append(edges, banner.EdgeBannerCreatives)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	switch name {
	case banner.EdgeCampaigns:
		return m.clearedcampaigns
	case banner.EdgeCreatives:
		return m.clearedcreatives
	case banner.EdgeStats:
		return m.clearedstats
	case banner.EdgeLeads:
		return m.clearedleads
	case banner.EdgeBannerCreatives:
		return m.clearedbanner_creatives
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	switch name {
	case banner.EdgeCampaigns:
		m.ResetCampaigns()
		return nil
	case banner.EdgeCreatives:
		m.ResetCreatives()
		return nil
	case banner.EdgeStats:
		m.ResetStats()
		return nil
	case banner.EdgeLeads:
		m.ResetLeads()
		return nil
	case banner.EdgeBannerCreatives:
		m.ResetBannerCreatives()
		return nil
	}
	return fmt.Errorf("unknown Banner edge %s", name)
}

// BannerCreativeMutation represents an operation that mutates the BannerCreative nodes in the graph.
type BannerCreativeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	is_primary       *bool
	display_order    *int
	adddisplay_order *int
	clearedFields    map[string]struct{}
	banner           *int64
	clearedbanner    bool
	creative         *int64
	clearedcreative  bool
	done             bool
	oldValue         func(context.Context) (*BannerCreative, error)
	predicates       []predicate.BannerCreative
}

var _ ent.Mutation = (*BannerCreativeMutation)(nil)

// bannercreativeOption allows management of the mutation configuration using functional options.
type bannercreativeOption func(*BannerCreativeMutation)

// newBannerCreativeMutation creates new mutation for the BannerCreative entity.
func newBannerCreativeMutation(c config, op Op, opts ...bannercreativeOption) *BannerCreativeMutation {
	m := &BannerCreativeMutation{
		config:        c,
		op:            op,
		typ:           TypeBannerCreative,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerCreativeID sets the ID field of the mutation.
func withBannerCreativeID(id int) bannercreativeOption {
	return func(m *BannerCreativeMutation) {
		var (
			err   error
			once  sync.Once
			value *BannerCreative
		)
		m.oldValue = func(ctx context.Context) (*BannerCreative, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BannerCreative.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBannerCreative sets the old BannerCreative of the mutation.
func withBannerCreative(node *BannerCreative) bannercreativeOption {
	return func(m *BannerCreativeMutation) {
		m.oldValue = func(context.Context) (*BannerCreative, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerCreativeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerCreativeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerCreativeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerCreativeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BannerCreative.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBannerID sets the "banner_id" field.
func (m *BannerCreativeMutation) SetBannerID(i int64) {
	m.banner = &i
}

// BannerID returns the value of the "banner_id" field in the mutation.
func (m *BannerCreativeMutation) BannerID() (r int64, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerID returns the old "banner_id" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldBannerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerID: %w", err)
	}
	return oldValue.BannerID, nil
}

// ResetBannerID resets all changes to the "banner_id" field.
func (m *BannerCreativeMutation) ResetBannerID() {
	m.banner = nil
}

// SetCreativeID sets the "creative_id" field.
func (m *BannerCreativeMutation) SetCreativeID(i int64) {
	m.creative = &i
}

// CreativeID returns the value of the "creative_id" field in the mutation.
func (m *BannerCreativeMutation) CreativeID() (r int64, exists bool) {
	v := m.creative
	if v == nil {
		return
	}
	return *v, true
}

// OldCreativeID returns the old "creative_id" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldCreativeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreativeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreativeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreativeID: %w", err)
	}
	return oldValue.CreativeID, nil
}

// ResetCreativeID resets all changes to the "creative_id" field.
func (m *BannerCreativeMutation) ResetCreativeID() {
	m.creative = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerCreativeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerCreativeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerCreativeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerCreativeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerCreativeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerCreativeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIsPrimary sets the "is_primary" field.
func (m *BannerCreativeMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *BannerCreativeMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *BannerCreativeMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *BannerCreativeMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *BannerCreativeMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the BannerCreative entity.
// If the BannerCreative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerCreativeMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *BannerCreativeMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *BannerCreativeMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplayOrder clears the value of the "display_order" field.
func (m *BannerCreativeMutation) ClearDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
	m.clearedFields[bannercreative.FieldDisplayOrder] = struct{}{}
}

// DisplayOrderCleared returns if the "display_order" field was cleared in this mutation.
func (m *BannerCreativeMutation) DisplayOrderCleared() bool {
	_, ok := m.clearedFields[bannercreative.FieldDisplayOrder]
	return ok
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *BannerCreativeMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
	delete(m.clearedFields, bannercreative.FieldDisplayOrder)
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *BannerCreativeMutation) ClearBanner() {
	m.clearedbanner = true
	m.clearedFields[bannercreative.FieldBannerID] = struct{}{}
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *BannerCreativeMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *BannerCreativeMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *BannerCreativeMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// ClearCreative clears the "creative" edge to the Creative entity.
func (m *BannerCreativeMutation) ClearCreative() {
	m.clearedcreative = true
	m.clearedFields[bannercreative.FieldCreativeID] = struct{}{}
}

// CreativeCleared reports if the "creative" edge to the Creative entity was cleared.
func (m *BannerCreativeMutation) CreativeCleared() bool {
	return m.clearedcreative
}

// CreativeIDs returns the "creative" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreativeID instead. It exists only for internal usage by the builders.
func (m *BannerCreativeMutation) CreativeIDs() (ids []int64) {
	if id := m.creative; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreative resets all changes to the "creative" edge.
func (m *BannerCreativeMutation) ResetCreative() {
	m.creative = nil
	m.clearedcreative = false
}

// Where appends a list predicates to the BannerCreativeMutation builder.
func (m *BannerCreativeMutation) Where(ps ...predicate.BannerCreative) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerCreativeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerCreativeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BannerCreative, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerCreativeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerCreativeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BannerCreative).
func (m *BannerCreativeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerCreativeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.banner != nil {
		fields = append(fields, bannercreative.FieldBannerID)
	}
	if m.creative != nil {
		fields = append(fields, bannercreative.FieldCreativeID)
	}
	if m.created_at != nil {
		fields = append(fields, bannercreative.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bannercreative.FieldUpdatedAt)
	}
	if m.is_primary != nil {
		fields = append(fields, bannercreative.FieldIsPrimary)
	}
	if m.display_order != nil {
		fields = append(fields, bannercreative.FieldDisplayOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerCreativeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bannercreative.FieldBannerID:
		return m.BannerID()
	case bannercreative.FieldCreativeID:
		return m.CreativeID()
	case bannercreative.FieldCreatedAt:
		return m.CreatedAt()
	case bannercreative.FieldUpdatedAt:
		return m.UpdatedAt()
	case bannercreative.FieldIsPrimary:
		return m.IsPrimary()
	case bannercreative.FieldDisplayOrder:
		return m.DisplayOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerCreativeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bannercreative.FieldBannerID:
		return m.OldBannerID(ctx)
	case bannercreative.FieldCreativeID:
		return m.OldCreativeID(ctx)
	case bannercreative.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bannercreative.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bannercreative.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case bannercreative.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	}
	return nil, fmt.Errorf("unknown BannerCreative field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerCreativeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bannercreative.FieldBannerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerID(v)
		return nil
	case bannercreative.FieldCreativeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreativeID(v)
		return nil
	case bannercreative.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bannercreative.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bannercreative.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case bannercreative.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown BannerCreative field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerCreativeMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, bannercreative.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerCreativeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bannercreative.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerCreativeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bannercreative.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown BannerCreative numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerCreativeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bannercreative.FieldDisplayOrder) {
		fields = append(fields, bannercreative.FieldDisplayOrder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerCreativeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerCreativeMutation) ClearField(name string) error {
	switch name {
	case bannercreative.FieldDisplayOrder:
		m.ClearDisplayOrder()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerCreativeMutation) ResetField(name string) error {
	switch name {
	case bannercreative.FieldBannerID:
		m.ResetBannerID()
		return nil
	case bannercreative.FieldCreativeID:
		m.ResetCreativeID()
		return nil
	case bannercreative.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bannercreative.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bannercreative.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case bannercreative.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerCreativeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.banner != nil {
		edges = append(edges, bannercreative.EdgeBanner)
	}
	if m.creative != nil {
		edges = append(edges, bannercreative.EdgeCreative)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerCreativeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bannercreative.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	case bannercreative.EdgeCreative:
		if id := m.creative; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerCreativeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerCreativeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerCreativeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbanner {
		edges = append(edges, bannercreative.EdgeBanner)
	}
	if m.clearedcreative {
		edges = append(edges, bannercreative.EdgeCreative)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerCreativeMutation) EdgeCleared(name string) bool {
	switch name {
	case bannercreative.EdgeBanner:
		return m.clearedbanner
	case bannercreative.EdgeCreative:
		return m.clearedcreative
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerCreativeMutation) ClearEdge(name string) error {
	switch name {
	case bannercreative.EdgeBanner:
		m.ClearBanner()
		return nil
	case bannercreative.EdgeCreative:
		m.ClearCreative()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerCreativeMutation) ResetEdge(name string) error {
	switch name {
	case bannercreative.EdgeBanner:
		m.ResetBanner()
		return nil
	case bannercreative.EdgeCreative:
		m.ResetCreative()
		return nil
	}
	return fmt.Errorf("unknown BannerCreative edge %s", name)
}

// BannerStatsMutation represents an operation that mutates the BannerStats nodes in the graph.
type BannerStatsMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	date               *time.Time
	impressions        *int64
	addimpressions     *int64
	clicks             *int64
	addclicks          *int64
	leads              *int64
	addleads           *int64
	earnings           *float64
	addearnings        *float64
	ctr                *float64
	addctr             *float64
	conversion_rate    *float64
	addconversion_rate *float64
	device_type        *string
	browser            *string
	os                 *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	banner             *int64
	clearedbanner      bool
	publisher          *int64
	clearedpublisher   bool
	done               bool
	oldValue           func(context.Context) (*BannerStats, error)
	predicates         []predicate.BannerStats
}

var _ ent.Mutation = (*BannerStatsMutation)(nil)

// bannerstatsOption allows management of the mutation configuration using functional options.
type bannerstatsOption func(*BannerStatsMutation)

// newBannerStatsMutation creates new mutation for the BannerStats entity.
func newBannerStatsMutation(c config, op Op, opts ...bannerstatsOption) *BannerStatsMutation {
	m := &BannerStatsMutation{
		config:        c,
		op:            op,
		typ:           TypeBannerStats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerStatsID sets the ID field of the mutation.
func withBannerStatsID(id int64) bannerstatsOption {
	return func(m *BannerStatsMutation) {
		var (
			err   error
			once  sync.Once
			value *BannerStats
		)
		m.oldValue = func(ctx context.Context) (*BannerStats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BannerStats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBannerStats sets the old BannerStats of the mutation.
func withBannerStats(node *BannerStats) bannerstatsOption {
	return func(m *BannerStatsMutation) {
		m.oldValue = func(context.Context) (*BannerStats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerStatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerStatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BannerStats entities.
func (m *BannerStatsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerStatsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BannerStatsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BannerStats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *BannerStatsMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *BannerStatsMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *BannerStatsMutation) ResetDate() {
	m.date = nil
}

// SetImpressions sets the "impressions" field.
func (m *BannerStatsMutation) SetImpressions(i int64) {
	m.impressions = &i
	m.addimpressions = nil
}

// Impressions returns the value of the "impressions" field in the mutation.
func (m *BannerStatsMutation) Impressions() (r int64, exists bool) {
	v := m.impressions
	if v == nil {
		return
	}
	return *v, true
}

// OldImpressions returns the old "impressions" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldImpressions(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpressions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpressions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpressions: %w", err)
	}
	return oldValue.Impressions, nil
}

// AddImpressions adds i to the "impressions" field.
func (m *BannerStatsMutation) AddImpressions(i int64) {
	if m.addimpressions != nil {
		*m.addimpressions += i
	} else {
		m.addimpressions = &i
	}
}

// AddedImpressions returns the value that was added to the "impressions" field in this mutation.
func (m *BannerStatsMutation) AddedImpressions() (r int64, exists bool) {
	v := m.addimpressions
	if v == nil {
		return
	}
	return *v, true
}

// ResetImpressions resets all changes to the "impressions" field.
func (m *BannerStatsMutation) ResetImpressions() {
	m.impressions = nil
	m.addimpressions = nil
}

// SetClicks sets the "clicks" field.
func (m *BannerStatsMutation) SetClicks(i int64) {
	m.clicks = &i
	m.addclicks = nil
}

// Clicks returns the value of the "clicks" field in the mutation.
func (m *BannerStatsMutation) Clicks() (r int64, exists bool) {
	v := m.clicks
	if v == nil {
		return
	}
	return *v, true
}

// OldClicks returns the old "clicks" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldClicks(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClicks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClicks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClicks: %w", err)
	}
	return oldValue.Clicks, nil
}

// AddClicks adds i to the "clicks" field.
func (m *BannerStatsMutation) AddClicks(i int64) {
	if m.addclicks != nil {
		*m.addclicks += i
	} else {
		m.addclicks = &i
	}
}

// AddedClicks returns the value that was added to the "clicks" field in this mutation.
func (m *BannerStatsMutation) AddedClicks() (r int64, exists bool) {
	v := m.addclicks
	if v == nil {
		return
	}
	return *v, true
}

// ResetClicks resets all changes to the "clicks" field.
func (m *BannerStatsMutation) ResetClicks() {
	m.clicks = nil
	m.addclicks = nil
}

// SetLeads sets the "leads" field.
func (m *BannerStatsMutation) SetLeads(i int64) {
	m.leads = &i
	m.addleads = nil
}

// Leads returns the value of the "leads" field in the mutation.
func (m *BannerStatsMutation) Leads() (r int64, exists bool) {
	v := m.leads
	if v == nil {
		return
	}
	return *v, true
}

// OldLeads returns the old "leads" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldLeads(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeads: %w", err)
	}
	return oldValue.Leads, nil
}

// AddLeads adds i to the "leads" field.
func (m *BannerStatsMutation) AddLeads(i int64) {
	if m.addleads != nil {
		*m.addleads += i
	} else {
		m.addleads = &i
	}
}

// AddedLeads returns the value that was added to the "leads" field in this mutation.
func (m *BannerStatsMutation) AddedLeads() (r int64, exists bool) {
	v := m.addleads
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeads resets all changes to the "leads" field.
func (m *BannerStatsMutation) ResetLeads() {
	m.leads = nil
	m.addleads = nil
}

// SetEarnings sets the "earnings" field.
func (m *BannerStatsMutation) SetEarnings(f float64) {
	m.earnings = &f
	m.addearnings = nil
}

// Earnings returns the value of the "earnings" field in the mutation.
func (m *BannerStatsMutation) Earnings() (r float64, exists bool) {
	v := m.earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldEarnings returns the old "earnings" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarnings: %w", err)
	}
	return oldValue.Earnings, nil
}

// AddEarnings adds f to the "earnings" field.
func (m *BannerStatsMutation) AddEarnings(f float64) {
	if m.addearnings != nil {
		*m.addearnings += f
	} else {
		m.addearnings = &f
	}
}

// AddedEarnings returns the value that was added to the "earnings" field in this mutation.
func (m *BannerStatsMutation) AddedEarnings() (r float64, exists bool) {
	v := m.addearnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetEarnings resets all changes to the "earnings" field.
func (m *BannerStatsMutation) ResetEarnings() {
	m.earnings = nil
	m.addearnings = nil
}

// SetCtr sets the "ctr" field.
func (m *BannerStatsMutation) SetCtr(f float64) {
	m.ctr = &f
	m.addctr = nil
}

// Ctr returns the value of the "ctr" field in the mutation.
func (m *BannerStatsMutation) Ctr() (r float64, exists bool) {
	v := m.ctr
	if v == nil {
		return
	}
	return *v, true
}

// OldCtr returns the old "ctr" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldCtr(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCtr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCtr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCtr: %w", err)
	}
	return oldValue.Ctr, nil
}

// AddCtr adds f to the "ctr" field.
func (m *BannerStatsMutation) AddCtr(f float64) {
	if m.addctr != nil {
		*m.addctr += f
	} else {
		m.addctr = &f
	}
}

// AddedCtr returns the value that was added to the "ctr" field in this mutation.
func (m *BannerStatsMutation) AddedCtr() (r float64, exists bool) {
	v := m.addctr
	if v == nil {
		return
	}
	return *v, true
}

// ClearCtr clears the value of the "ctr" field.
func (m *BannerStatsMutation) ClearCtr() {
	m.ctr = nil
	m.addctr = nil
	m.clearedFields[bannerstats.FieldCtr] = struct{}{}
}

// CtrCleared returns if the "ctr" field was cleared in this mutation.
func (m *BannerStatsMutation) CtrCleared() bool {
	_, ok := m.clearedFields[bannerstats.FieldCtr]
	return ok
}

// ResetCtr resets all changes to the "ctr" field.
func (m *BannerStatsMutation) ResetCtr() {
	m.ctr = nil
	m.addctr = nil
	delete(m.clearedFields, bannerstats.FieldCtr)
}

// SetConversionRate sets the "conversion_rate" field.
func (m *BannerStatsMutation) SetConversionRate(f float64) {
	m.conversion_rate = &f
	m.addconversion_rate = nil
}

// ConversionRate returns the value of the "conversion_rate" field in the mutation.
func (m *BannerStatsMutation) ConversionRate() (r float64, exists bool) {
	v := m.conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldConversionRate returns the old "conversion_rate" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldConversionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversionRate: %w", err)
	}
	return oldValue.ConversionRate, nil
}

// AddConversionRate adds f to the "conversion_rate" field.
func (m *BannerStatsMutation) AddConversionRate(f float64) {
	if m.addconversion_rate != nil {
		*m.addconversion_rate += f
	} else {
		m.addconversion_rate = &f
	}
}

// AddedConversionRate returns the value that was added to the "conversion_rate" field in this mutation.
func (m *BannerStatsMutation) AddedConversionRate() (r float64, exists bool) {
	v := m.addconversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearConversionRate clears the value of the "conversion_rate" field.
func (m *BannerStatsMutation) ClearConversionRate() {
	m.conversion_rate = nil
	m.addconversion_rate = nil
	m.clearedFields[bannerstats.FieldConversionRate] = struct{}{}
}

// ConversionRateCleared returns if the "conversion_rate" field was cleared in this mutation.
func (m *BannerStatsMutation) ConversionRateCleared() bool {
	_, ok := m.clearedFields[bannerstats.FieldConversionRate]
	return ok
}

// ResetConversionRate resets all changes to the "conversion_rate" field.
func (m *BannerStatsMutation) ResetConversionRate() {
	m.conversion_rate = nil
	m.addconversion_rate = nil
	delete(m.clearedFields, bannerstats.FieldConversionRate)
}

// SetDeviceType sets the "device_type" field.
func (m *BannerStatsMutation) SetDeviceType(s string) {
	m.device_type = &s
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *BannerStatsMutation) DeviceType() (r string, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldDeviceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ClearDeviceType clears the value of the "device_type" field.
func (m *BannerStatsMutation) ClearDeviceType() {
	m.device_type = nil
	m.clearedFields[bannerstats.FieldDeviceType] = struct{}{}
}

// DeviceTypeCleared returns if the "device_type" field was cleared in this mutation.
func (m *BannerStatsMutation) DeviceTypeCleared() bool {
	_, ok := m.clearedFields[bannerstats.FieldDeviceType]
	return ok
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *BannerStatsMutation) ResetDeviceType() {
	m.device_type = nil
	delete(m.clearedFields, bannerstats.FieldDeviceType)
}

// SetBrowser sets the "browser" field.
func (m *BannerStatsMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *BannerStatsMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldBrowser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ClearBrowser clears the value of the "browser" field.
func (m *BannerStatsMutation) ClearBrowser() {
	m.browser = nil
	m.clearedFields[bannerstats.FieldBrowser] = struct{}{}
}

// BrowserCleared returns if the "browser" field was cleared in this mutation.
func (m *BannerStatsMutation) BrowserCleared() bool {
	_, ok := m.clearedFields[bannerstats.FieldBrowser]
	return ok
}

// ResetBrowser resets all changes to the "browser" field.
func (m *BannerStatsMutation) ResetBrowser() {
	m.browser = nil
	delete(m.clearedFields, bannerstats.FieldBrowser)
}

// SetOs sets the "os" field.
func (m *BannerStatsMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *BannerStatsMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *BannerStatsMutation) ClearOs() {
	m.os = nil
	m.clearedFields[bannerstats.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *BannerStatsMutation) OsCleared() bool {
	_, ok := m.clearedFields[bannerstats.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *BannerStatsMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, bannerstats.FieldOs)
}

// SetCreatedAt sets the "created_at" field.
func (m *BannerStatsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BannerStatsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BannerStatsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BannerStatsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BannerStatsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BannerStats entity.
// If the BannerStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerStatsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BannerStatsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBannerID sets the "banner" edge to the Banner entity by id.
func (m *BannerStatsMutation) SetBannerID(id int64) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *BannerStatsMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *BannerStatsMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *BannerStatsMutation) BannerID() (id int64, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *BannerStatsMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *BannerStatsMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// SetPublisherID sets the "publisher" edge to the User entity by id.
func (m *BannerStatsMutation) SetPublisherID(id int64) {
	m.publisher = &id
}

// ClearPublisher clears the "publisher" edge to the User entity.
func (m *BannerStatsMutation) ClearPublisher() {
	m.clearedpublisher = true
}

// PublisherCleared reports if the "publisher" edge to the User entity was cleared.
func (m *BannerStatsMutation) PublisherCleared() bool {
	return m.clearedpublisher
}

// PublisherID returns the "publisher" edge ID in the mutation.
func (m *BannerStatsMutation) PublisherID() (id int64, exists bool) {
	if m.publisher != nil {
		return *m.publisher, true
	}
	return
}

// PublisherIDs returns the "publisher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublisherID instead. It exists only for internal usage by the builders.
func (m *BannerStatsMutation) PublisherIDs() (ids []int64) {
	if id := m.publisher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublisher resets all changes to the "publisher" edge.
func (m *BannerStatsMutation) ResetPublisher() {
	m.publisher = nil
	m.clearedpublisher = false
}

// Where appends a list predicates to the BannerStatsMutation builder.
func (m *BannerStatsMutation) Where(ps ...predicate.BannerStats) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BannerStatsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BannerStatsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BannerStats, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BannerStatsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BannerStatsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BannerStats).
func (m *BannerStatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerStatsMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.date != nil {
		fields = append(fields, bannerstats.FieldDate)
	}
	if m.impressions != nil {
		fields = append(fields, bannerstats.FieldImpressions)
	}
	if m.clicks != nil {
		fields = append(fields, bannerstats.FieldClicks)
	}
	if m.leads != nil {
		fields = append(fields, bannerstats.FieldLeads)
	}
	if m.earnings != nil {
		fields = append(fields, bannerstats.FieldEarnings)
	}
	if m.ctr != nil {
		fields = append(fields, bannerstats.FieldCtr)
	}
	if m.conversion_rate != nil {
		fields = append(fields, bannerstats.FieldConversionRate)
	}
	if m.device_type != nil {
		fields = append(fields, bannerstats.FieldDeviceType)
	}
	if m.browser != nil {
		fields = append(fields, bannerstats.FieldBrowser)
	}
	if m.os != nil {
		fields = append(fields, bannerstats.FieldOs)
	}
	if m.created_at != nil {
		fields = append(fields, bannerstats.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bannerstats.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerStatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bannerstats.FieldDate:
		return m.Date()
	case bannerstats.FieldImpressions:
		return m.Impressions()
	case bannerstats.FieldClicks:
		return m.Clicks()
	case bannerstats.FieldLeads:
		return m.Leads()
	case bannerstats.FieldEarnings:
		return m.Earnings()
	case bannerstats.FieldCtr:
		return m.Ctr()
	case bannerstats.FieldConversionRate:
		return m.ConversionRate()
	case bannerstats.FieldDeviceType:
		return m.DeviceType()
	case bannerstats.FieldBrowser:
		return m.Browser()
	case bannerstats.FieldOs:
		return m.Os()
	case bannerstats.FieldCreatedAt:
		return m.CreatedAt()
	case bannerstats.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerStatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bannerstats.FieldDate:
		return m.OldDate(ctx)
	case bannerstats.FieldImpressions:
		return m.OldImpressions(ctx)
	case bannerstats.FieldClicks:
		return m.OldClicks(ctx)
	case bannerstats.FieldLeads:
		return m.OldLeads(ctx)
	case bannerstats.FieldEarnings:
		return m.OldEarnings(ctx)
	case bannerstats.FieldCtr:
		return m.OldCtr(ctx)
	case bannerstats.FieldConversionRate:
		return m.OldConversionRate(ctx)
	case bannerstats.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case bannerstats.FieldBrowser:
		return m.OldBrowser(ctx)
	case bannerstats.FieldOs:
		return m.OldOs(ctx)
	case bannerstats.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bannerstats.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BannerStats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerStatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bannerstats.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case bannerstats.FieldImpressions:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpressions(v)
		return nil
	case bannerstats.FieldClicks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClicks(v)
		return nil
	case bannerstats.FieldLeads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeads(v)
		return nil
	case bannerstats.FieldEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarnings(v)
		return nil
	case bannerstats.FieldCtr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCtr(v)
		return nil
	case bannerstats.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversionRate(v)
		return nil
	case bannerstats.FieldDeviceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case bannerstats.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case bannerstats.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case bannerstats.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bannerstats.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BannerStats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerStatsMutation) AddedFields() []string {
	var fields []string
	if m.addimpressions != nil {
		fields = append(fields, bannerstats.FieldImpressions)
	}
	if m.addclicks != nil {
		fields = append(fields, bannerstats.FieldClicks)
	}
	if m.addleads != nil {
		fields = append(fields, bannerstats.FieldLeads)
	}
	if m.addearnings != nil {
		fields = append(fields, bannerstats.FieldEarnings)
	}
	if m.addctr != nil {
		fields = append(fields, bannerstats.FieldCtr)
	}
	if m.addconversion_rate != nil {
		fields = append(fields, bannerstats.FieldConversionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerStatsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bannerstats.FieldImpressions:
		return m.AddedImpressions()
	case bannerstats.FieldClicks:
		return m.AddedClicks()
	case bannerstats.FieldLeads:
		return m.AddedLeads()
	case bannerstats.FieldEarnings:
		return m.AddedEarnings()
	case bannerstats.FieldCtr:
		return m.AddedCtr()
	case bannerstats.FieldConversionRate:
		return m.AddedConversionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerStatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bannerstats.FieldImpressions:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImpressions(v)
		return nil
	case bannerstats.FieldClicks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClicks(v)
		return nil
	case bannerstats.FieldLeads:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeads(v)
		return nil
	case bannerstats.FieldEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEarnings(v)
		return nil
	case bannerstats.FieldCtr:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCtr(v)
		return nil
	case bannerstats.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown BannerStats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerStatsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bannerstats.FieldCtr) {
		fields = append(fields, bannerstats.FieldCtr)
	}
	if m.FieldCleared(bannerstats.FieldConversionRate) {
		fields = append(fields, bannerstats.FieldConversionRate)
	}
	if m.FieldCleared(bannerstats.FieldDeviceType) {
		fields = append(fields, bannerstats.FieldDeviceType)
	}
	if m.FieldCleared(bannerstats.FieldBrowser) {
		fields = append(fields, bannerstats.FieldBrowser)
	}
	if m.FieldCleared(bannerstats.FieldOs) {
		fields = append(fields, bannerstats.FieldOs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerStatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerStatsMutation) ClearField(name string) error {
	switch name {
	case bannerstats.FieldCtr:
		m.ClearCtr()
		return nil
	case bannerstats.FieldConversionRate:
		m.ClearConversionRate()
		return nil
	case bannerstats.FieldDeviceType:
		m.ClearDeviceType()
		return nil
	case bannerstats.FieldBrowser:
		m.ClearBrowser()
		return nil
	case bannerstats.FieldOs:
		m.ClearOs()
		return nil
	}
	return fmt.Errorf("unknown BannerStats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerStatsMutation) ResetField(name string) error {
	switch name {
	case bannerstats.FieldDate:
		m.ResetDate()
		return nil
	case bannerstats.FieldImpressions:
		m.ResetImpressions()
		return nil
	case bannerstats.FieldClicks:
		m.ResetClicks()
		return nil
	case bannerstats.FieldLeads:
		m.ResetLeads()
		return nil
	case bannerstats.FieldEarnings:
		m.ResetEarnings()
		return nil
	case bannerstats.FieldCtr:
		m.ResetCtr()
		return nil
	case bannerstats.FieldConversionRate:
		m.ResetConversionRate()
		return nil
	case bannerstats.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case bannerstats.FieldBrowser:
		m.ResetBrowser()
		return nil
	case bannerstats.FieldOs:
		m.ResetOs()
		return nil
	case bannerstats.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bannerstats.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BannerStats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerStatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.banner != nil {
		edges = append(edges, bannerstats.EdgeBanner)
	}
	if m.publisher != nil {
		edges = append(edges, bannerstats.EdgePublisher)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerStatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bannerstats.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	case bannerstats.EdgePublisher:
		if id := m.publisher; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerStatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerStatsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerStatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbanner {
		edges = append(edges, bannerstats.EdgeBanner)
	}
	if m.clearedpublisher {
		edges = append(edges, bannerstats.EdgePublisher)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerStatsMutation) EdgeCleared(name string) bool {
	switch name {
	case bannerstats.EdgeBanner:
		return m.clearedbanner
	case bannerstats.EdgePublisher:
		return m.clearedpublisher
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerStatsMutation) ClearEdge(name string) error {
	switch name {
	case bannerstats.EdgeBanner:
		m.ClearBanner()
		return nil
	case bannerstats.EdgePublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown BannerStats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerStatsMutation) ResetEdge(name string) error {
	switch name {
	case bannerstats.EdgeBanner:
		m.ResetBanner()
		return nil
	case bannerstats.EdgePublisher:
		m.ResetPublisher()
		return nil
	}
	return fmt.Errorf("unknown BannerStats edge %s", name)
}

// CampaignMutation represents an operation that mutates the Campaign nodes in the graph.
type CampaignMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	description             *string
	unique_code             *string
	_type                   *campaign.Type
	commission_type         *campaign.CommissionType
	base_commission_rate    *float64
	addbase_commission_rate *float64
	commission_tiers        *[]schema.CommissionTier
	appendcommission_tiers  []schema.CommissionTier
	target_geography        *string
	target_demographics     *map[string]interface{}
	start_date              *time.Time
	end_date                *time.Time
	status                  *campaign.Status
	tracking_url            *string
	total_clicks            *int
	addtotal_clicks         *int
	total_conversions       *int
	addtotal_conversions    *int
	total_revenue           *float64
	addtotal_revenue        *float64
	conversion_rate         *float64
	addconversion_rate      *float64
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	owner                   *int64
	clearedowner            bool
	links                   map[int64]struct{}
	removedlinks            map[int64]struct{}
	clearedlinks            bool
	banners                 map[int64]struct{}
	removedbanners          map[int64]struct{}
	clearedbanners          bool
	done                    bool
	oldValue                func(context.Context) (*Campaign, error)
	predicates              []predicate.Campaign
}

var _ ent.Mutation = (*CampaignMutation)(nil)

// campaignOption allows management of the mutation configuration using functional options.
type campaignOption func(*CampaignMutation)

// newCampaignMutation creates new mutation for the Campaign entity.
func newCampaignMutation(c config, op Op, opts ...campaignOption) *CampaignMutation {
	m := &CampaignMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignID sets the ID field of the mutation.
func withCampaignID(id int64) campaignOption {
	return func(m *CampaignMutation) {
		var (
			err   error
			once  sync.Once
			value *Campaign
		)
		m.oldValue = func(ctx context.Context) (*Campaign, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Campaign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaign sets the old Campaign of the mutation.
func withCampaign(node *Campaign) campaignOption {
	return func(m *CampaignMutation) {
		m.oldValue = func(context.Context) (*Campaign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Campaign entities.
func (m *CampaignMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Campaign.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CampaignMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CampaignMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CampaignMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CampaignMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CampaignMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CampaignMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[campaign.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CampaignMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[campaign.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CampaignMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, campaign.FieldDescription)
}

// SetUniqueCode sets the "unique_code" field.
func (m *CampaignMutation) SetUniqueCode(s string) {
	m.unique_code = &s
}

// UniqueCode returns the value of the "unique_code" field in the mutation.
func (m *CampaignMutation) UniqueCode() (r string, exists bool) {
	v := m.unique_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueCode returns the old "unique_code" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUniqueCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueCode: %w", err)
	}
	return oldValue.UniqueCode, nil
}

// ResetUniqueCode resets all changes to the "unique_code" field.
func (m *CampaignMutation) ResetUniqueCode() {
	m.unique_code = nil
}

// SetType sets the "type" field.
func (m *CampaignMutation) SetType(c campaign.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CampaignMutation) GetType() (r campaign.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldType(ctx context.Context) (v campaign.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CampaignMutation) ResetType() {
	m._type = nil
}

// SetCommissionType sets the "commission_type" field.
func (m *CampaignMutation) SetCommissionType(ct campaign.CommissionType) {
	m.commission_type = &ct
}

// CommissionType returns the value of the "commission_type" field in the mutation.
func (m *CampaignMutation) CommissionType() (r campaign.CommissionType, exists bool) {
	v := m.commission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionType returns the old "commission_type" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCommissionType(ctx context.Context) (v campaign.CommissionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionType: %w", err)
	}
	return oldValue.CommissionType, nil
}

// ResetCommissionType resets all changes to the "commission_type" field.
func (m *CampaignMutation) ResetCommissionType() {
	m.commission_type = nil
}

// SetBaseCommissionRate sets the "base_commission_rate" field.
func (m *CampaignMutation) SetBaseCommissionRate(f float64) {
	m.base_commission_rate = &f
	m.addbase_commission_rate = nil
}

// BaseCommissionRate returns the value of the "base_commission_rate" field in the mutation.
func (m *CampaignMutation) BaseCommissionRate() (r float64, exists bool) {
	v := m.base_commission_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseCommissionRate returns the old "base_commission_rate" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldBaseCommissionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseCommissionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseCommissionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseCommissionRate: %w", err)
	}
	return oldValue.BaseCommissionRate, nil
}

// AddBaseCommissionRate adds f to the "base_commission_rate" field.
func (m *CampaignMutation) AddBaseCommissionRate(f float64) {
	if m.addbase_commission_rate != nil {
		*m.addbase_commission_rate += f
	} else {
		m.addbase_commission_rate = &f
	}
}

// AddedBaseCommissionRate returns the value that was added to the "base_commission_rate" field in this mutation.
func (m *CampaignMutation) AddedBaseCommissionRate() (r float64, exists bool) {
	v := m.addbase_commission_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetBaseCommissionRate resets all changes to the "base_commission_rate" field.
func (m *CampaignMutation) ResetBaseCommissionRate() {
	m.base_commission_rate = nil
	m.addbase_commission_rate = nil
}

// SetCommissionTiers sets the "commission_tiers" field.
func (m *CampaignMutation) SetCommissionTiers(st []schema.CommissionTier) {
	m.commission_tiers = &st
	m.appendcommission_tiers = nil
}

// CommissionTiers returns the value of the "commission_tiers" field in the mutation.
func (m *CampaignMutation) CommissionTiers() (r []schema.CommissionTier, exists bool) {
	v := m.commission_tiers
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionTiers returns the old "commission_tiers" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCommissionTiers(ctx context.Context) (v []schema.CommissionTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionTiers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionTiers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionTiers: %w", err)
	}
	return oldValue.CommissionTiers, nil
}

// AppendCommissionTiers adds st to the "commission_tiers" field.
func (m *CampaignMutation) AppendCommissionTiers(st []schema.CommissionTier) {
	m.appendcommission_tiers = append(m.appendcommission_tiers, st...)
}

// AppendedCommissionTiers returns the list of values that were appended to the "commission_tiers" field in this mutation.
func (m *CampaignMutation) AppendedCommissionTiers() ([]schema.CommissionTier, bool) {
	if len(m.appendcommission_tiers) == 0 {
		return nil, false
	}
	return m.appendcommission_tiers, true
}

// ClearCommissionTiers clears the value of the "commission_tiers" field.
func (m *CampaignMutation) ClearCommissionTiers() {
	m.commission_tiers = nil
	m.appendcommission_tiers = nil
	m.clearedFields[campaign.FieldCommissionTiers] = struct{}{}
}

// CommissionTiersCleared returns if the "commission_tiers" field was cleared in this mutation.
func (m *CampaignMutation) CommissionTiersCleared() bool {
	_, ok := m.clearedFields[campaign.FieldCommissionTiers]
	return ok
}

// ResetCommissionTiers resets all changes to the "commission_tiers" field.
func (m *CampaignMutation) ResetCommissionTiers() {
	m.commission_tiers = nil
	m.appendcommission_tiers = nil
	delete(m.clearedFields, campaign.FieldCommissionTiers)
}

// SetTargetGeography sets the "target_geography" field.
func (m *CampaignMutation) SetTargetGeography(s string) {
	m.target_geography = &s
}

// TargetGeography returns the value of the "target_geography" field in the mutation.
func (m *CampaignMutation) TargetGeography() (r string, exists bool) {
	v := m.target_geography
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetGeography returns the old "target_geography" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTargetGeography(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetGeography is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetGeography requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetGeography: %w", err)
	}
	return oldValue.TargetGeography, nil
}

// ClearTargetGeography clears the value of the "target_geography" field.
func (m *CampaignMutation) ClearTargetGeography() {
	m.target_geography = nil
	m.clearedFields[campaign.FieldTargetGeography] = struct{}{}
}

// TargetGeographyCleared returns if the "target_geography" field was cleared in this mutation.
func (m *CampaignMutation) TargetGeographyCleared() bool {
	_, ok := m.clearedFields[campaign.FieldTargetGeography]
	return ok
}

// ResetTargetGeography resets all changes to the "target_geography" field.
func (m *CampaignMutation) ResetTargetGeography() {
	m.target_geography = nil
	delete(m.clearedFields, campaign.FieldTargetGeography)
}

// SetTargetDemographics sets the "target_demographics" field.
func (m *CampaignMutation) SetTargetDemographics(value map[string]interface{}) {
	m.target_demographics = &value
}

// TargetDemographics returns the value of the "target_demographics" field in the mutation.
func (m *CampaignMutation) TargetDemographics() (r map[string]interface{}, exists bool) {
	v := m.target_demographics
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDemographics returns the old "target_demographics" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTargetDemographics(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDemographics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDemographics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDemographics: %w", err)
	}
	return oldValue.TargetDemographics, nil
}

// ClearTargetDemographics clears the value of the "target_demographics" field.
func (m *CampaignMutation) ClearTargetDemographics() {
	m.target_demographics = nil
	m.clearedFields[campaign.FieldTargetDemographics] = struct{}{}
}

// TargetDemographicsCleared returns if the "target_demographics" field was cleared in this mutation.
func (m *CampaignMutation) TargetDemographicsCleared() bool {
	_, ok := m.clearedFields[campaign.FieldTargetDemographics]
	return ok
}

// ResetTargetDemographics resets all changes to the "target_demographics" field.
func (m *CampaignMutation) ResetTargetDemographics() {
	m.target_demographics = nil
	delete(m.clearedFields, campaign.FieldTargetDemographics)
}

// SetStartDate sets the "start_date" field.
func (m *CampaignMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *CampaignMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *CampaignMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *CampaignMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *CampaignMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *CampaignMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[campaign.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *CampaignMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[campaign.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *CampaignMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, campaign.FieldEndDate)
}

// SetStatus sets the "status" field.
func (m *CampaignMutation) SetStatus(c campaign.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CampaignMutation) Status() (r campaign.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldStatus(ctx context.Context) (v campaign.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CampaignMutation) ResetStatus() {
	m.status = nil
}

// SetTrackingURL sets the "tracking_url" field.
func (m *CampaignMutation) SetTrackingURL(s string) {
	m.tracking_url = &s
}

// TrackingURL returns the value of the "tracking_url" field in the mutation.
func (m *CampaignMutation) TrackingURL() (r string, exists bool) {
	v := m.tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingURL returns the old "tracking_url" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingURL: %w", err)
	}
	return oldValue.TrackingURL, nil
}

// ClearTrackingURL clears the value of the "tracking_url" field.
func (m *CampaignMutation) ClearTrackingURL() {
	m.tracking_url = nil
	m.clearedFields[campaign.FieldTrackingURL] = struct{}{}
}

// TrackingURLCleared returns if the "tracking_url" field was cleared in this mutation.
func (m *CampaignMutation) TrackingURLCleared() bool {
	_, ok := m.clearedFields[campaign.FieldTrackingURL]
	return ok
}

// ResetTrackingURL resets all changes to the "tracking_url" field.
func (m *CampaignMutation) ResetTrackingURL() {
	m.tracking_url = nil
	delete(m.clearedFields, campaign.FieldTrackingURL)
}

// SetTotalClicks sets the "total_clicks" field.
func (m *CampaignMutation) SetTotalClicks(i int) {
	m.total_clicks = &i
	m.addtotal_clicks = nil
}

// TotalClicks returns the value of the "total_clicks" field in the mutation.
func (m *CampaignMutation) TotalClicks() (r int, exists bool) {
	v := m.total_clicks
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalClicks returns the old "total_clicks" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTotalClicks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalClicks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalClicks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalClicks: %w", err)
	}
	return oldValue.TotalClicks, nil
}

// AddTotalClicks adds i to the "total_clicks" field.
func (m *CampaignMutation) AddTotalClicks(i int) {
	if m.addtotal_clicks != nil {
		*m.addtotal_clicks += i
	} else {
		m.addtotal_clicks = &i
	}
}

// AddedTotalClicks returns the value that was added to the "total_clicks" field in this mutation.
func (m *CampaignMutation) AddedTotalClicks() (r int, exists bool) {
	v := m.addtotal_clicks
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalClicks resets all changes to the "total_clicks" field.
func (m *CampaignMutation) ResetTotalClicks() {
	m.total_clicks = nil
	m.addtotal_clicks = nil
}

// SetTotalConversions sets the "total_conversions" field.
func (m *CampaignMutation) SetTotalConversions(i int) {
	m.total_conversions = &i
	m.addtotal_conversions = nil
}

// TotalConversions returns the value of the "total_conversions" field in the mutation.
func (m *CampaignMutation) TotalConversions() (r int, exists bool) {
	v := m.total_conversions
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalConversions returns the old "total_conversions" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTotalConversions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalConversions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalConversions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalConversions: %w", err)
	}
	return oldValue.TotalConversions, nil
}

// AddTotalConversions adds i to the "total_conversions" field.
func (m *CampaignMutation) AddTotalConversions(i int) {
	if m.addtotal_conversions != nil {
		*m.addtotal_conversions += i
	} else {
		m.addtotal_conversions = &i
	}
}

// AddedTotalConversions returns the value that was added to the "total_conversions" field in this mutation.
func (m *CampaignMutation) AddedTotalConversions() (r int, exists bool) {
	v := m.addtotal_conversions
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalConversions resets all changes to the "total_conversions" field.
func (m *CampaignMutation) ResetTotalConversions() {
	m.total_conversions = nil
	m.addtotal_conversions = nil
}

// SetTotalRevenue sets the "total_revenue" field.
func (m *CampaignMutation) SetTotalRevenue(f float64) {
	m.total_revenue = &f
	m.addtotal_revenue = nil
}

// TotalRevenue returns the value of the "total_revenue" field in the mutation.
func (m *CampaignMutation) TotalRevenue() (r float64, exists bool) {
	v := m.total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRevenue returns the old "total_revenue" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldTotalRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRevenue: %w", err)
	}
	return oldValue.TotalRevenue, nil
}

// AddTotalRevenue adds f to the "total_revenue" field.
func (m *CampaignMutation) AddTotalRevenue(f float64) {
	if m.addtotal_revenue != nil {
		*m.addtotal_revenue += f
	} else {
		m.addtotal_revenue = &f
	}
}

// AddedTotalRevenue returns the value that was added to the "total_revenue" field in this mutation.
func (m *CampaignMutation) AddedTotalRevenue() (r float64, exists bool) {
	v := m.addtotal_revenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRevenue resets all changes to the "total_revenue" field.
func (m *CampaignMutation) ResetTotalRevenue() {
	m.total_revenue = nil
	m.addtotal_revenue = nil
}

// SetConversionRate sets the "conversion_rate" field.
func (m *CampaignMutation) SetConversionRate(f float64) {
	m.conversion_rate = &f
	m.addconversion_rate = nil
}

// ConversionRate returns the value of the "conversion_rate" field in the mutation.
func (m *CampaignMutation) ConversionRate() (r float64, exists bool) {
	v := m.conversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldConversionRate returns the old "conversion_rate" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldConversionRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversionRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversionRate: %w", err)
	}
	return oldValue.ConversionRate, nil
}

// AddConversionRate adds f to the "conversion_rate" field.
func (m *CampaignMutation) AddConversionRate(f float64) {
	if m.addconversion_rate != nil {
		*m.addconversion_rate += f
	} else {
		m.addconversion_rate = &f
	}
}

// AddedConversionRate returns the value that was added to the "conversion_rate" field in this mutation.
func (m *CampaignMutation) AddedConversionRate() (r float64, exists bool) {
	v := m.addconversion_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetConversionRate resets all changes to the "conversion_rate" field.
func (m *CampaignMutation) ResetConversionRate() {
	m.conversion_rate = nil
	m.addconversion_rate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CampaignMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CampaignMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Campaign entity.
// If the Campaign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CampaignMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CampaignMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CampaignMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CampaignMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CampaignMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CampaignMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CampaignMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddLinkIDs adds the "links" edge to the CampaignLink entity by ids.
func (m *CampaignMutation) AddLinkIDs(ids ...int64) {
	if m.links == nil {
		m.links = make(map[int64]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the CampaignLink entity.
func (m *CampaignMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the CampaignLink entity was cleared.
func (m *CampaignMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the CampaignLink entity by IDs.
func (m *CampaignMutation) RemoveLinkIDs(ids ...int64) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the CampaignLink entity.
func (m *CampaignMutation) RemovedLinksIDs() (ids []int64) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *CampaignMutation) LinksIDs() (ids []int64) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *CampaignMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// AddBannerIDs adds the "banners" edge to the Banner entity by ids.
func (m *CampaignMutation) AddBannerIDs(ids ...int64) {
	if m.banners == nil {
		m.banners = make(map[int64]struct{})
	}
	for i := range ids {
		m.banners[ids[i]] = struct{}{}
	}
}

// ClearBanners clears the "banners" edge to the Banner entity.
func (m *CampaignMutation) ClearBanners() {
	m.clearedbanners = true
}

// BannersCleared reports if the "banners" edge to the Banner entity was cleared.
func (m *CampaignMutation) BannersCleared() bool {
	return m.clearedbanners
}

// RemoveBannerIDs removes the "banners" edge to the Banner entity by IDs.
func (m *CampaignMutation) RemoveBannerIDs(ids ...int64) {
	if m.removedbanners == nil {
		m.removedbanners = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.banners, ids[i])
		m.removedbanners[ids[i]] = struct{}{}
	}
}

// RemovedBanners returns the removed IDs of the "banners" edge to the Banner entity.
func (m *CampaignMutation) RemovedBannersIDs() (ids []int64) {
	for id := range m.removedbanners {
		ids = append(ids, id)
	}
	return
}

// BannersIDs returns the "banners" edge IDs in the mutation.
func (m *CampaignMutation) BannersIDs() (ids []int64) {
	for id := range m.banners {
		ids = append(ids, id)
	}
	return
}

// ResetBanners resets all changes to the "banners" edge.
func (m *CampaignMutation) ResetBanners() {
	m.banners = nil
	m.clearedbanners = false
	m.removedbanners = nil
}

// Where appends a list predicates to the CampaignMutation builder.
func (m *CampaignMutation) Where(ps ...predicate.Campaign) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Campaign, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Campaign).
func (m *CampaignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.name != nil {
		fields = append(fields, campaign.FieldName)
	}
	if m.description != nil {
		fields = append(fields, campaign.FieldDescription)
	}
	if m.unique_code != nil {
		fields = append(fields, campaign.FieldUniqueCode)
	}
	if m._type != nil {
		fields = append(fields, campaign.FieldType)
	}
	if m.commission_type != nil {
		fields = append(fields, campaign.FieldCommissionType)
	}
	if m.base_commission_rate != nil {
		fields = append(fields, campaign.FieldBaseCommissionRate)
	}
	if m.commission_tiers != nil {
		fields = append(fields, campaign.FieldCommissionTiers)
	}
	if m.target_geography != nil {
		fields = append(fields, campaign.FieldTargetGeography)
	}
	if m.target_demographics != nil {
		fields = append(fields, campaign.FieldTargetDemographics)
	}
	if m.start_date != nil {
		fields = append(fields, campaign.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, campaign.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, campaign.FieldStatus)
	}
	if m.tracking_url != nil {
		fields = append(fields, campaign.FieldTrackingURL)
	}
	if m.total_clicks != nil {
		fields = append(fields, campaign.FieldTotalClicks)
	}
	if m.total_conversions != nil {
		fields = append(fields, campaign.FieldTotalConversions)
	}
	if m.total_revenue != nil {
		fields = append(fields, campaign.FieldTotalRevenue)
	}
	if m.conversion_rate != nil {
		fields = append(fields, campaign.FieldConversionRate)
	}
	if m.created_at != nil {
		fields = append(fields, campaign.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, campaign.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldName:
		return m.Name()
	case campaign.FieldDescription:
		return m.Description()
	case campaign.FieldUniqueCode:
		return m.UniqueCode()
	case campaign.FieldType:
		return m.GetType()
	case campaign.FieldCommissionType:
		return m.CommissionType()
	case campaign.FieldBaseCommissionRate:
		return m.BaseCommissionRate()
	case campaign.FieldCommissionTiers:
		return m.CommissionTiers()
	case campaign.FieldTargetGeography:
		return m.TargetGeography()
	case campaign.FieldTargetDemographics:
		return m.TargetDemographics()
	case campaign.FieldStartDate:
		return m.StartDate()
	case campaign.FieldEndDate:
		return m.EndDate()
	case campaign.FieldStatus:
		return m.Status()
	case campaign.FieldTrackingURL:
		return m.TrackingURL()
	case campaign.FieldTotalClicks:
		return m.TotalClicks()
	case campaign.FieldTotalConversions:
		return m.TotalConversions()
	case campaign.FieldTotalRevenue:
		return m.TotalRevenue()
	case campaign.FieldConversionRate:
		return m.ConversionRate()
	case campaign.FieldCreatedAt:
		return m.CreatedAt()
	case campaign.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaign.FieldName:
		return m.OldName(ctx)
	case campaign.FieldDescription:
		return m.OldDescription(ctx)
	case campaign.FieldUniqueCode:
		return m.OldUniqueCode(ctx)
	case campaign.FieldType:
		return m.OldType(ctx)
	case campaign.FieldCommissionType:
		return m.OldCommissionType(ctx)
	case campaign.FieldBaseCommissionRate:
		return m.OldBaseCommissionRate(ctx)
	case campaign.FieldCommissionTiers:
		return m.OldCommissionTiers(ctx)
	case campaign.FieldTargetGeography:
		return m.OldTargetGeography(ctx)
	case campaign.FieldTargetDemographics:
		return m.OldTargetDemographics(ctx)
	case campaign.FieldStartDate:
		return m.OldStartDate(ctx)
	case campaign.FieldEndDate:
		return m.OldEndDate(ctx)
	case campaign.FieldStatus:
		return m.OldStatus(ctx)
	case campaign.FieldTrackingURL:
		return m.OldTrackingURL(ctx)
	case campaign.FieldTotalClicks:
		return m.OldTotalClicks(ctx)
	case campaign.FieldTotalConversions:
		return m.OldTotalConversions(ctx)
	case campaign.FieldTotalRevenue:
		return m.OldTotalRevenue(ctx)
	case campaign.FieldConversionRate:
		return m.OldConversionRate(ctx)
	case campaign.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaign.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Campaign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case campaign.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case campaign.FieldUniqueCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueCode(v)
		return nil
	case campaign.FieldType:
		v, ok := value.(campaign.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case campaign.FieldCommissionType:
		v, ok := value.(campaign.CommissionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionType(v)
		return nil
	case campaign.FieldBaseCommissionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseCommissionRate(v)
		return nil
	case campaign.FieldCommissionTiers:
		v, ok := value.([]schema.CommissionTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionTiers(v)
		return nil
	case campaign.FieldTargetGeography:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetGeography(v)
		return nil
	case campaign.FieldTargetDemographics:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDemographics(v)
		return nil
	case campaign.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case campaign.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case campaign.FieldStatus:
		v, ok := value.(campaign.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case campaign.FieldTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingURL(v)
		return nil
	case campaign.FieldTotalClicks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalClicks(v)
		return nil
	case campaign.FieldTotalConversions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalConversions(v)
		return nil
	case campaign.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRevenue(v)
		return nil
	case campaign.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversionRate(v)
		return nil
	case campaign.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaign.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignMutation) AddedFields() []string {
	var fields []string
	if m.addbase_commission_rate != nil {
		fields = append(fields, campaign.FieldBaseCommissionRate)
	}
	if m.addtotal_clicks != nil {
		fields = append(fields, campaign.FieldTotalClicks)
	}
	if m.addtotal_conversions != nil {
		fields = append(fields, campaign.FieldTotalConversions)
	}
	if m.addtotal_revenue != nil {
		fields = append(fields, campaign.FieldTotalRevenue)
	}
	if m.addconversion_rate != nil {
		fields = append(fields, campaign.FieldConversionRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case campaign.FieldBaseCommissionRate:
		return m.AddedBaseCommissionRate()
	case campaign.FieldTotalClicks:
		return m.AddedTotalClicks()
	case campaign.FieldTotalConversions:
		return m.AddedTotalConversions()
	case campaign.FieldTotalRevenue:
		return m.AddedTotalRevenue()
	case campaign.FieldConversionRate:
		return m.AddedConversionRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case campaign.FieldBaseCommissionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBaseCommissionRate(v)
		return nil
	case campaign.FieldTotalClicks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalClicks(v)
		return nil
	case campaign.FieldTotalConversions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalConversions(v)
		return nil
	case campaign.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRevenue(v)
		return nil
	case campaign.FieldConversionRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConversionRate(v)
		return nil
	}
	return fmt.Errorf("unknown Campaign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(campaign.FieldDescription) {
		fields = append(fields, campaign.FieldDescription)
	}
	if m.FieldCleared(campaign.FieldCommissionTiers) {
		fields = append(fields, campaign.FieldCommissionTiers)
	}
	if m.FieldCleared(campaign.FieldTargetGeography) {
		fields = append(fields, campaign.FieldTargetGeography)
	}
	if m.FieldCleared(campaign.FieldTargetDemographics) {
		fields = append(fields, campaign.FieldTargetDemographics)
	}
	if m.FieldCleared(campaign.FieldEndDate) {
		fields = append(fields, campaign.FieldEndDate)
	}
	if m.FieldCleared(campaign.FieldTrackingURL) {
		fields = append(fields, campaign.FieldTrackingURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignMutation) ClearField(name string) error {
	switch name {
	case campaign.FieldDescription:
		m.ClearDescription()
		return nil
	case campaign.FieldCommissionTiers:
		m.ClearCommissionTiers()
		return nil
	case campaign.FieldTargetGeography:
		m.ClearTargetGeography()
		return nil
	case campaign.FieldTargetDemographics:
		m.ClearTargetDemographics()
		return nil
	case campaign.FieldEndDate:
		m.ClearEndDate()
		return nil
	case campaign.FieldTrackingURL:
		m.ClearTrackingURL()
		return nil
	}
	return fmt.Errorf("unknown Campaign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignMutation) ResetField(name string) error {
	switch name {
	case campaign.FieldName:
		m.ResetName()
		return nil
	case campaign.FieldDescription:
		m.ResetDescription()
		return nil
	case campaign.FieldUniqueCode:
		m.ResetUniqueCode()
		return nil
	case campaign.FieldType:
		m.ResetType()
		return nil
	case campaign.FieldCommissionType:
		m.ResetCommissionType()
		return nil
	case campaign.FieldBaseCommissionRate:
		m.ResetBaseCommissionRate()
		return nil
	case campaign.FieldCommissionTiers:
		m.ResetCommissionTiers()
		return nil
	case campaign.FieldTargetGeography:
		m.ResetTargetGeography()
		return nil
	case campaign.FieldTargetDemographics:
		m.ResetTargetDemographics()
		return nil
	case campaign.FieldStartDate:
		m.ResetStartDate()
		return nil
	case campaign.FieldEndDate:
		m.ResetEndDate()
		return nil
	case campaign.FieldStatus:
		m.ResetStatus()
		return nil
	case campaign.FieldTrackingURL:
		m.ResetTrackingURL()
		return nil
	case campaign.FieldTotalClicks:
		m.ResetTotalClicks()
		return nil
	case campaign.FieldTotalConversions:
		m.ResetTotalConversions()
		return nil
	case campaign.FieldTotalRevenue:
		m.ResetTotalRevenue()
		return nil
	case campaign.FieldConversionRate:
		m.ResetConversionRate()
		return nil
	case campaign.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaign.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Campaign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, campaign.EdgeOwner)
	}
	if m.links != nil {
		edges = append(edges, campaign.EdgeLinks)
	}
	if m.banners != nil {
		edges = append(edges, campaign.EdgeBanners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case campaign.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.banners))
		for id := range m.banners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlinks != nil {
		edges = append(edges, campaign.EdgeLinks)
	}
	if m.removedbanners != nil {
		edges = append(edges, campaign.EdgeBanners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case campaign.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	case campaign.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.removedbanners))
		for id := range m.removedbanners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, campaign.EdgeOwner)
	}
	if m.clearedlinks {
		edges = append(edges, campaign.EdgeLinks)
	}
	if m.clearedbanners {
		edges = append(edges, campaign.EdgeBanners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignMutation) EdgeCleared(name string) bool {
	switch name {
	case campaign.EdgeOwner:
		return m.clearedowner
	case campaign.EdgeLinks:
		return m.clearedlinks
	case campaign.EdgeBanners:
		return m.clearedbanners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignMutation) ClearEdge(name string) error {
	switch name {
	case campaign.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Campaign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignMutation) ResetEdge(name string) error {
	switch name {
	case campaign.EdgeOwner:
		m.ResetOwner()
		return nil
	case campaign.EdgeLinks:
		m.ResetLinks()
		return nil
	case campaign.EdgeBanners:
		m.ResetBanners()
		return nil
	}
	return fmt.Errorf("unknown Campaign edge %s", name)
}

// CampaignLinkMutation represents an operation that mutates the CampaignLink nodes in the graph.
type CampaignLinkMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	unique_code     *string
	original_url    *string
	tracking_url    *string
	created_at      *time.Time
	is_active       *bool
	clearedFields   map[string]struct{}
	campaign        *int64
	clearedcampaign bool
	done            bool
	oldValue        func(context.Context) (*CampaignLink, error)
	predicates      []predicate.CampaignLink
}

var _ ent.Mutation = (*CampaignLinkMutation)(nil)

// campaignlinkOption allows management of the mutation configuration using functional options.
type campaignlinkOption func(*CampaignLinkMutation)

// newCampaignLinkMutation creates new mutation for the CampaignLink entity.
func newCampaignLinkMutation(c config, op Op, opts ...campaignlinkOption) *CampaignLinkMutation {
	m := &CampaignLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeCampaignLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCampaignLinkID sets the ID field of the mutation.
func withCampaignLinkID(id int64) campaignlinkOption {
	return func(m *CampaignLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *CampaignLink
		)
		m.oldValue = func(ctx context.Context) (*CampaignLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CampaignLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCampaignLink sets the old CampaignLink of the mutation.
func withCampaignLink(node *CampaignLink) campaignlinkOption {
	return func(m *CampaignLinkMutation) {
		m.oldValue = func(context.Context) (*CampaignLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CampaignLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CampaignLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CampaignLink entities.
func (m *CampaignLinkMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CampaignLinkMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CampaignLinkMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CampaignLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUniqueCode sets the "unique_code" field.
func (m *CampaignLinkMutation) SetUniqueCode(s string) {
	m.unique_code = &s
}

// UniqueCode returns the value of the "unique_code" field in the mutation.
func (m *CampaignLinkMutation) UniqueCode() (r string, exists bool) {
	v := m.unique_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueCode returns the old "unique_code" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldUniqueCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueCode: %w", err)
	}
	return oldValue.UniqueCode, nil
}

// ResetUniqueCode resets all changes to the "unique_code" field.
func (m *CampaignLinkMutation) ResetUniqueCode() {
	m.unique_code = nil
}

// SetOriginalURL sets the "original_url" field.
func (m *CampaignLinkMutation) SetOriginalURL(s string) {
	m.original_url = &s
}

// OriginalURL returns the value of the "original_url" field in the mutation.
func (m *CampaignLinkMutation) OriginalURL() (r string, exists bool) {
	v := m.original_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalURL returns the old "original_url" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldOriginalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalURL: %w", err)
	}
	return oldValue.OriginalURL, nil
}

// ResetOriginalURL resets all changes to the "original_url" field.
func (m *CampaignLinkMutation) ResetOriginalURL() {
	m.original_url = nil
}

// SetTrackingURL sets the "tracking_url" field.
func (m *CampaignLinkMutation) SetTrackingURL(s string) {
	m.tracking_url = &s
}

// TrackingURL returns the value of the "tracking_url" field in the mutation.
func (m *CampaignLinkMutation) TrackingURL() (r string, exists bool) {
	v := m.tracking_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingURL returns the old "tracking_url" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldTrackingURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingURL: %w", err)
	}
	return oldValue.TrackingURL, nil
}

// ResetTrackingURL resets all changes to the "tracking_url" field.
func (m *CampaignLinkMutation) ResetTrackingURL() {
	m.tracking_url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CampaignLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CampaignLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CampaignLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetIsActive sets the "is_active" field.
func (m *CampaignLinkMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CampaignLinkMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CampaignLink entity.
// If the CampaignLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CampaignLinkMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CampaignLinkMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCampaignID sets the "campaign" edge to the Campaign entity by id.
func (m *CampaignLinkMutation) SetCampaignID(id int64) {
	m.campaign = &id
}

// ClearCampaign clears the "campaign" edge to the Campaign entity.
func (m *CampaignLinkMutation) ClearCampaign() {
	m.clearedcampaign = true
}

// CampaignCleared reports if the "campaign" edge to the Campaign entity was cleared.
func (m *CampaignLinkMutation) CampaignCleared() bool {
	return m.clearedcampaign
}

// CampaignID returns the "campaign" edge ID in the mutation.
func (m *CampaignLinkMutation) CampaignID() (id int64, exists bool) {
	if m.campaign != nil {
		return *m.campaign, true
	}
	return
}

// CampaignIDs returns the "campaign" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CampaignID instead. It exists only for internal usage by the builders.
func (m *CampaignLinkMutation) CampaignIDs() (ids []int64) {
	if id := m.campaign; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCampaign resets all changes to the "campaign" edge.
func (m *CampaignLinkMutation) ResetCampaign() {
	m.campaign = nil
	m.clearedcampaign = false
}

// Where appends a list predicates to the CampaignLinkMutation builder.
func (m *CampaignLinkMutation) Where(ps ...predicate.CampaignLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CampaignLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CampaignLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CampaignLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CampaignLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CampaignLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CampaignLink).
func (m *CampaignLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CampaignLinkMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.unique_code != nil {
		fields = append(fields, campaignlink.FieldUniqueCode)
	}
	if m.original_url != nil {
		fields = append(fields, campaignlink.FieldOriginalURL)
	}
	if m.tracking_url != nil {
		fields = append(fields, campaignlink.FieldTrackingURL)
	}
	if m.created_at != nil {
		fields = append(fields, campaignlink.FieldCreatedAt)
	}
	if m.is_active != nil {
		fields = append(fields, campaignlink.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CampaignLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case campaignlink.FieldUniqueCode:
		return m.UniqueCode()
	case campaignlink.FieldOriginalURL:
		return m.OriginalURL()
	case campaignlink.FieldTrackingURL:
		return m.TrackingURL()
	case campaignlink.FieldCreatedAt:
		return m.CreatedAt()
	case campaignlink.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CampaignLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case campaignlink.FieldUniqueCode:
		return m.OldUniqueCode(ctx)
	case campaignlink.FieldOriginalURL:
		return m.OldOriginalURL(ctx)
	case campaignlink.FieldTrackingURL:
		return m.OldTrackingURL(ctx)
	case campaignlink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case campaignlink.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown CampaignLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case campaignlink.FieldUniqueCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueCode(v)
		return nil
	case campaignlink.FieldOriginalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalURL(v)
		return nil
	case campaignlink.FieldTrackingURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingURL(v)
		return nil
	case campaignlink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case campaignlink.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown CampaignLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CampaignLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CampaignLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CampaignLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CampaignLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CampaignLinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CampaignLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CampaignLinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CampaignLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CampaignLinkMutation) ResetField(name string) error {
	switch name {
	case campaignlink.FieldUniqueCode:
		m.ResetUniqueCode()
		return nil
	case campaignlink.FieldOriginalURL:
		m.ResetOriginalURL()
		return nil
	case campaignlink.FieldTrackingURL:
		m.ResetTrackingURL()
		return nil
	case campaignlink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case campaignlink.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown CampaignLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CampaignLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.campaign != nil {
		edges = append(edges, campaignlink.EdgeCampaign)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CampaignLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case campaignlink.EdgeCampaign:
		if id := m.campaign; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CampaignLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CampaignLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CampaignLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcampaign {
		edges = append(edges, campaignlink.EdgeCampaign)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CampaignLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case campaignlink.EdgeCampaign:
		return m.clearedcampaign
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CampaignLinkMutation) ClearEdge(name string) error {
	switch name {
	case campaignlink.EdgeCampaign:
		m.ClearCampaign()
		return nil
	}
	return fmt.Errorf("unknown CampaignLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CampaignLinkMutation) ResetEdge(name string) error {
	switch name {
	case campaignlink.EdgeCampaign:
		m.ResetCampaign()
		return nil
	}
	return fmt.Errorf("unknown CampaignLink edge %s", name)
}

// CommissionPlanMutation represents an operation that mutates the CommissionPlan nodes in the graph.
type CommissionPlanMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	description              *string
	_type                    *commissionplan.Type
	click_commission         *float64
	addclick_commission      *float64
	impression_commission    *float64
	addimpression_commission *float64
	lead_commission          *float64
	addlead_commission       *float64
	minimum_payout           *float64
	addminimum_payout        *float64
	valid_from               *time.Time
	valid_until              *time.Time
	is_active                *bool
	is_default               *bool
	clearedFields            map[string]struct{}
	publishers               map[int64]struct{}
	removedpublishers        map[int64]struct{}
	clearedpublishers        bool
	done                     bool
	oldValue                 func(context.Context) (*CommissionPlan, error)
	predicates               []predicate.CommissionPlan
}

var _ ent.Mutation = (*CommissionPlanMutation)(nil)

// commissionplanOption allows management of the mutation configuration using functional options.
type commissionplanOption func(*CommissionPlanMutation)

// newCommissionPlanMutation creates new mutation for the CommissionPlan entity.
func newCommissionPlanMutation(c config, op Op, opts ...commissionplanOption) *CommissionPlanMutation {
	m := &CommissionPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeCommissionPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommissionPlanID sets the ID field of the mutation.
func withCommissionPlanID(id int) commissionplanOption {
	return func(m *CommissionPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *CommissionPlan
		)
		m.oldValue = func(ctx context.Context) (*CommissionPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommissionPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommissionPlan sets the old CommissionPlan of the mutation.
func withCommissionPlan(node *CommissionPlan) commissionplanOption {
	return func(m *CommissionPlanMutation) {
		m.oldValue = func(context.Context) (*CommissionPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommissionPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommissionPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommissionPlanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommissionPlanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommissionPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CommissionPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommissionPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommissionPlanMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CommissionPlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommissionPlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommissionPlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[commissionplan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommissionPlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[commissionplan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommissionPlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, commissionplan.FieldDescription)
}

// SetType sets the "type" field.
func (m *CommissionPlanMutation) SetType(c commissionplan.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CommissionPlanMutation) GetType() (r commissionplan.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldType(ctx context.Context) (v commissionplan.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CommissionPlanMutation) ResetType() {
	m._type = nil
}

// SetClickCommission sets the "click_commission" field.
func (m *CommissionPlanMutation) SetClickCommission(f float64) {
	m.click_commission = &f
	m.addclick_commission = nil
}

// ClickCommission returns the value of the "click_commission" field in the mutation.
func (m *CommissionPlanMutation) ClickCommission() (r float64, exists bool) {
	v := m.click_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldClickCommission returns the old "click_commission" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldClickCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickCommission: %w", err)
	}
	return oldValue.ClickCommission, nil
}

// AddClickCommission adds f to the "click_commission" field.
func (m *CommissionPlanMutation) AddClickCommission(f float64) {
	if m.addclick_commission != nil {
		*m.addclick_commission += f
	} else {
		m.addclick_commission = &f
	}
}

// AddedClickCommission returns the value that was added to the "click_commission" field in this mutation.
func (m *CommissionPlanMutation) AddedClickCommission() (r float64, exists bool) {
	v := m.addclick_commission
	if v == nil {
		return
	}
	return *v, true
}

// ResetClickCommission resets all changes to the "click_commission" field.
func (m *CommissionPlanMutation) ResetClickCommission() {
	m.click_commission = nil
	m.addclick_commission = nil
}

// SetImpressionCommission sets the "impression_commission" field.
func (m *CommissionPlanMutation) SetImpressionCommission(f float64) {
	m.impression_commission = &f
	m.addimpression_commission = nil
}

// ImpressionCommission returns the value of the "impression_commission" field in the mutation.
func (m *CommissionPlanMutation) ImpressionCommission() (r float64, exists bool) {
	v := m.impression_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldImpressionCommission returns the old "impression_commission" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldImpressionCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImpressionCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImpressionCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImpressionCommission: %w", err)
	}
	return oldValue.ImpressionCommission, nil
}

// AddImpressionCommission adds f to the "impression_commission" field.
func (m *CommissionPlanMutation) AddImpressionCommission(f float64) {
	if m.addimpression_commission != nil {
		*m.addimpression_commission += f
	} else {
		m.addimpression_commission = &f
	}
}

// AddedImpressionCommission returns the value that was added to the "impression_commission" field in this mutation.
func (m *CommissionPlanMutation) AddedImpressionCommission() (r float64, exists bool) {
	v := m.addimpression_commission
	if v == nil {
		return
	}
	return *v, true
}

// ResetImpressionCommission resets all changes to the "impression_commission" field.
func (m *CommissionPlanMutation) ResetImpressionCommission() {
	m.impression_commission = nil
	m.addimpression_commission = nil
}

// SetLeadCommission sets the "lead_commission" field.
func (m *CommissionPlanMutation) SetLeadCommission(f float64) {
	m.lead_commission = &f
	m.addlead_commission = nil
}

// LeadCommission returns the value of the "lead_commission" field in the mutation.
func (m *CommissionPlanMutation) LeadCommission() (r float64, exists bool) {
	v := m.lead_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldLeadCommission returns the old "lead_commission" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldLeadCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeadCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeadCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeadCommission: %w", err)
	}
	return oldValue.LeadCommission, nil
}

// AddLeadCommission adds f to the "lead_commission" field.
func (m *CommissionPlanMutation) AddLeadCommission(f float64) {
	if m.addlead_commission != nil {
		*m.addlead_commission += f
	} else {
		m.addlead_commission = &f
	}
}

// AddedLeadCommission returns the value that was added to the "lead_commission" field in this mutation.
func (m *CommissionPlanMutation) AddedLeadCommission() (r float64, exists bool) {
	v := m.addlead_commission
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeadCommission resets all changes to the "lead_commission" field.
func (m *CommissionPlanMutation) ResetLeadCommission() {
	m.lead_commission = nil
	m.addlead_commission = nil
}

// SetMinimumPayout sets the "minimum_payout" field.
func (m *CommissionPlanMutation) SetMinimumPayout(f float64) {
	m.minimum_payout = &f
	m.addminimum_payout = nil
}

// MinimumPayout returns the value of the "minimum_payout" field in the mutation.
func (m *CommissionPlanMutation) MinimumPayout() (r float64, exists bool) {
	v := m.minimum_payout
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumPayout returns the old "minimum_payout" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldMinimumPayout(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumPayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumPayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumPayout: %w", err)
	}
	return oldValue.MinimumPayout, nil
}

// AddMinimumPayout adds f to the "minimum_payout" field.
func (m *CommissionPlanMutation) AddMinimumPayout(f float64) {
	if m.addminimum_payout != nil {
		*m.addminimum_payout += f
	} else {
		m.addminimum_payout = &f
	}
}

// AddedMinimumPayout returns the value that was added to the "minimum_payout" field in this mutation.
func (m *CommissionPlanMutation) AddedMinimumPayout() (r float64, exists bool) {
	v := m.addminimum_payout
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinimumPayout resets all changes to the "minimum_payout" field.
func (m *CommissionPlanMutation) ResetMinimumPayout() {
	m.minimum_payout = nil
	m.addminimum_payout = nil
}

// SetValidFrom sets the "valid_from" field.
func (m *CommissionPlanMutation) SetValidFrom(t time.Time) {
	m.valid_from = &t
}

// ValidFrom returns the value of the "valid_from" field in the mutation.
func (m *CommissionPlanMutation) ValidFrom() (r time.Time, exists bool) {
	v := m.valid_from
	if v == nil {
		return
	}
	return *v, true
}

// OldValidFrom returns the old "valid_from" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldValidFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidFrom: %w", err)
	}
	return oldValue.ValidFrom, nil
}

// ClearValidFrom clears the value of the "valid_from" field.
func (m *CommissionPlanMutation) ClearValidFrom() {
	m.valid_from = nil
	m.clearedFields[commissionplan.FieldValidFrom] = struct{}{}
}

// ValidFromCleared returns if the "valid_from" field was cleared in this mutation.
func (m *CommissionPlanMutation) ValidFromCleared() bool {
	_, ok := m.clearedFields[commissionplan.FieldValidFrom]
	return ok
}

// ResetValidFrom resets all changes to the "valid_from" field.
func (m *CommissionPlanMutation) ResetValidFrom() {
	m.valid_from = nil
	delete(m.clearedFields, commissionplan.FieldValidFrom)
}

// SetValidUntil sets the "valid_until" field.
func (m *CommissionPlanMutation) SetValidUntil(t time.Time) {
	m.valid_until = &t
}

// ValidUntil returns the value of the "valid_until" field in the mutation.
func (m *CommissionPlanMutation) ValidUntil() (r time.Time, exists bool) {
	v := m.valid_until
	if v == nil {
		return
	}
	return *v, true
}

// OldValidUntil returns the old "valid_until" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldValidUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidUntil: %w", err)
	}
	return oldValue.ValidUntil, nil
}

// ClearValidUntil clears the value of the "valid_until" field.
func (m *CommissionPlanMutation) ClearValidUntil() {
	m.valid_until = nil
	m.clearedFields[commissionplan.FieldValidUntil] = struct{}{}
}

// ValidUntilCleared returns if the "valid_until" field was cleared in this mutation.
func (m *CommissionPlanMutation) ValidUntilCleared() bool {
	_, ok := m.clearedFields[commissionplan.FieldValidUntil]
	return ok
}

// ResetValidUntil resets all changes to the "valid_until" field.
func (m *CommissionPlanMutation) ResetValidUntil() {
	m.valid_until = nil
	delete(m.clearedFields, commissionplan.FieldValidUntil)
}

// SetIsActive sets the "is_active" field.
func (m *CommissionPlanMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CommissionPlanMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CommissionPlanMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsDefault sets the "is_default" field.
func (m *CommissionPlanMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *CommissionPlanMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the CommissionPlan entity.
// If the CommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionPlanMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *CommissionPlanMutation) ResetIsDefault() {
	m.is_default = nil
}

// AddPublisherIDs adds the "publishers" edge to the User entity by ids.
func (m *CommissionPlanMutation) AddPublisherIDs(ids ...int64) {
	if m.publishers == nil {
		m.publishers = make(map[int64]struct{})
	}
	for i := range ids {
		m.publishers[ids[i]] = struct{}{}
	}
}

// ClearPublishers clears the "publishers" edge to the User entity.
func (m *CommissionPlanMutation) ClearPublishers() {
	m.clearedpublishers = true
}

// PublishersCleared reports if the "publishers" edge to the User entity was cleared.
func (m *CommissionPlanMutation) PublishersCleared() bool {
	return m.clearedpublishers
}

// RemovePublisherIDs removes the "publishers" edge to the User entity by IDs.
func (m *CommissionPlanMutation) RemovePublisherIDs(ids ...int64) {
	if m.removedpublishers == nil {
		m.removedpublishers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.publishers, ids[i])
		m.removedpublishers[ids[i]] = struct{}{}
	}
}

// RemovedPublishers returns the removed IDs of the "publishers" edge to the User entity.
func (m *CommissionPlanMutation) RemovedPublishersIDs() (ids []int64) {
	for id := range m.removedpublishers {
		ids = append(ids, id)
	}
	return
}

// PublishersIDs returns the "publishers" edge IDs in the mutation.
func (m *CommissionPlanMutation) PublishersIDs() (ids []int64) {
	for id := range m.publishers {
		ids = append(ids, id)
	}
	return
}

// ResetPublishers resets all changes to the "publishers" edge.
func (m *CommissionPlanMutation) ResetPublishers() {
	m.publishers = nil
	m.clearedpublishers = false
	m.removedpublishers = nil
}

// Where appends a list predicates to the CommissionPlanMutation builder.
func (m *CommissionPlanMutation) Where(ps ...predicate.CommissionPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommissionPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommissionPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommissionPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommissionPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommissionPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommissionPlan).
func (m *CommissionPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommissionPlanMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, commissionplan.FieldName)
	}
	if m.description != nil {
		fields = append(fields, commissionplan.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, commissionplan.FieldType)
	}
	if m.click_commission != nil {
		fields = append(fields, commissionplan.FieldClickCommission)
	}
	if m.impression_commission != nil {
		fields = append(fields, commissionplan.FieldImpressionCommission)
	}
	if m.lead_commission != nil {
		fields = append(fields, commissionplan.FieldLeadCommission)
	}
	if m.minimum_payout != nil {
		fields = append(fields, commissionplan.FieldMinimumPayout)
	}
	if m.valid_from != nil {
		fields = append(fields, commissionplan.FieldValidFrom)
	}
	if m.valid_until != nil {
		fields = append(fields, commissionplan.FieldValidUntil)
	}
	if m.is_active != nil {
		fields = append(fields, commissionplan.FieldIsActive)
	}
	if m.is_default != nil {
		fields = append(fields, commissionplan.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommissionPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commissionplan.FieldName:
		return m.Name()
	case commissionplan.FieldDescription:
		return m.Description()
	case commissionplan.FieldType:
		return m.GetType()
	case commissionplan.FieldClickCommission:
		return m.ClickCommission()
	case commissionplan.FieldImpressionCommission:
		return m.ImpressionCommission()
	case commissionplan.FieldLeadCommission:
		return m.LeadCommission()
	case commissionplan.FieldMinimumPayout:
		return m.MinimumPayout()
	case commissionplan.FieldValidFrom:
		return m.ValidFrom()
	case commissionplan.FieldValidUntil:
		return m.ValidUntil()
	case commissionplan.FieldIsActive:
		return m.IsActive()
	case commissionplan.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommissionPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commissionplan.FieldName:
		return m.OldName(ctx)
	case commissionplan.FieldDescription:
		return m.OldDescription(ctx)
	case commissionplan.FieldType:
		return m.OldType(ctx)
	case commissionplan.FieldClickCommission:
		return m.OldClickCommission(ctx)
	case commissionplan.FieldImpressionCommission:
		return m.OldImpressionCommission(ctx)
	case commissionplan.FieldLeadCommission:
		return m.OldLeadCommission(ctx)
	case commissionplan.FieldMinimumPayout:
		return m.OldMinimumPayout(ctx)
	case commissionplan.FieldValidFrom:
		return m.OldValidFrom(ctx)
	case commissionplan.FieldValidUntil:
		return m.OldValidUntil(ctx)
	case commissionplan.FieldIsActive:
		return m.OldIsActive(ctx)
	case commissionplan.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown CommissionPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commissionplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case commissionplan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case commissionplan.FieldType:
		v, ok := value.(commissionplan.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case commissionplan.FieldClickCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickCommission(v)
		return nil
	case commissionplan.FieldImpressionCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImpressionCommission(v)
		return nil
	case commissionplan.FieldLeadCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeadCommission(v)
		return nil
	case commissionplan.FieldMinimumPayout:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumPayout(v)
		return nil
	case commissionplan.FieldValidFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidFrom(v)
		return nil
	case commissionplan.FieldValidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidUntil(v)
		return nil
	case commissionplan.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case commissionplan.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown CommissionPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommissionPlanMutation) AddedFields() []string {
	var fields []string
	if m.addclick_commission != nil {
		fields = append(fields, commissionplan.FieldClickCommission)
	}
	if m.addimpression_commission != nil {
		fields = append(fields, commissionplan.FieldImpressionCommission)
	}
	if m.addlead_commission != nil {
		fields = append(fields, commissionplan.FieldLeadCommission)
	}
	if m.addminimum_payout != nil {
		fields = append(fields, commissionplan.FieldMinimumPayout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommissionPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commissionplan.FieldClickCommission:
		return m.AddedClickCommission()
	case commissionplan.FieldImpressionCommission:
		return m.AddedImpressionCommission()
	case commissionplan.FieldLeadCommission:
		return m.AddedLeadCommission()
	case commissionplan.FieldMinimumPayout:
		return m.AddedMinimumPayout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commissionplan.FieldClickCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClickCommission(v)
		return nil
	case commissionplan.FieldImpressionCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImpressionCommission(v)
		return nil
	case commissionplan.FieldLeadCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeadCommission(v)
		return nil
	case commissionplan.FieldMinimumPayout:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinimumPayout(v)
		return nil
	}
	return fmt.Errorf("unknown CommissionPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommissionPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commissionplan.FieldDescription) {
		fields = append(fields, commissionplan.FieldDescription)
	}
	if m.FieldCleared(commissionplan.FieldValidFrom) {
		fields = append(fields, commissionplan.FieldValidFrom)
	}
	if m.FieldCleared(commissionplan.FieldValidUntil) {
		fields = append(fields, commissionplan.FieldValidUntil)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommissionPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommissionPlanMutation) ClearField(name string) error {
	switch name {
	case commissionplan.FieldDescription:
		m.ClearDescription()
		return nil
	case commissionplan.FieldValidFrom:
		m.ClearValidFrom()
		return nil
	case commissionplan.FieldValidUntil:
		m.ClearValidUntil()
		return nil
	}
	return fmt.Errorf("unknown CommissionPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommissionPlanMutation) ResetField(name string) error {
	switch name {
	case commissionplan.FieldName:
		m.ResetName()
		return nil
	case commissionplan.FieldDescription:
		m.ResetDescription()
		return nil
	case commissionplan.FieldType:
		m.ResetType()
		return nil
	case commissionplan.FieldClickCommission:
		m.ResetClickCommission()
		return nil
	case commissionplan.FieldImpressionCommission:
		m.ResetImpressionCommission()
		return nil
	case commissionplan.FieldLeadCommission:
		m.ResetLeadCommission()
		return nil
	case commissionplan.FieldMinimumPayout:
		m.ResetMinimumPayout()
		return nil
	case commissionplan.FieldValidFrom:
		m.ResetValidFrom()
		return nil
	case commissionplan.FieldValidUntil:
		m.ResetValidUntil()
		return nil
	case commissionplan.FieldIsActive:
		m.ResetIsActive()
		return nil
	case commissionplan.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown CommissionPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommissionPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.publishers != nil {
		edges = append(edges, commissionplan.EdgePublishers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommissionPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commissionplan.EdgePublishers:
		ids := make([]ent.Value, 0, len(m.publishers))
		for id := range m.publishers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommissionPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpublishers != nil {
		edges = append(edges, commissionplan.EdgePublishers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommissionPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case commissionplan.EdgePublishers:
		ids := make([]ent.Value, 0, len(m.removedpublishers))
		for id := range m.removedpublishers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommissionPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpublishers {
		edges = append(edges, commissionplan.EdgePublishers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommissionPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case commissionplan.EdgePublishers:
		return m.clearedpublishers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommissionPlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CommissionPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommissionPlanMutation) ResetEdge(name string) error {
	switch name {
	case commissionplan.EdgePublishers:
		m.ResetPublishers()
		return nil
	}
	return fmt.Errorf("unknown CommissionPlan edge %s", name)
}

// CreativeMutation represents an operation that mutates the Creative nodes in the graph.
type CreativeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	image_url               *string
	size                    *string
	enabled                 *bool
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	banners                 map[int64]struct{}
	removedbanners          map[int64]struct{}
	clearedbanners          bool
	banner_creatives        map[int]struct{}
	removedbanner_creatives map[int]struct{}
	clearedbanner_creatives bool
	done                    bool
	oldValue                func(context.Context) (*Creative, error)
	predicates              []predicate.Creative
}

var _ ent.Mutation = (*CreativeMutation)(nil)

// creativeOption allows management of the mutation configuration using functional options.
type creativeOption func(*CreativeMutation)

// newCreativeMutation creates new mutation for the Creative entity.
func newCreativeMutation(c config, op Op, opts ...creativeOption) *CreativeMutation {
	m := &CreativeMutation{
		config:        c,
		op:            op,
		typ:           TypeCreative,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreativeID sets the ID field of the mutation.
func withCreativeID(id int64) creativeOption {
	return func(m *CreativeMutation) {
		var (
			err   error
			once  sync.Once
			value *Creative
		)
		m.oldValue = func(ctx context.Context) (*Creative, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Creative.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreative sets the old Creative of the mutation.
func withCreative(node *Creative) creativeOption {
	return func(m *CreativeMutation) {
		m.oldValue = func(context.Context) (*Creative, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreativeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreativeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Creative entities.
func (m *CreativeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreativeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreativeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Creative.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CreativeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CreativeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Creative entity.
// If the Creative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreativeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CreativeMutation) ClearName() {
	m.name = nil
	m.clearedFields[creative.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CreativeMutation) NameCleared() bool {
	_, ok := m.clearedFields[creative.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CreativeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, creative.FieldName)
}

// SetImageURL sets the "image_url" field.
func (m *CreativeMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *CreativeMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Creative entity.
// If the Creative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreativeMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *CreativeMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[creative.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *CreativeMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[creative.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *CreativeMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, creative.FieldImageURL)
}

// SetSize sets the "size" field.
func (m *CreativeMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *CreativeMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Creative entity.
// If the Creative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreativeMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ClearSize clears the value of the "size" field.
func (m *CreativeMutation) ClearSize() {
	m.size = nil
	m.clearedFields[creative.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *CreativeMutation) SizeCleared() bool {
	_, ok := m.clearedFields[creative.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *CreativeMutation) ResetSize() {
	m.size = nil
	delete(m.clearedFields, creative.FieldSize)
}

// SetEnabled sets the "enabled" field.
func (m *CreativeMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *CreativeMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Creative entity.
// If the Creative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreativeMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *CreativeMutation) ResetEnabled() {
	m.enabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CreativeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreativeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Creative entity.
// If the Creative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreativeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreativeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CreativeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CreativeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Creative entity.
// If the Creative object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreativeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CreativeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBannerIDs adds the "banners" edge to the Banner entity by ids.
func (m *CreativeMutation) AddBannerIDs(ids ...int64) {
	if m.banners == nil {
		m.banners = make(map[int64]struct{})
	}
	for i := range ids {
		m.banners[ids[i]] = struct{}{}
	}
}

// ClearBanners clears the "banners" edge to the Banner entity.
func (m *CreativeMutation) ClearBanners() {
	m.clearedbanners = true
}

// BannersCleared reports if the "banners" edge to the Banner entity was cleared.
func (m *CreativeMutation) BannersCleared() bool {
	return m.clearedbanners
}

// RemoveBannerIDs removes the "banners" edge to the Banner entity by IDs.
func (m *CreativeMutation) RemoveBannerIDs(ids ...int64) {
	if m.removedbanners == nil {
		m.removedbanners = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.banners, ids[i])
		m.removedbanners[ids[i]] = struct{}{}
	}
}

// RemovedBanners returns the removed IDs of the "banners" edge to the Banner entity.
func (m *CreativeMutation) RemovedBannersIDs() (ids []int64) {
	for id := range m.removedbanners {
		ids = append(ids, id)
	}
	return
}

// BannersIDs returns the "banners" edge IDs in the mutation.
func (m *CreativeMutation) BannersIDs() (ids []int64) {
	for id := range m.banners {
		ids = append(ids, id)
	}
	return
}

// ResetBanners resets all changes to the "banners" edge.
func (m *CreativeMutation) ResetBanners() {
	m.banners = nil
	m.clearedbanners = false
	m.removedbanners = nil
}

// AddBannerCreativeIDs adds the "banner_creatives" edge to the BannerCreative entity by ids.
func (m *CreativeMutation) AddBannerCreativeIDs(ids ...int) {
	if m.banner_creatives == nil {
		m.banner_creatives = make(map[int]struct{})
	}
	for i := range ids {
		m.banner_creatives[ids[i]] = struct{}{}
	}
}

// ClearBannerCreatives clears the "banner_creatives" edge to the BannerCreative entity.
func (m *CreativeMutation) ClearBannerCreatives() {
	m.clearedbanner_creatives = true
}

// BannerCreativesCleared reports if the "banner_creatives" edge to the BannerCreative entity was cleared.
func (m *CreativeMutation) BannerCreativesCleared() bool {
	return m.clearedbanner_creatives
}

// RemoveBannerCreativeIDs removes the "banner_creatives" edge to the BannerCreative entity by IDs.
func (m *CreativeMutation) RemoveBannerCreativeIDs(ids ...int) {
	if m.removedbanner_creatives == nil {
		m.removedbanner_creatives = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.banner_creatives, ids[i])
		m.removedbanner_creatives[ids[i]] = struct{}{}
	}
}

// RemovedBannerCreatives returns the removed IDs of the "banner_creatives" edge to the BannerCreative entity.
func (m *CreativeMutation) RemovedBannerCreativesIDs() (ids []int) {
	for id := range m.removedbanner_creatives {
		ids = append(ids, id)
	}
	return
}

// BannerCreativesIDs returns the "banner_creatives" edge IDs in the mutation.
func (m *CreativeMutation) BannerCreativesIDs() (ids []int) {
	for id := range m.banner_creatives {
		ids = append(ids, id)
	}
	return
}

// ResetBannerCreatives resets all changes to the "banner_creatives" edge.
func (m *CreativeMutation) ResetBannerCreatives() {
	m.banner_creatives = nil
	m.clearedbanner_creatives = false
	m.removedbanner_creatives = nil
}

// Where appends a list predicates to the CreativeMutation builder.
func (m *CreativeMutation) Where(ps ...predicate.Creative) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreativeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreativeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Creative, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreativeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreativeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Creative).
func (m *CreativeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreativeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, creative.FieldName)
	}
	if m.image_url != nil {
		fields = append(fields, creative.FieldImageURL)
	}
	if m.size != nil {
		fields = append(fields, creative.FieldSize)
	}
	if m.enabled != nil {
		fields = append(fields, creative.FieldEnabled)
	}
	if m.created_at != nil {
		fields = append(fields, creative.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, creative.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreativeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case creative.FieldName:
		return m.Name()
	case creative.FieldImageURL:
		return m.ImageURL()
	case creative.FieldSize:
		return m.Size()
	case creative.FieldEnabled:
		return m.Enabled()
	case creative.FieldCreatedAt:
		return m.CreatedAt()
	case creative.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreativeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case creative.FieldName:
		return m.OldName(ctx)
	case creative.FieldImageURL:
		return m.OldImageURL(ctx)
	case creative.FieldSize:
		return m.OldSize(ctx)
	case creative.FieldEnabled:
		return m.OldEnabled(ctx)
	case creative.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case creative.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Creative field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreativeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case creative.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case creative.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case creative.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case creative.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case creative.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case creative.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Creative field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreativeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreativeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreativeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Creative numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreativeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(creative.FieldName) {
		fields = append(fields, creative.FieldName)
	}
	if m.FieldCleared(creative.FieldImageURL) {
		fields = append(fields, creative.FieldImageURL)
	}
	if m.FieldCleared(creative.FieldSize) {
		fields = append(fields, creative.FieldSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreativeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreativeMutation) ClearField(name string) error {
	switch name {
	case creative.FieldName:
		m.ClearName()
		return nil
	case creative.FieldImageURL:
		m.ClearImageURL()
		return nil
	case creative.FieldSize:
		m.ClearSize()
		return nil
	}
	return fmt.Errorf("unknown Creative nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreativeMutation) ResetField(name string) error {
	switch name {
	case creative.FieldName:
		m.ResetName()
		return nil
	case creative.FieldImageURL:
		m.ResetImageURL()
		return nil
	case creative.FieldSize:
		m.ResetSize()
		return nil
	case creative.FieldEnabled:
		m.ResetEnabled()
		return nil
	case creative.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case creative.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Creative field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreativeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.banners != nil {
		edges = append(edges, creative.EdgeBanners)
	}
	if m.banner_creatives != nil {
		edges = append(edges, creative.EdgeBannerCreatives)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreativeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case creative.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.banners))
		for id := range m.banners {
			ids = append(ids, id)
		}
		return ids
	case creative.EdgeBannerCreatives:
		ids := make([]ent.Value, 0, len(m.banner_creatives))
		for id := range m.banner_creatives {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreativeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbanners != nil {
		edges = append(edges, creative.EdgeBanners)
	}
	if m.removedbanner_creatives != nil {
		edges = append(edges, creative.EdgeBannerCreatives)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreativeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case creative.EdgeBanners:
		ids := make([]ent.Value, 0, len(m.removedbanners))
		for id := range m.removedbanners {
			ids = append(ids, id)
		}
		return ids
	case creative.EdgeBannerCreatives:
		ids := make([]ent.Value, 0, len(m.removedbanner_creatives))
		for id := range m.removedbanner_creatives {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreativeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbanners {
		edges = append(edges, creative.EdgeBanners)
	}
	if m.clearedbanner_creatives {
		edges = append(edges, creative.EdgeBannerCreatives)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreativeMutation) EdgeCleared(name string) bool {
	switch name {
	case creative.EdgeBanners:
		return m.clearedbanners
	case creative.EdgeBannerCreatives:
		return m.clearedbanner_creatives
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreativeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Creative unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreativeMutation) ResetEdge(name string) error {
	switch name {
	case creative.EdgeBanners:
		m.ResetBanners()
		return nil
	case creative.EdgeBannerCreatives:
		m.ResetBannerCreatives()
		return nil
	}
	return fmt.Errorf("unknown Creative edge %s", name)
}

// GigTrackingMutation represents an operation that mutates the GigTracking nodes in the graph.
type GigTrackingMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	date             *time.Time
	_type            *string
	utm_query        *string
	lp               *string
	track_id         *string
	revenue          *float64
	addrevenue       *float64
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	publisher        *int64
	clearedpublisher bool
	done             bool
	oldValue         func(context.Context) (*GigTracking, error)
	predicates       []predicate.GigTracking
}

var _ ent.Mutation = (*GigTrackingMutation)(nil)

// gigtrackingOption allows management of the mutation configuration using functional options.
type gigtrackingOption func(*GigTrackingMutation)

// newGigTrackingMutation creates new mutation for the GigTracking entity.
func newGigTrackingMutation(c config, op Op, opts ...gigtrackingOption) *GigTrackingMutation {
	m := &GigTrackingMutation{
		config:        c,
		op:            op,
		typ:           TypeGigTracking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGigTrackingID sets the ID field of the mutation.
func withGigTrackingID(id int64) gigtrackingOption {
	return func(m *GigTrackingMutation) {
		var (
			err   error
			once  sync.Once
			value *GigTracking
		)
		m.oldValue = func(ctx context.Context) (*GigTracking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GigTracking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGigTracking sets the old GigTracking of the mutation.
func withGigTracking(node *GigTracking) gigtrackingOption {
	return func(m *GigTrackingMutation) {
		m.oldValue = func(context.Context) (*GigTracking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GigTrackingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GigTrackingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GigTracking entities.
func (m *GigTrackingMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GigTrackingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GigTrackingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GigTracking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *GigTrackingMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *GigTrackingMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *GigTrackingMutation) ResetDate() {
	m.date = nil
}

// SetType sets the "type" field.
func (m *GigTrackingMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *GigTrackingMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *GigTrackingMutation) ResetType() {
	m._type = nil
}

// SetUtmQuery sets the "utm_query" field.
func (m *GigTrackingMutation) SetUtmQuery(s string) {
	m.utm_query = &s
}

// UtmQuery returns the value of the "utm_query" field in the mutation.
func (m *GigTrackingMutation) UtmQuery() (r string, exists bool) {
	v := m.utm_query
	if v == nil {
		return
	}
	return *v, true
}

// OldUtmQuery returns the old "utm_query" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldUtmQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUtmQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUtmQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUtmQuery: %w", err)
	}
	return oldValue.UtmQuery, nil
}

// ClearUtmQuery clears the value of the "utm_query" field.
func (m *GigTrackingMutation) ClearUtmQuery() {
	m.utm_query = nil
	m.clearedFields[gigtracking.FieldUtmQuery] = struct{}{}
}

// UtmQueryCleared returns if the "utm_query" field was cleared in this mutation.
func (m *GigTrackingMutation) UtmQueryCleared() bool {
	_, ok := m.clearedFields[gigtracking.FieldUtmQuery]
	return ok
}

// ResetUtmQuery resets all changes to the "utm_query" field.
func (m *GigTrackingMutation) ResetUtmQuery() {
	m.utm_query = nil
	delete(m.clearedFields, gigtracking.FieldUtmQuery)
}

// SetLp sets the "lp" field.
func (m *GigTrackingMutation) SetLp(s string) {
	m.lp = &s
}

// Lp returns the value of the "lp" field in the mutation.
func (m *GigTrackingMutation) Lp() (r string, exists bool) {
	v := m.lp
	if v == nil {
		return
	}
	return *v, true
}

// OldLp returns the old "lp" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldLp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLp: %w", err)
	}
	return oldValue.Lp, nil
}

// ClearLp clears the value of the "lp" field.
func (m *GigTrackingMutation) ClearLp() {
	m.lp = nil
	m.clearedFields[gigtracking.FieldLp] = struct{}{}
}

// LpCleared returns if the "lp" field was cleared in this mutation.
func (m *GigTrackingMutation) LpCleared() bool {
	_, ok := m.clearedFields[gigtracking.FieldLp]
	return ok
}

// ResetLp resets all changes to the "lp" field.
func (m *GigTrackingMutation) ResetLp() {
	m.lp = nil
	delete(m.clearedFields, gigtracking.FieldLp)
}

// SetTrackID sets the "track_id" field.
func (m *GigTrackingMutation) SetTrackID(s string) {
	m.track_id = &s
}

// TrackID returns the value of the "track_id" field in the mutation.
func (m *GigTrackingMutation) TrackID() (r string, exists bool) {
	v := m.track_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackID returns the old "track_id" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldTrackID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackID: %w", err)
	}
	return oldValue.TrackID, nil
}

// ClearTrackID clears the value of the "track_id" field.
func (m *GigTrackingMutation) ClearTrackID() {
	m.track_id = nil
	m.clearedFields[gigtracking.FieldTrackID] = struct{}{}
}

// TrackIDCleared returns if the "track_id" field was cleared in this mutation.
func (m *GigTrackingMutation) TrackIDCleared() bool {
	_, ok := m.clearedFields[gigtracking.FieldTrackID]
	return ok
}

// ResetTrackID resets all changes to the "track_id" field.
func (m *GigTrackingMutation) ResetTrackID() {
	m.track_id = nil
	delete(m.clearedFields, gigtracking.FieldTrackID)
}

// SetRevenue sets the "revenue" field.
func (m *GigTrackingMutation) SetRevenue(f float64) {
	m.revenue = &f
	m.addrevenue = nil
}

// Revenue returns the value of the "revenue" field in the mutation.
func (m *GigTrackingMutation) Revenue() (r float64, exists bool) {
	v := m.revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenue returns the old "revenue" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenue: %w", err)
	}
	return oldValue.Revenue, nil
}

// AddRevenue adds f to the "revenue" field.
func (m *GigTrackingMutation) AddRevenue(f float64) {
	if m.addrevenue != nil {
		*m.addrevenue += f
	} else {
		m.addrevenue = &f
	}
}

// AddedRevenue returns the value that was added to the "revenue" field in this mutation.
func (m *GigTrackingMutation) AddedRevenue() (r float64, exists bool) {
	v := m.addrevenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevenue resets all changes to the "revenue" field.
func (m *GigTrackingMutation) ResetRevenue() {
	m.revenue = nil
	m.addrevenue = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GigTrackingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GigTrackingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GigTrackingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GigTrackingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GigTrackingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GigTracking entity.
// If the GigTracking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GigTrackingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GigTrackingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPublisherID sets the "publisher" edge to the User entity by id.
func (m *GigTrackingMutation) SetPublisherID(id int64) {
	m.publisher = &id
}

// ClearPublisher clears the "publisher" edge to the User entity.
func (m *GigTrackingMutation) ClearPublisher() {
	m.clearedpublisher = true
}

// PublisherCleared reports if the "publisher" edge to the User entity was cleared.
func (m *GigTrackingMutation) PublisherCleared() bool {
	return m.clearedpublisher
}

// PublisherID returns the "publisher" edge ID in the mutation.
func (m *GigTrackingMutation) PublisherID() (id int64, exists bool) {
	if m.publisher != nil {
		return *m.publisher, true
	}
	return
}

// PublisherIDs returns the "publisher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublisherID instead. It exists only for internal usage by the builders.
func (m *GigTrackingMutation) PublisherIDs() (ids []int64) {
	if id := m.publisher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublisher resets all changes to the "publisher" edge.
func (m *GigTrackingMutation) ResetPublisher() {
	m.publisher = nil
	m.clearedpublisher = false
}

// Where appends a list predicates to the GigTrackingMutation builder.
func (m *GigTrackingMutation) Where(ps ...predicate.GigTracking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GigTrackingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GigTrackingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GigTracking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GigTrackingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GigTrackingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GigTracking).
func (m *GigTrackingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GigTrackingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.date != nil {
		fields = append(fields, gigtracking.FieldDate)
	}
	if m._type != nil {
		fields = append(fields, gigtracking.FieldType)
	}
	if m.utm_query != nil {
		fields = append(fields, gigtracking.FieldUtmQuery)
	}
	if m.lp != nil {
		fields = append(fields, gigtracking.FieldLp)
	}
	if m.track_id != nil {
		fields = append(fields, gigtracking.FieldTrackID)
	}
	if m.revenue != nil {
		fields = append(fields, gigtracking.FieldRevenue)
	}
	if m.created_at != nil {
		fields = append(fields, gigtracking.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gigtracking.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GigTrackingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gigtracking.FieldDate:
		return m.Date()
	case gigtracking.FieldType:
		return m.GetType()
	case gigtracking.FieldUtmQuery:
		return m.UtmQuery()
	case gigtracking.FieldLp:
		return m.Lp()
	case gigtracking.FieldTrackID:
		return m.TrackID()
	case gigtracking.FieldRevenue:
		return m.Revenue()
	case gigtracking.FieldCreatedAt:
		return m.CreatedAt()
	case gigtracking.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GigTrackingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gigtracking.FieldDate:
		return m.OldDate(ctx)
	case gigtracking.FieldType:
		return m.OldType(ctx)
	case gigtracking.FieldUtmQuery:
		return m.OldUtmQuery(ctx)
	case gigtracking.FieldLp:
		return m.OldLp(ctx)
	case gigtracking.FieldTrackID:
		return m.OldTrackID(ctx)
	case gigtracking.FieldRevenue:
		return m.OldRevenue(ctx)
	case gigtracking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gigtracking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GigTracking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GigTrackingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gigtracking.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case gigtracking.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case gigtracking.FieldUtmQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUtmQuery(v)
		return nil
	case gigtracking.FieldLp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLp(v)
		return nil
	case gigtracking.FieldTrackID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackID(v)
		return nil
	case gigtracking.FieldRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenue(v)
		return nil
	case gigtracking.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gigtracking.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GigTracking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GigTrackingMutation) AddedFields() []string {
	var fields []string
	if m.addrevenue != nil {
		fields = append(fields, gigtracking.FieldRevenue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GigTrackingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gigtracking.FieldRevenue:
		return m.AddedRevenue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GigTrackingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gigtracking.FieldRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenue(v)
		return nil
	}
	return fmt.Errorf("unknown GigTracking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GigTrackingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gigtracking.FieldUtmQuery) {
		fields = append(fields, gigtracking.FieldUtmQuery)
	}
	if m.FieldCleared(gigtracking.FieldLp) {
		fields = append(fields, gigtracking.FieldLp)
	}
	if m.FieldCleared(gigtracking.FieldTrackID) {
		fields = append(fields, gigtracking.FieldTrackID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GigTrackingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GigTrackingMutation) ClearField(name string) error {
	switch name {
	case gigtracking.FieldUtmQuery:
		m.ClearUtmQuery()
		return nil
	case gigtracking.FieldLp:
		m.ClearLp()
		return nil
	case gigtracking.FieldTrackID:
		m.ClearTrackID()
		return nil
	}
	return fmt.Errorf("unknown GigTracking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GigTrackingMutation) ResetField(name string) error {
	switch name {
	case gigtracking.FieldDate:
		m.ResetDate()
		return nil
	case gigtracking.FieldType:
		m.ResetType()
		return nil
	case gigtracking.FieldUtmQuery:
		m.ResetUtmQuery()
		return nil
	case gigtracking.FieldLp:
		m.ResetLp()
		return nil
	case gigtracking.FieldTrackID:
		m.ResetTrackID()
		return nil
	case gigtracking.FieldRevenue:
		m.ResetRevenue()
		return nil
	case gigtracking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gigtracking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown GigTracking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GigTrackingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.publisher != nil {
		edges = append(edges, gigtracking.EdgePublisher)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GigTrackingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gigtracking.EdgePublisher:
		if id := m.publisher; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GigTrackingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GigTrackingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GigTrackingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpublisher {
		edges = append(edges, gigtracking.EdgePublisher)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GigTrackingMutation) EdgeCleared(name string) bool {
	switch name {
	case gigtracking.EdgePublisher:
		return m.clearedpublisher
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GigTrackingMutation) ClearEdge(name string) error {
	switch name {
	case gigtracking.EdgePublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown GigTracking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GigTrackingMutation) ResetEdge(name string) error {
	switch name {
	case gigtracking.EdgePublisher:
		m.ResetPublisher()
		return nil
	}
	return fmt.Errorf("unknown GigTracking edge %s", name)
}

// LeadMutation represents an operation that mutates the Lead nodes in the graph.
type LeadMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	reference_id  *string
	_type         *lead.Type
	amount        *float64
	addamount     *float64
	currency      *string
	ip_address    *string
	user_agent    *string
	metadata      *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	banner        *int64
	clearedbanner bool
	done          bool
	oldValue      func(context.Context) (*Lead, error)
	predicates    []predicate.Lead
}

var _ ent.Mutation = (*LeadMutation)(nil)

// leadOption allows management of the mutation configuration using functional options.
type leadOption func(*LeadMutation)

// newLeadMutation creates new mutation for the Lead entity.
func newLeadMutation(c config, op Op, opts ...leadOption) *LeadMutation {
	m := &LeadMutation{
		config:        c,
		op:            op,
		typ:           TypeLead,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeadID sets the ID field of the mutation.
func withLeadID(id int64) leadOption {
	return func(m *LeadMutation) {
		var (
			err   error
			once  sync.Once
			value *Lead
		)
		m.oldValue = func(ctx context.Context) (*Lead, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lead.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLead sets the old Lead of the mutation.
func withLead(node *Lead) leadOption {
	return func(m *LeadMutation) {
		m.oldValue = func(context.Context) (*Lead, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Lead entities.
func (m *LeadMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeadMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeadMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lead.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReferenceID sets the "reference_id" field.
func (m *LeadMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *LeadMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *LeadMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[lead.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *LeadMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[lead.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *LeadMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, lead.FieldReferenceID)
}

// SetType sets the "type" field.
func (m *LeadMutation) SetType(l lead.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LeadMutation) GetType() (r lead.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldType(ctx context.Context) (v lead.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LeadMutation) ResetType() {
	m._type = nil
}

// SetAmount sets the "amount" field.
func (m *LeadMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *LeadMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *LeadMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *LeadMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *LeadMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[lead.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *LeadMutation) AmountCleared() bool {
	_, ok := m.clearedFields[lead.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *LeadMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, lead.FieldAmount)
}

// SetCurrency sets the "currency" field.
func (m *LeadMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *LeadMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *LeadMutation) ResetCurrency() {
	m.currency = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *LeadMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *LeadMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *LeadMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[lead.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *LeadMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[lead.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *LeadMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, lead.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *LeadMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LeadMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LeadMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[lead.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LeadMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[lead.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LeadMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, lead.FieldUserAgent)
}

// SetMetadata sets the "metadata" field.
func (m *LeadMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LeadMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LeadMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[lead.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LeadMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[lead.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LeadMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, lead.FieldMetadata)
}

// SetCreatedAt sets the "created_at" field.
func (m *LeadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Lead entity.
// If the Lead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetBannerID sets the "banner" edge to the Banner entity by id.
func (m *LeadMutation) SetBannerID(id int64) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *LeadMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *LeadMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *LeadMutation) BannerID() (id int64, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *LeadMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *LeadMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the LeadMutation builder.
func (m *LeadMutation) Where(ps ...predicate.Lead) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lead, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lead).
func (m *LeadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeadMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.reference_id != nil {
		fields = append(fields, lead.FieldReferenceID)
	}
	if m._type != nil {
		fields = append(fields, lead.FieldType)
	}
	if m.amount != nil {
		fields = append(fields, lead.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, lead.FieldCurrency)
	}
	if m.ip_address != nil {
		fields = append(fields, lead.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, lead.FieldUserAgent)
	}
	if m.metadata != nil {
		fields = append(fields, lead.FieldMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, lead.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldReferenceID:
		return m.ReferenceID()
	case lead.FieldType:
		return m.GetType()
	case lead.FieldAmount:
		return m.Amount()
	case lead.FieldCurrency:
		return m.Currency()
	case lead.FieldIPAddress:
		return m.IPAddress()
	case lead.FieldUserAgent:
		return m.UserAgent()
	case lead.FieldMetadata:
		return m.Metadata()
	case lead.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lead.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case lead.FieldType:
		return m.OldType(ctx)
	case lead.FieldAmount:
		return m.OldAmount(ctx)
	case lead.FieldCurrency:
		return m.OldCurrency(ctx)
	case lead.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case lead.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case lead.FieldMetadata:
		return m.OldMetadata(ctx)
	case lead.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Lead field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lead.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case lead.FieldType:
		v, ok := value.(lead.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case lead.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case lead.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case lead.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case lead.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case lead.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case lead.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeadMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, lead.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lead.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lead.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Lead numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lead.FieldReferenceID) {
		fields = append(fields, lead.FieldReferenceID)
	}
	if m.FieldCleared(lead.FieldAmount) {
		fields = append(fields, lead.FieldAmount)
	}
	if m.FieldCleared(lead.FieldIPAddress) {
		fields = append(fields, lead.FieldIPAddress)
	}
	if m.FieldCleared(lead.FieldUserAgent) {
		fields = append(fields, lead.FieldUserAgent)
	}
	if m.FieldCleared(lead.FieldMetadata) {
		fields = append(fields, lead.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeadMutation) ClearField(name string) error {
	switch name {
	case lead.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case lead.FieldAmount:
		m.ClearAmount()
		return nil
	case lead.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case lead.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case lead.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Lead nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeadMutation) ResetField(name string) error {
	switch name {
	case lead.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case lead.FieldType:
		m.ResetType()
		return nil
	case lead.FieldAmount:
		m.ResetAmount()
		return nil
	case lead.FieldCurrency:
		m.ResetCurrency()
		return nil
	case lead.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case lead.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case lead.FieldMetadata:
		m.ResetMetadata()
		return nil
	case lead.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Lead field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner != nil {
		edges = append(edges, lead.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lead.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner {
		edges = append(edges, lead.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeadMutation) EdgeCleared(name string) bool {
	switch name {
	case lead.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeadMutation) ClearEdge(name string) error {
	switch name {
	case lead.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown Lead unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeadMutation) ResetEdge(name string) error {
	switch name {
	case lead.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown Lead edge %s", name)
}

// PayoutMutation represents an operation that mutates the Payout nodes in the graph.
type PayoutMutation struct {
	config
	op             Op
	typ            string
	id             *string
	amount         *float64
	addamount      *float64
	paid_at        *time.Time
	status         *payout.Status
	transaction_id *string
	clearedFields  map[string]struct{}
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Payout, error)
	predicates     []predicate.Payout
}

var _ ent.Mutation = (*PayoutMutation)(nil)

// payoutOption allows management of the mutation configuration using functional options.
type payoutOption func(*PayoutMutation)

// newPayoutMutation creates new mutation for the Payout entity.
func newPayoutMutation(c config, op Op, opts ...payoutOption) *PayoutMutation {
	m := &PayoutMutation{
		config:        c,
		op:            op,
		typ:           TypePayout,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayoutID sets the ID field of the mutation.
func withPayoutID(id string) payoutOption {
	return func(m *PayoutMutation) {
		var (
			err   error
			once  sync.Once
			value *Payout
		)
		m.oldValue = func(ctx context.Context) (*Payout, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payout.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayout sets the old Payout of the mutation.
func withPayout(node *Payout) payoutOption {
	return func(m *PayoutMutation) {
		m.oldValue = func(context.Context) (*Payout, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayoutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayoutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payout entities.
func (m *PayoutMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayoutMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayoutMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payout.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *PayoutMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PayoutMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PayoutMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PayoutMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PayoutMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *PayoutMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PayoutMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldPaidAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PayoutMutation) ResetPaidAt() {
	m.paid_at = nil
}

// SetStatus sets the "status" field.
func (m *PayoutMutation) SetStatus(pa payout.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PayoutMutation) Status() (r payout.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldStatus(ctx context.Context) (v payout.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PayoutMutation) ResetStatus() {
	m.status = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *PayoutMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *PayoutMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Payout entity.
// If the Payout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayoutMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ClearTransactionID clears the value of the "transaction_id" field.
func (m *PayoutMutation) ClearTransactionID() {
	m.transaction_id = nil
	m.clearedFields[payout.FieldTransactionID] = struct{}{}
}

// TransactionIDCleared returns if the "transaction_id" field was cleared in this mutation.
func (m *PayoutMutation) TransactionIDCleared() bool {
	_, ok := m.clearedFields[payout.FieldTransactionID]
	return ok
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *PayoutMutation) ResetTransactionID() {
	m.transaction_id = nil
	delete(m.clearedFields, payout.FieldTransactionID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PayoutMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PayoutMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PayoutMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PayoutMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PayoutMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PayoutMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PayoutMutation builder.
func (m *PayoutMutation) Where(ps ...predicate.Payout) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PayoutMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PayoutMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payout, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PayoutMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PayoutMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payout).
func (m *PayoutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayoutMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.amount != nil {
		fields = append(fields, payout.FieldAmount)
	}
	if m.paid_at != nil {
		fields = append(fields, payout.FieldPaidAt)
	}
	if m.status != nil {
		fields = append(fields, payout.FieldStatus)
	}
	if m.transaction_id != nil {
		fields = append(fields, payout.FieldTransactionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayoutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payout.FieldAmount:
		return m.Amount()
	case payout.FieldPaidAt:
		return m.PaidAt()
	case payout.FieldStatus:
		return m.Status()
	case payout.FieldTransactionID:
		return m.TransactionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayoutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payout.FieldAmount:
		return m.OldAmount(ctx)
	case payout.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case payout.FieldStatus:
		return m.OldStatus(ctx)
	case payout.FieldTransactionID:
		return m.OldTransactionID(ctx)
	}
	return nil, fmt.Errorf("unknown Payout field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayoutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payout.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payout.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case payout.FieldStatus:
		v, ok := value.(payout.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case payout.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	}
	return fmt.Errorf("unknown Payout field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayoutMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payout.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayoutMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payout.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayoutMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payout.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payout numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayoutMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payout.FieldTransactionID) {
		fields = append(fields, payout.FieldTransactionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayoutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayoutMutation) ClearField(name string) error {
	switch name {
	case payout.FieldTransactionID:
		m.ClearTransactionID()
		return nil
	}
	return fmt.Errorf("unknown Payout nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayoutMutation) ResetField(name string) error {
	switch name {
	case payout.FieldAmount:
		m.ResetAmount()
		return nil
	case payout.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case payout.FieldStatus:
		m.ResetStatus()
		return nil
	case payout.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	}
	return fmt.Errorf("unknown Payout field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayoutMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, payout.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayoutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payout.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayoutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayoutMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayoutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, payout.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayoutMutation) EdgeCleared(name string) bool {
	switch name {
	case payout.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayoutMutation) ClearEdge(name string) error {
	switch name {
	case payout.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Payout unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayoutMutation) ResetEdge(name string) error {
	switch name {
	case payout.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Payout edge %s", name)
}

// TestMutation represents an operation that mutates the Test nodes in the graph.
type TestMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Test, error)
	predicates    []predicate.Test
}

var _ ent.Mutation = (*TestMutation)(nil)

// testOption allows management of the mutation configuration using functional options.
type testOption func(*TestMutation)

// newTestMutation creates new mutation for the Test entity.
func newTestMutation(c config, op Op, opts ...testOption) *TestMutation {
	m := &TestMutation{
		config:        c,
		op:            op,
		typ:           TypeTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestID sets the ID field of the mutation.
func withTestID(id int) testOption {
	return func(m *TestMutation) {
		var (
			err   error
			once  sync.Once
			value *Test
		)
		m.oldValue = func(ctx context.Context) (*Test, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest sets the old Test of the mutation.
func withTest(node *Test) testOption {
	return func(m *TestMutation) {
		m.oldValue = func(context.Context) (*Test, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the TestMutation builder.
func (m *TestMutation) Where(ps ...predicate.Test) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test).
func (m *TestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Test field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Test numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Test nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Test field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Test unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Test edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	username               *string
	email                  *string
	password_hash          *string
	first_name             *string
	last_name              *string
	role                   *user.Role
	created_at             *time.Time
	updated_at             *time.Time
	is_active              *bool
	last_login             *time.Time
	reset_token            *string
	reset_token_expires_at *time.Time
	clearedFields          map[string]struct{}
	campaigns              map[int64]struct{}
	removedcampaigns       map[int64]struct{}
	clearedcampaigns       bool
	payouts                map[string]struct{}
	removedpayouts         map[string]struct{}
	clearedpayouts         bool
	stats                  map[int64]struct{}
	removedstats           map[int64]struct{}
	clearedstats           bool
	gig_trackings          map[int64]struct{}
	removedgig_trackings   map[int64]struct{}
	clearedgig_trackings   bool
	commission_plan        *int
	clearedcommission_plan bool
	affiliates             map[int64]struct{}
	removedaffiliates      map[int64]struct{}
	clearedaffiliates      bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// SetResetToken sets the "reset_token" field.
func (m *UserMutation) SetResetToken(s string) {
	m.reset_token = &s
}

// ResetToken returns the value of the "reset_token" field in the mutation.
func (m *UserMutation) ResetToken() (r string, exists bool) {
	v := m.reset_token
	if v == nil {
		return
	}
	return *v, true
}

// OldResetToken returns the old "reset_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldResetToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetToken: %w", err)
	}
	return oldValue.ResetToken, nil
}

// ClearResetToken clears the value of the "reset_token" field.
func (m *UserMutation) ClearResetToken() {
	m.reset_token = nil
	m.clearedFields[user.FieldResetToken] = struct{}{}
}

// ResetTokenCleared returns if the "reset_token" field was cleared in this mutation.
func (m *UserMutation) ResetTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldResetToken]
	return ok
}

// ResetResetToken resets all changes to the "reset_token" field.
func (m *UserMutation) ResetResetToken() {
	m.reset_token = nil
	delete(m.clearedFields, user.FieldResetToken)
}

// SetResetTokenExpiresAt sets the "reset_token_expires_at" field.
func (m *UserMutation) SetResetTokenExpiresAt(t time.Time) {
	m.reset_token_expires_at = &t
}

// ResetTokenExpiresAt returns the value of the "reset_token_expires_at" field in the mutation.
func (m *UserMutation) ResetTokenExpiresAt() (r time.Time, exists bool) {
	v := m.reset_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldResetTokenExpiresAt returns the old "reset_token_expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldResetTokenExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetTokenExpiresAt: %w", err)
	}
	return oldValue.ResetTokenExpiresAt, nil
}

// ClearResetTokenExpiresAt clears the value of the "reset_token_expires_at" field.
func (m *UserMutation) ClearResetTokenExpiresAt() {
	m.reset_token_expires_at = nil
	m.clearedFields[user.FieldResetTokenExpiresAt] = struct{}{}
}

// ResetTokenExpiresAtCleared returns if the "reset_token_expires_at" field was cleared in this mutation.
func (m *UserMutation) ResetTokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldResetTokenExpiresAt]
	return ok
}

// ResetResetTokenExpiresAt resets all changes to the "reset_token_expires_at" field.
func (m *UserMutation) ResetResetTokenExpiresAt() {
	m.reset_token_expires_at = nil
	delete(m.clearedFields, user.FieldResetTokenExpiresAt)
}

// AddCampaignIDs adds the "campaigns" edge to the Campaign entity by ids.
func (m *UserMutation) AddCampaignIDs(ids ...int64) {
	if m.campaigns == nil {
		m.campaigns = make(map[int64]struct{})
	}
	for i := range ids {
		m.campaigns[ids[i]] = struct{}{}
	}
}

// ClearCampaigns clears the "campaigns" edge to the Campaign entity.
func (m *UserMutation) ClearCampaigns() {
	m.clearedcampaigns = true
}

// CampaignsCleared reports if the "campaigns" edge to the Campaign entity was cleared.
func (m *UserMutation) CampaignsCleared() bool {
	return m.clearedcampaigns
}

// RemoveCampaignIDs removes the "campaigns" edge to the Campaign entity by IDs.
func (m *UserMutation) RemoveCampaignIDs(ids ...int64) {
	if m.removedcampaigns == nil {
		m.removedcampaigns = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.campaigns, ids[i])
		m.removedcampaigns[ids[i]] = struct{}{}
	}
}

// RemovedCampaigns returns the removed IDs of the "campaigns" edge to the Campaign entity.
func (m *UserMutation) RemovedCampaignsIDs() (ids []int64) {
	for id := range m.removedcampaigns {
		ids = append(ids, id)
	}
	return
}

// CampaignsIDs returns the "campaigns" edge IDs in the mutation.
func (m *UserMutation) CampaignsIDs() (ids []int64) {
	for id := range m.campaigns {
		ids = append(ids, id)
	}
	return
}

// ResetCampaigns resets all changes to the "campaigns" edge.
func (m *UserMutation) ResetCampaigns() {
	m.campaigns = nil
	m.clearedcampaigns = false
	m.removedcampaigns = nil
}

// AddPayoutIDs adds the "payouts" edge to the Payout entity by ids.
func (m *UserMutation) AddPayoutIDs(ids ...string) {
	if m.payouts == nil {
		m.payouts = make(map[string]struct{})
	}
	for i := range ids {
		m.payouts[ids[i]] = struct{}{}
	}
}

// ClearPayouts clears the "payouts" edge to the Payout entity.
func (m *UserMutation) ClearPayouts() {
	m.clearedpayouts = true
}

// PayoutsCleared reports if the "payouts" edge to the Payout entity was cleared.
func (m *UserMutation) PayoutsCleared() bool {
	return m.clearedpayouts
}

// RemovePayoutIDs removes the "payouts" edge to the Payout entity by IDs.
func (m *UserMutation) RemovePayoutIDs(ids ...string) {
	if m.removedpayouts == nil {
		m.removedpayouts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.payouts, ids[i])
		m.removedpayouts[ids[i]] = struct{}{}
	}
}

// RemovedPayouts returns the removed IDs of the "payouts" edge to the Payout entity.
func (m *UserMutation) RemovedPayoutsIDs() (ids []string) {
	for id := range m.removedpayouts {
		ids = append(ids, id)
	}
	return
}

// PayoutsIDs returns the "payouts" edge IDs in the mutation.
func (m *UserMutation) PayoutsIDs() (ids []string) {
	for id := range m.payouts {
		ids = append(ids, id)
	}
	return
}

// ResetPayouts resets all changes to the "payouts" edge.
func (m *UserMutation) ResetPayouts() {
	m.payouts = nil
	m.clearedpayouts = false
	m.removedpayouts = nil
}

// AddStatIDs adds the "stats" edge to the BannerStats entity by ids.
func (m *UserMutation) AddStatIDs(ids ...int64) {
	if m.stats == nil {
		m.stats = make(map[int64]struct{})
	}
	for i := range ids {
		m.stats[ids[i]] = struct{}{}
	}
}

// ClearStats clears the "stats" edge to the BannerStats entity.
func (m *UserMutation) ClearStats() {
	m.clearedstats = true
}

// StatsCleared reports if the "stats" edge to the BannerStats entity was cleared.
func (m *UserMutation) StatsCleared() bool {
	return m.clearedstats
}

// RemoveStatIDs removes the "stats" edge to the BannerStats entity by IDs.
func (m *UserMutation) RemoveStatIDs(ids ...int64) {
	if m.removedstats == nil {
		m.removedstats = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.stats, ids[i])
		m.removedstats[ids[i]] = struct{}{}
	}
}

// RemovedStats returns the removed IDs of the "stats" edge to the BannerStats entity.
func (m *UserMutation) RemovedStatsIDs() (ids []int64) {
	for id := range m.removedstats {
		ids = append(ids, id)
	}
	return
}

// StatsIDs returns the "stats" edge IDs in the mutation.
func (m *UserMutation) StatsIDs() (ids []int64) {
	for id := range m.stats {
		ids = append(ids, id)
	}
	return
}

// ResetStats resets all changes to the "stats" edge.
func (m *UserMutation) ResetStats() {
	m.stats = nil
	m.clearedstats = false
	m.removedstats = nil
}

// AddGigTrackingIDs adds the "gig_trackings" edge to the GigTracking entity by ids.
func (m *UserMutation) AddGigTrackingIDs(ids ...int64) {
	if m.gig_trackings == nil {
		m.gig_trackings = make(map[int64]struct{})
	}
	for i := range ids {
		m.gig_trackings[ids[i]] = struct{}{}
	}
}

// ClearGigTrackings clears the "gig_trackings" edge to the GigTracking entity.
func (m *UserMutation) ClearGigTrackings() {
	m.clearedgig_trackings = true
}

// GigTrackingsCleared reports if the "gig_trackings" edge to the GigTracking entity was cleared.
func (m *UserMutation) GigTrackingsCleared() bool {
	return m.clearedgig_trackings
}

// RemoveGigTrackingIDs removes the "gig_trackings" edge to the GigTracking entity by IDs.
func (m *UserMutation) RemoveGigTrackingIDs(ids ...int64) {
	if m.removedgig_trackings == nil {
		m.removedgig_trackings = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.gig_trackings, ids[i])
		m.removedgig_trackings[ids[i]] = struct{}{}
	}
}

// RemovedGigTrackings returns the removed IDs of the "gig_trackings" edge to the GigTracking entity.
func (m *UserMutation) RemovedGigTrackingsIDs() (ids []int64) {
	for id := range m.removedgig_trackings {
		ids = append(ids, id)
	}
	return
}

// GigTrackingsIDs returns the "gig_trackings" edge IDs in the mutation.
func (m *UserMutation) GigTrackingsIDs() (ids []int64) {
	for id := range m.gig_trackings {
		ids = append(ids, id)
	}
	return
}

// ResetGigTrackings resets all changes to the "gig_trackings" edge.
func (m *UserMutation) ResetGigTrackings() {
	m.gig_trackings = nil
	m.clearedgig_trackings = false
	m.removedgig_trackings = nil
}

// SetCommissionPlanID sets the "commission_plan" edge to the CommissionPlan entity by id.
func (m *UserMutation) SetCommissionPlanID(id int) {
	m.commission_plan = &id
}

// ClearCommissionPlan clears the "commission_plan" edge to the CommissionPlan entity.
func (m *UserMutation) ClearCommissionPlan() {
	m.clearedcommission_plan = true
}

// CommissionPlanCleared reports if the "commission_plan" edge to the CommissionPlan entity was cleared.
func (m *UserMutation) CommissionPlanCleared() bool {
	return m.clearedcommission_plan
}

// CommissionPlanID returns the "commission_plan" edge ID in the mutation.
func (m *UserMutation) CommissionPlanID() (id int, exists bool) {
	if m.commission_plan != nil {
		return *m.commission_plan, true
	}
	return
}

// CommissionPlanIDs returns the "commission_plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommissionPlanID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CommissionPlanIDs() (ids []int) {
	if id := m.commission_plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommissionPlan resets all changes to the "commission_plan" edge.
func (m *UserMutation) ResetCommissionPlan() {
	m.commission_plan = nil
	m.clearedcommission_plan = false
}

// AddAffiliateIDs adds the "affiliates" edge to the Affiliate entity by ids.
func (m *UserMutation) AddAffiliateIDs(ids ...int64) {
	if m.affiliates == nil {
		m.affiliates = make(map[int64]struct{})
	}
	for i := range ids {
		m.affiliates[ids[i]] = struct{}{}
	}
}

// ClearAffiliates clears the "affiliates" edge to the Affiliate entity.
func (m *UserMutation) ClearAffiliates() {
	m.clearedaffiliates = true
}

// AffiliatesCleared reports if the "affiliates" edge to the Affiliate entity was cleared.
func (m *UserMutation) AffiliatesCleared() bool {
	return m.clearedaffiliates
}

// RemoveAffiliateIDs removes the "affiliates" edge to the Affiliate entity by IDs.
func (m *UserMutation) RemoveAffiliateIDs(ids ...int64) {
	if m.removedaffiliates == nil {
		m.removedaffiliates = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.affiliates, ids[i])
		m.removedaffiliates[ids[i]] = struct{}{}
	}
}

// RemovedAffiliates returns the removed IDs of the "affiliates" edge to the Affiliate entity.
func (m *UserMutation) RemovedAffiliatesIDs() (ids []int64) {
	for id := range m.removedaffiliates {
		ids = append(ids, id)
	}
	return
}

// AffiliatesIDs returns the "affiliates" edge IDs in the mutation.
func (m *UserMutation) AffiliatesIDs() (ids []int64) {
	for id := range m.affiliates {
		ids = append(ids, id)
	}
	return
}

// ResetAffiliates resets all changes to the "affiliates" edge.
func (m *UserMutation) ResetAffiliates() {
	m.affiliates = nil
	m.clearedaffiliates = false
	m.removedaffiliates = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.reset_token != nil {
		fields = append(fields, user.FieldResetToken)
	}
	if m.reset_token_expires_at != nil {
		fields = append(fields, user.FieldResetTokenExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldResetToken:
		return m.ResetToken()
	case user.FieldResetTokenExpiresAt:
		return m.ResetTokenExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldResetToken:
		return m.OldResetToken(ctx)
	case user.FieldResetTokenExpiresAt:
		return m.OldResetTokenExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldResetToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetToken(v)
		return nil
	case user.FieldResetTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetTokenExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.FieldCleared(user.FieldResetToken) {
		fields = append(fields, user.FieldResetToken)
	}
	if m.FieldCleared(user.FieldResetTokenExpiresAt) {
		fields = append(fields, user.FieldResetTokenExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	case user.FieldResetToken:
		m.ClearResetToken()
		return nil
	case user.FieldResetTokenExpiresAt:
		m.ClearResetTokenExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldResetToken:
		m.ResetResetToken()
		return nil
	case user.FieldResetTokenExpiresAt:
		m.ResetResetTokenExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.campaigns != nil {
		edges = append(edges, user.EdgeCampaigns)
	}
	if m.payouts != nil {
		edges = append(edges, user.EdgePayouts)
	}
	if m.stats != nil {
		edges = append(edges, user.EdgeStats)
	}
	if m.gig_trackings != nil {
		edges = append(edges, user.EdgeGigTrackings)
	}
	if m.commission_plan != nil {
		edges = append(edges, user.EdgeCommissionPlan)
	}
	if m.affiliates != nil {
		edges = append(edges, user.EdgeAffiliates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.campaigns))
		for id := range m.campaigns {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayouts:
		ids := make([]ent.Value, 0, len(m.payouts))
		for id := range m.payouts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStats:
		ids := make([]ent.Value, 0, len(m.stats))
		for id := range m.stats {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGigTrackings:
		ids := make([]ent.Value, 0, len(m.gig_trackings))
		for id := range m.gig_trackings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCommissionPlan:
		if id := m.commission_plan; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAffiliates:
		ids := make([]ent.Value, 0, len(m.affiliates))
		for id := range m.affiliates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedcampaigns != nil {
		edges = append(edges, user.EdgeCampaigns)
	}
	if m.removedpayouts != nil {
		edges = append(edges, user.EdgePayouts)
	}
	if m.removedstats != nil {
		edges = append(edges, user.EdgeStats)
	}
	if m.removedgig_trackings != nil {
		edges = append(edges, user.EdgeGigTrackings)
	}
	if m.removedaffiliates != nil {
		edges = append(edges, user.EdgeAffiliates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCampaigns:
		ids := make([]ent.Value, 0, len(m.removedcampaigns))
		for id := range m.removedcampaigns {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayouts:
		ids := make([]ent.Value, 0, len(m.removedpayouts))
		for id := range m.removedpayouts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStats:
		ids := make([]ent.Value, 0, len(m.removedstats))
		for id := range m.removedstats {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGigTrackings:
		ids := make([]ent.Value, 0, len(m.removedgig_trackings))
		for id := range m.removedgig_trackings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAffiliates:
		ids := make([]ent.Value, 0, len(m.removedaffiliates))
		for id := range m.removedaffiliates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcampaigns {
		edges = append(edges, user.EdgeCampaigns)
	}
	if m.clearedpayouts {
		edges = append(edges, user.EdgePayouts)
	}
	if m.clearedstats {
		edges = append(edges, user.EdgeStats)
	}
	if m.clearedgig_trackings {
		edges = append(edges, user.EdgeGigTrackings)
	}
	if m.clearedcommission_plan {
		edges = append(edges, user.EdgeCommissionPlan)
	}
	if m.clearedaffiliates {
		edges = append(edges, user.EdgeAffiliates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCampaigns:
		return m.clearedcampaigns
	case user.EdgePayouts:
		return m.clearedpayouts
	case user.EdgeStats:
		return m.clearedstats
	case user.EdgeGigTrackings:
		return m.clearedgig_trackings
	case user.EdgeCommissionPlan:
		return m.clearedcommission_plan
	case user.EdgeAffiliates:
		return m.clearedaffiliates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCommissionPlan:
		m.ClearCommissionPlan()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCampaigns:
		m.ResetCampaigns()
		return nil
	case user.EdgePayouts:
		m.ResetPayouts()
		return nil
	case user.EdgeStats:
		m.ResetStats()
		return nil
	case user.EdgeGigTrackings:
		m.ResetGigTrackings()
		return nil
	case user.EdgeCommissionPlan:
		m.ResetCommissionPlan()
		return nil
	case user.EdgeAffiliates:
		m.ResetAffiliates()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
